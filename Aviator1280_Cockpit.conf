name: Aviator1280_Cokpit

slots:
    core:
        class: CoreUnit
        select: 1
    gyro:
        class: GyroUnit
        select: 1
    warpdrive:
        class: WarpDriveUnit
        select: 1
    atmofueltank:
        class: AtmoFuelContainer
        select: all
    spacefueltank:
        class: SpaceFuelContainer
        select: all
    rocketfueltank:
        class: RocketFuelContainer
        select: all
    weapon:
        class: WeaponUnit
        select: manual
    radar:
        class: RadarPVPUnit
        select: manual
    container:
        class: ItemContainer
        select: manual
    databank:
        class: databank
        select: 1
    radio_alt:
        class: VerticalBooster
        select: 1
    antigrav:
        class: AntiGravityGeneratorUnit
handlers:
    unit:
        start:
            lua: |
                --[[

                Author: Aviator1280

                --]]

                -- DU CODE
                    Nav = Navigator.new(system, core, unit)
                    Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})
                    Nav.axisCommandManager:setTargetGroundAltitude(0)

                    -- element widgets
                    -- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.
                    _autoconf.displayCategoryPanel(weapon, weapon_size, "Weapons", "weapon", true)
                    core.show()
                    _autoconf.displayCategoryPanel(radar, radar_size, "Periscope", "periscope")
                    placeRadar = true
                    if atmofueltank_size > 0 then
                        _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, "Atmo Fuel", "fuel_container")
                        if placeRadar then
                            _autoconf.displayCategoryPanel(radar, radar_size, "Radar", "radar")
                            placeRadar = false
                        end
                    end
                    if spacefueltank_size > 0 then
                        _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, "Space Fuel", "fuel_container")
                        if placeRadar then
                            _autoconf.displayCategoryPanel(radar, radar_size, "Radar", "radar")
                            placeRadar = false
                        end
                    end
                    _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, "Rocket Fuel", "fuel_container")
                    if placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels
                        _autoconf.displayCategoryPanel(radar, radar_size, "Radar", "radar")
                        placeRadar = false
                    end
                    if antigrav ~= nil then antigrav.show() end
                    if warpdrive ~= nil then warpdrive.show() end
                    if gyro ~= nil then gyro.show() end

                    -- freeze the player in he is remote controlling the construct
                    if Nav.control.isRemoteControlled() == 1 then
                        system.freeze(1)
                    end

                    -- landing gear
                    -- make sure every gears are synchonized with the first
                    gearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean
                    if gearExtended then
                        Nav.control.extendLandingGears()
                    else
                        Nav.control.retractLandingGears()
                    end

                --START HUD CODE
                    du_widgets = true
                    du_radar_widgets = true
                    loading_pg = true

                    if databank then
                        if databank.getFloatValue("navigator_pe_target_altitude") ~= nil then
                            PeTargetAlt = databank.getFloatValue("navigator_pe_target_altitude")
                        else
                            PeTargetAlt = 20000
                        end
                    else
                        PeTargetAlt = 20000 --export: Pe Target altitude
                    end


                --TOOLS

                    --STRING CONVERTER TO VEC3
                        function vec3FromStr(vStr) -- to convert string to vec3
                            local v3 = {};
                            for num in string.gmatch(vStr, "[-%d%.]+") do
                                local vN = string.gsub(num, "%+", "")
                                table.insert(v3, tonumber(vN))
                            end
                        return vec3(table.unpack(v3))
                        end -- function vec3FromStr(vStr)

                    --AUTHOR JAYLE BREAK

                        --ATLAS
                            function atlas()
                                return {
                                [0] = {
                                  [1]={
                                    GM=6930729684,
                                    bodyId=1,
                                    center={x=17465536.000,y=22665536.000,z=-34464.000},
                                    name='Madis',
                                    planetarySystemId=0,
                                    radius=44300
                                  },
                                  [2]={
                                    GM=157470826617,
                                    bodyId=2,
                                    center={x=-8.000,y=-8.000,z=-126303.000},
                                    name='Alioth',
                                    planetarySystemId=0,
                                    radius=126068
                                  },
                                  [3]={
                                    GM=11776905000,
                                    bodyId=3,
                                    center={x=29165536.000,y=10865536.000,z=65536.000},
                                    name='Thades',
                                    planetarySystemId=0,
                                    radius=49000
                                  },
                                  [4]={
                                    GM=14893847582,
                                    bodyId=4,
                                    center={x=-13234464.000,y=55765536.000,z=465536.000},
                                    name='Talemai',
                                    planetarySystemId=0,
                                    radius=57450
                                  },
                                  [5]={
                                    GM=16951680000,
                                    bodyId=5,
                                    center={x=-43534464.000,y=22565536.000,z=-48934464.000},
                                    name='Feli',
                                    planetarySystemId=0,
                                    radius=60000
                                  },
                                  [6]={
                                    GM=10502547741,
                                    bodyId=6,
                                    center={x=52765536.000,y=27165538.000,z=52065535.000},
                                    name='Sicari',
                                    planetarySystemId=0,
                                    radius=51100
                                  },
                                  [7]={
                                    GM=13033380591,
                                    bodyId=7,
                                    center={x=58665538.000,y=29665535.000,z=58165535.000},
                                    name='Sinnen',
                                    planetarySystemId=0,
                                    radius=54950
                                  },
                                  [8]={
                                    GM=18477723600,
                                    bodyId=8,
                                    center={x=80865538.000,y=54665536.000,z=-934463.940},
                                    name='Teoma',
                                    planetarySystemId=0,
                                    radius=62000
                                  },
                                  [9]={
                                    GM=18606274330,
                                    bodyId=9,
                                    center={x=-94134462.000,y=12765534.000,z=-3634464.000},
                                    name='Jago',
                                    planetarySystemId=0,
                                    radius=61590
                                  },
                                  [10]={
                                    GM=78480000,
                                    bodyId=10,
                                    center={x=17448118.224,y=22966846.286,z=143078.820},
                                    name='Madis Moon 1',
                                    planetarySystemId=0,
                                    radius=10000
                                  },
                                  [11]={
                                    GM=237402000,
                                    bodyId=11,
                                    center={x=17194626.000,y=22243633.880,z=-214962.810},
                                    name='Madis Moon 2',
                                    planetarySystemId=0,
                                    radius=11000
                                  },
                                  [12]={
                                    GM=265046609,
                                    bodyId=12,
                                    center={x=17520614.000,y=22184730.000,z=-309989.990},
                                    name='Madis Moon 3',
                                    planetarySystemId=0,
                                    radius=15005
                                  },
                                  [21]={
                                    GM=2118960000,
                                    bodyId=21,
                                    center={x=457933.000,y=-1509011.000,z=115524.000},
                                    name='Alioth Moon 1',
                                    planetarySystemId=0,
                                    radius=30000
                                  },
                                  [22]={
                                    GM=2165833514,
                                    bodyId=22,
                                    center={x=-1692694.000,y=729681.000,z=-411464.000},
                                    name='Alioth Moon 4',
                                    planetarySystemId=0,
                                    radius=30330
                                  },
                                  [26]={
                                    GM=68234043600,
                                    bodyId=26,
                                    center={x=-1404835.000,y=562655.000,z=-285074.000},
                                    name='Sanctuary',
                                    planetarySystemId=0,
                                    radius=83400
                                  },
                                  [30]={
                                    GM=211564034,
                                    bodyId=30,
                                    center={x=29214402.000,y=10907080.695,z=433858.200},
                                    name='Thades Moon 1',
                                    planetarySystemId=0,
                                    radius=14002
                                  },
                                  [31]={
                                    GM=264870000,
                                    bodyId=31,
                                    center={x=29404193.000,y=10432768.000,z=19554.131},
                                    name='Thades Moon 2',
                                    planetarySystemId=0,
                                    radius=15000
                                  },
                                  [40]={
                                    GM=141264000,
                                    bodyId=40,
                                    center={x=-13503090.000,y=55594325.000,z=769838.640},
                                    name='Talemai Moon 2',
                                    planetarySystemId=0,
                                    radius=12000
                                  },
                                  [41]={
                                    GM=106830900,
                                    bodyId=41,
                                    center={x=-12800515.000,y=55700259.000,z=325207.840},
                                    name='Talemai Moon 3',
                                    planetarySystemId=0,
                                    radius=11000
                                  },
                                  [42]={
                                    GM=264870000,
                                    bodyId=42,
                                    center={x=-13058408.000,y=55781856.000,z=740177.760},
                                    name='Talemai Moon 1',
                                    planetarySystemId=0,
                                    radius=15000
                                  },
                                  [50]={
                                    GM=499917600,
                                    bodyId=50,
                                    center={x=-43902841.780,y=22261034.700,z=-48862386.000},
                                    name='Feli Moon 1',
                                    planetarySystemId=0,
                                    radius=14000
                                  },
                                  [70]={
                                    GM=396912600,
                                    bodyId=70,
                                    center={x=58969616.000,y=29797945.000,z=57969449.000},
                                    name='Sinnen Moon 1',
                                    planetarySystemId=0,
                                    radius=17000
                                  },
                                  [100]={
                                    GM=13975172474,
                                    bodyId=100,
                                    center={x=98865536.000,y=-13534464.000,z=-934461.990},
                                    name='Lacobus',
                                    planetarySystemId=0,
                                    radius=55650
                                  },
                                  [101]={
                                    GM=264870000,
                                    bodyId=101,
                                    center={x=98905288.170,y=-13950921.100,z=-647589.530},
                                    name='Lacobus Moon 3',
                                    planetarySystemId=0,
                                    radius=15000
                                  },
                                  [102]={
                                    GM=444981600,
                                    bodyId=102,
                                    center={x=99180968.000,y=-13783862.000,z=-926156.400},
                                    name='Lacobus Moon 1',
                                    planetarySystemId=0,
                                    radius=18000
                                  },
                                  [103]={
                                    GM=211503600,
                                    bodyId=103,
                                    center={x=99250052.000,y=-13629215.000,z=-1059341.400},
                                    name='Lacobus Moon 2',
                                    planetarySystemId=0,
                                    radius=14000
                                  },
                                  [110]={
                                    GM=9204742375,
                                    bodyId=110,
                                    center={x=14165536.000,y=-85634465.000,z=-934464.300},
                                    name='Symeon',
                                    planetarySystemId=0,
                                    radius=49050
                                  },
                                  [120]={
                                    GM=7135606629,
                                    bodyId=120,
                                    center={x=2865536.700,y=-99034464.000,z=-934462.020},
                                    name='Ion',
                                    planetarySystemId=0,
                                    radius=44950
                                  },
                                  [121]={
                                    GM=106830900,
                                    bodyId=121,
                                    center={x=2472916.800,y=-99133747.000,z=-1133582.800},
                                    name='Ion Moon 1',
                                    planetarySystemId=0,
                                    radius=11000
                                  },
                                  [122]={
                                    GM=176580000,
                                    bodyId=122,
                                    center={x=2995424.500,y=-99275010.000,z=-1378480.700},
                                    name='Ion Moon 2',
                                    planetarySystemId=0,
                                    radius=15000
                                  }  
                                 }
                                }
                            end -- function atlas()

                        --PLANETREF
                            function planetref()
                                local function isNumber(n)  return type(n)           == 'number' end
                                local function isSNumber(n) return type(tonumber(n)) == 'number' end
                                local function isTable(t)   return type(t)           == 'table'  end
                                local function isString(s)  return type(s)           == 'string' end
                                local function isVector(v)  return isTable(v)
                                                                    and isNumber(v.x and v.y and v.z) end

                                local function isMapPosition(m) return isTable(m) and isNumber(m.latitude  and
                                                                                               m.longitude and
                                                                                               m.altitude  and
                                                                                               m.bodyId    and
                                                                                               m.systemId) end

                                -- Constants

                                local deg2rad    = math.pi/180
                                local rad2deg    = 180/math.pi
                                local epsilon    = 1e-10
                                local num        = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'
                                local posPattern = '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' ..
                                                   num ..  ',' .. num .. '}'

                                -- Utilities

                                local utils  = require('cpml.utils')
                                local vec3   = require('cpml.vec3')
                                local clamp  = utils.clamp

                                local function float_eq(a,b)
                                    if a == 0 then return math.abs(b) < 1e-09 end
                                    if b == 0 then return math.abs(a) < 1e-09 end
                                    return math.abs(a - b) < math.max(math.abs(a),math.abs(b))*epsilon
                                end

                                local function formatNumber(n)
                                    local result = string.gsub(
                                                    string.reverse(string.format('%.4f',n)),
                                                    '^0*%.?','')
                                    return result == '' and '0' or string.reverse(result)
                                end

                                local function formatValue(obj)
                                    if isVector(obj) then
                                        return string.format('{x=%.3f,y=%.3f,z=%.3f}', obj.x, obj.y, obj.z)
                                    end

                                    if isTable(obj) and not getmetatable(obj) then
                                        local list = {}
                                        local nxt  = next(obj)

                                        if type(nxt) == 'nil' or nxt == 1 then -- assume this is an array
                                            list = obj
                                        else
                                            for k,v in pairs(obj) do
                                                local value = formatValue(v)
                                                if type(k) == 'number' then
                                                    table.insert(list, string.format('[%s]=%s', k, value))
                                                else
                                                    table.insert(list, string.format('%s=%s',   k, value))
                                                end
                                            end
                                        end
                                        return string.format('{%s}', table.concat(list, ','))
                                    end

                                    if isString(obj) then
                                        return string.format("'%s'", obj:gsub("'",[[\']]))
                                    end
                                    return tostring(obj)
                                end

                                -- CLASSES

                                local BodyParameters = {}
                                BodyParameters.__index = BodyParameters
                                BodyParameters.__tostring =
                                    function(obj, indent)
                                        local sep = indent or ''
                                        local keys = {}
                                        for k in pairs(obj) do table.insert(keys, k) end
                                        table.sort(keys)
                                        local list = {}
                                        for _, k in ipairs(keys) do
                                            local value = formatValue(obj[k])
                                            if type(k) == 'number' then
                                                table.insert(list, string.format('[%s]=%s', k, value))
                                            else
                                                table.insert(list, string.format('%s=%s', k, value))
                                            end
                                        end
                                        if indent then
                                            return string.format('%s%s',
                                                                 indent,
                                                                 table.concat(list, ',\n' .. indent))
                                        end
                                        return string.format('{%s}', table.concat(list, ','))
                                    end
                                BodyParameters.__eq = function(lhs, rhs)
                                        return lhs.planetarySystemId == rhs.planetarySystemId and
                                               lhs.bodyId            == rhs.bodyId            and
                                               float_eq(lhs.radius, rhs.radius)               and
                                               float_eq(lhs.center.x, rhs.center.x)           and
                                               float_eq(lhs.center.y, rhs.center.y)           and
                                               float_eq(lhs.center.z, rhs.center.z)           and
                                               float_eq(lhs.GM, rhs.GM)
                                    end

                                local function mkBodyParameters(systemId, bodyId, radius, worldCoordinates, GM)
                                    -- 'worldCoordinates' can be either table or vec3
                                    assert(isSNumber(systemId),
                                           'Argument 1 (planetarySystemId) must be a number:' .. type(systemId))
                                    assert(isSNumber(bodyId),
                                           'Argument 2 (bodyId) must be a number:' .. type(bodyId))
                                    assert(isSNumber(radius),
                                           'Argument 3 (radius) must be a number:' .. type(radius))
                                    assert(isTable(worldCoordinates),
                                           'Argument 4 (worldCoordinates) must be a array or vec3.' ..
                                           type(worldCoordinates))
                                    assert(isSNumber(GM),
                                           'Argument 5 (GM) must be a number:' .. type(GM))
                                    return setmetatable({planetarySystemId = tonumber(systemId),
                                                         bodyId            = tonumber(bodyId),
                                                         radius            = tonumber(radius),
                                                         center            = vec3(worldCoordinates),
                                                         GM                = tonumber(GM) }, BodyParameters)
                                end

                                local MapPosition = {}
                                MapPosition.__index = MapPosition
                                MapPosition.__tostring = function(p)
                                        return string.format('::pos{%d,%d,%s,%s,%s}',
                                                             p.systemId,
                                                             p.bodyId,
                                                             formatNumber(p.latitude*rad2deg),
                                                             formatNumber(p.longitude*rad2deg),
                                                             formatNumber(p.altitude))
                                    end
                                MapPosition.__eq       = function(lhs, rhs)
                                        return lhs.bodyId   == rhs.bodyId              and
                                               lhs.systemId == rhs.systemId            and
                                               float_eq(lhs.latitude,   rhs.latitude)  and
                                               float_eq(lhs.altitude,   rhs.altitude)  and
                                               (float_eq(lhs.longitude, rhs.longitude) or
                                                float_eq(lhs.latitude, math.pi/2)      or
                                                float_eq(lhs.latitude, -math.pi/2))
                                    end

                                local function mkMapPosition(overload, bodyId, latitude, longitude, altitude)
                                    local systemId = overload -- Id or '::pos{...}' string

                                    if isString(overload) and not longitude and not altitude and
                                                              not bodyId    and not latitude then
                                        systemId, bodyId, latitude, longitude, altitude =
                                                                            string.match(overload, posPattern)
                                        assert(systemId, 'Argument 1 (position string) is malformed.')
                                    else
                                        assert(isSNumber(systemId),
                                               'Argument 1 (systemId) must be a number:' .. type(systemId))
                                        assert(isSNumber(bodyId),
                                               'Argument 2 (bodyId) must be a number:' .. type(bodyId))
                                        assert(isSNumber(latitude),
                                               'Argument 3 (latitude) must be in degrees:' .. type(latitude))
                                        assert(isSNumber(longitude),
                                               'Argument 4 (longitude) must be in degrees:' .. type(longitude))
                                        assert(isSNumber(altitude),
                                               'Argument 5 (altitude) must be in meters:' .. type(altitude))
                                    end
                                    systemId  = tonumber(systemId)
                                    bodyId    = tonumber(bodyId)
                                    latitude  = tonumber(latitude)
                                    longitude = tonumber(longitude)
                                    altitude  = tonumber(altitude)

                                    if bodyId == 0 then -- this is a hack to represent points in space
                                        return setmetatable({latitude  = latitude,
                                                             longitude = longitude,
                                                             altitude  = altitude,
                                                             bodyId    = bodyId,
                                                             systemId  = systemId}, MapPosition)
                                    end
                                    return setmetatable({latitude  = deg2rad*clamp(latitude, -90, 90),
                                                         longitude = deg2rad*(longitude % 360),
                                                         altitude  = altitude,
                                                         bodyId    = bodyId,
                                                         systemId  = systemId}, MapPosition)
                                end

                                local PlanetarySystem = {}
                                PlanetarySystem.__index = PlanetarySystem

                                PlanetarySystem.__tostring =
                                    function (obj, indent)
                                        local sep = indent and (indent .. '  ' )
                                        local bdylist = {}
                                        local keys = {}
                                        for k in pairs(obj) do table.insert(keys, k) end
                                        table.sort(keys)
                                        for _, bi in ipairs(keys) do
                                            bdy = obj[bi]
                                            local bdys = BodyParameters.__tostring(bdy, sep)
                                            if indent then
                                                table.insert(bdylist,
                                                             string.format('[%s]={\n%s\n%s}',
                                                                           bi, bdys, indent))
                                            else
                                                table.insert(bdylist, string.format('  [%s]=%s', bi, bdys))
                                            end
                                        end
                                        if indent then
                                            return string.format('\n%s%s%s',
                                                                 indent,
                                                                 table.concat(bdylist, ',\n' .. indent),
                                                                 indent)
                                        end
                                        return string.format('{\n%s\n}', table.concat(bdylist, ',\n'))
                                    end

                                local function mkPlanetarySystem(referenceTable)
                                    local atlas = {}
                                    local pid
                                    for _, v in pairs(referenceTable) do
                                        local id = v.planetarySystemId

                                        if type(id) ~= 'number' then
                                            error('Invalid planetary system ID: ' .. tostring(id))
                                        elseif pid and id ~= pid then
                                            error('Mismatch planetary system IDs: ' .. id .. ' and '
                                                  .. pid)
                                        end
                                        local bid = v.bodyId
                                        if type(bid) ~= 'number' then
                                            error('Invalid body ID: ' .. tostring(bid))
                                        elseif atlas[bid] then
                                            error('Duplicate body ID: ' .. tostring(bid))
                                        end
                                        setmetatable(v.center, getmetatable(vec3.unit_x))
                                        atlas[bid] = setmetatable(v, BodyParameters)
                                        pid = id
                                    end
                                    return setmetatable(atlas, PlanetarySystem)
                                end

                                PlanetaryReference = {}

                                local function mkPlanetaryReference(referenceTable)
                                    return setmetatable({ galaxyAtlas = referenceTable or {} },
                                                          PlanetaryReference)
                                end

                                PlanetaryReference.__index        =
                                    function(t,i)
                                        if type(i) == 'number' then
                                            local system = t.galaxyAtlas[i]
                                            return mkPlanetarySystem(system)
                                        end
                                        return rawget(PlanetaryReference, i)
                                    end
                                PlanetaryReference.__pairs        =
                                    function(obj)
                                        return  function(t, k)
                                                    local nk, nv = next(t, k)
                                                    return nk, nv and mkPlanetarySystem(nv)
                                                end, obj.galaxyAtlas, nil
                                    end
                                PlanetaryReference.__tostring     =
                                    function (obj)
                                        local pslist = {}
                                        for _,ps in pairs(obj or {}) do
                                            local psi = ps:getPlanetarySystemId()
                                            local pss = PlanetarySystem.__tostring(ps, '    ')
                                            table.insert(pslist,
                                                         string.format('  [%s]={%s\n  }', psi, pss))
                                        end
                                        return string.format('{\n%s\n}\n', table.concat(pslist,',\n'))
                                    end

                                PlanetaryReference.BodyParameters = mkBodyParameters

                                PlanetaryReference.MapPosition    = mkMapPosition

                                PlanetaryReference.PlanetarySystem = mkPlanetarySystem

                                function PlanetaryReference.createBodyParameters(planetarySystemId,
                                                                                 bodyId,
                                                                                 surfaceArea,
                                                                                 aPosition,
                                                                                 verticalAtPosition,
                                                                                 altitudeAtPosition,
                                                                                 gravityAtPosition)
                                    assert(isSNumber(planetarySystemId),
                                           'Argument 1 (planetarySystemId) must be a number:' ..
                                           type(planetarySystemId))
                                    assert(isSNumber(bodyId),
                                           'Argument 2 (bodyId) must be a number:' .. type(bodyId))
                                    assert(isSNumber(surfaceArea),
                                           'Argument 3 (surfaceArea) must be a number:' .. type(surfaceArea))
                                    assert(isTable(aPosition),
                                           'Argument 4 (aPosition) must be an array or vec3:' ..
                                           type(aPosition))
                                    assert(isTable(verticalAtPosition),
                                           'Argument 5 (verticalAtPosition) must be an array or vec3:' ..
                                           type(verticalAtPosition))
                                    assert(isSNumber(altitudeAtPosition),
                                           'Argument 6 (altitude) must be in meters:' ..
                                           type(altitudeAtPosition))
                                    assert(isSNumber(gravityAtPosition),
                                           'Argument 7 (gravityAtPosition) must be number:' ..
                                           type(gravityAtPosition))
                                    local radius   = math.sqrt(surfaceArea/4/math.pi)
                                    local distance = radius + altitudeAtPosition
                                    local center   = vec3(aPosition) + distance*vec3(verticalAtPosition)
                                    local GM       = gravityAtPosition * distance * distance
                                    return mkBodyParameters(planetarySystemId, bodyId, radius, center, GM)
                                end

                                PlanetaryReference.isMapPosition  = isMapPosition

                                function PlanetaryReference:getPlanetarySystem(overload)
                                    if self.galaxyAtlas then
                                        local planetarySystemId = overload

                                        if isMapPosition(overload) then
                                            planetarySystemId = overload.systemId
                                        end

                                        if type(planetarySystemId) == 'number' then
                                            local system = self.galaxyAtlas[i]
                                            if system then
                                                if getmetatable(nv) ~= PlanetarySystem then
                                                    system = mkPlanetarySystem(system)
                                                end
                                                return system
                                            end
                                        end
                                    end
                                    return nil
                                end

                                function PlanetarySystem:castIntersections(origin,
                                                                           direction,
                                                                           sizeCalculator,
                                                                           bodyIds)
                                    local sizeCalculator = sizeCalculator or 
                                                            function (body) return 1.05*body.radius end
                                    local candidates = {}

                                    if bodyIds then
                                        for _,i in ipairs(bodyIds) do candidates[i] = self[i] end
                                    else
                                        bodyIds = {}
                                        for k,body in pairs(self) do
                                            table.insert(bodyIds, k)
                                            candidates[k] = body
                                        end
                                    end
                                    local function compare(b1,b2)
                                        local v1 = candidates[b1].center - origin
                                        local v2 = candidates[b2].center - origin
                                        return v1:len() < v2:len()
                                    end
                                    table.sort(bodyIds, compare)
                                    local dir = direction:normalize()

                                    for i, id in ipairs(bodyIds) do
                                        local body   = candidates[id]
                                        local c_oV3  = body.center - origin
                                        local radius = sizeCalculator(body)
                                        local dot    = c_oV3:dot(dir)
                                        local desc   = dot^2 - (c_oV3:len2() - radius^2)

                                        if desc >= 0 then
                                            local root     = math.sqrt(desc)
                                            local farSide  = dot + root
                                            local nearSide = dot - root
                                            if nearSide > 0 then
                                                return body, farSide, nearSide
                                            elseif farSide > 0 then
                                                return body, farSide, nil
                                            end
                                        end
                                    end
                                    return nil, nil, nil
                                end

                                function PlanetarySystem:closestBody(coordinates)
                                    assert(type(coordinates) == 'table', 'Invalid coordinates.')
                                    local minDistance2, body
                                    local coord = vec3(coordinates)

                                    for _,params in pairs(self) do
                                        local distance2 = (params.center - coord):len2()
                                        if not body or distance2 < minDistance2 then
                                            body         = params
                                            minDistance2 = distance2
                                        end
                                    end
                                    return body
                                end

                                function PlanetarySystem:convertToBodyIdAndWorldCoordinates(overload)
                                    local mapPosition = overload
                                    if isString(overload) then
                                        mapPosition = mkMapPosition(overload)
                                    end

                                    if mapPosition.bodyId == 0 then
                                        return 0, vec3(mapPosition.latitude,
                                                       mapPosition.longitude,
                                                       mapPosition.altitude)
                                    end
                                    local params = self:getBodyParameters(mapPosition)

                                    if params then
                                        return mapPosition.bodyId,
                                               params:convertToWorldCoordinates(mapPosition)
                                    end
                                end

                                function PlanetarySystem:getBodyParameters(overload)
                                    local bodyId = overload

                                    if isMapPosition(overload) then
                                        bodyId = overload.bodyId
                                    end
                                    assert(isSNumber(bodyId),
                                               'Argument 1 (bodyId) must be a number:' .. type(bodyId))

                                    return self[bodyId]
                                end

                                function PlanetarySystem:getPlanetarySystemId()
                                    local k, v = next(self)
                                    return v and v.planetarySystemId
                                end

                                function BodyParameters:convertToMapPosition(worldCoordinates)
                                    assert(isTable(worldCoordinates),
                                           'Argument 1 (worldCoordinates) must be an array or vec3:' ..
                                           type(worldCoordinates))
                                    local worldVec  = vec3(worldCoordinates) 

                                    if self.bodyId == 0 then
                                        return setmetatable({latitude  = worldVec.x,
                                                             longitude = worldVec.y,
                                                             altitude  = worldVec.z,
                                                             bodyId    = 0,
                                                             systemId  = self.planetarySystemId}, MapPosition)
                                    end
                                    local coords    = worldVec - self.center
                                    local distance  = coords:len()
                                    local altitude  = distance - self.radius
                                    local latitude  = 0
                                    local longitude = 0

                                    if not float_eq(distance, 0) then
                                        local phi = math.atan(coords.y, coords.x)
                                        longitude = phi >= 0 and phi or (2*math.pi + phi)
                                        latitude  = math.pi/2 - math.acos(coords.z/distance)
                                    end
                                    return setmetatable({latitude  = latitude,
                                                         longitude = longitude,
                                                         altitude  = altitude,
                                                         bodyId    = self.bodyId,
                                                         systemId  = self.planetarySystemId}, MapPosition)
                                end

                                function BodyParameters:convertToWorldCoordinates(overload)
                                    local mapPosition = isString(overload) and
                                                                           mkMapPosition(overload) or overload
                                    if mapPosition.bodyId == 0 then -- support deep space map position
                                        return vec3(mapPosition.latitude,
                                                    mapPosition.longitude,
                                                    mapPosition.altitude)
                                    end
                                    assert(isMapPosition(mapPosition),
                                           'Argument 1 (mapPosition) is not an instance of "MapPosition".')
                                    assert(mapPosition.systemId == self.planetarySystemId,
                                           'Argument 1 (mapPosition) has a different planetary system ID.')
                                    assert(mapPosition.bodyId == self.bodyId,
                                           'Argument 1 (mapPosition) has a different planetary body ID.')
                                    local xproj = math.cos(mapPosition.latitude)
                                    return self.center + (self.radius + mapPosition.altitude) *
                                           vec3(xproj*math.cos(mapPosition.longitude),
                                                xproj*math.sin(mapPosition.longitude),
                                                math.sin(mapPosition.latitude))
                                end

                                function BodyParameters:getAltitude(worldCoordinates)
                                    return (vec3(worldCoordinates) - self.center):len() - self.radius
                                end

                                function BodyParameters:getDistance(worldCoordinates)
                                    return (vec3(worldCoordinates) - self.center):len()
                                end

                                function BodyParameters:getGravity(worldCoordinates)
                                    local radial = self.center - vec3(worldCoordinates) -- directed towards body
                                    local len2   = radial:len2()
                                    return (self.GM/len2) * radial/math.sqrt(len2)
                                end

                                return setmetatable(PlanetaryReference,
                                                    { __call = function(_,...)
                                                                    return mkPlanetaryReference(...)
                                                               end })
                            end -- function planetref()

                        --KEPLER
                            function kepler()
                                local vec3       = require('cpml.vec3')
                                local PlanetRef  = planetref()

                                local function isString(s) return type(s)   == 'string' end
                                local function isTable(t)  return type(t)   == 'table'  end

                                local function float_eq(a,b)
                                    if a == 0 then return math.abs(b) < 1e-09 end
                                    if b == 0 then return math.abs(a) < 1e-09 end
                                    return math.abs(a - b) < math.max(math.abs(a),math.abs(b))*epsilon
                                end

                                Kepler = {}
                                Kepler.__index = Kepler

                                function Kepler:escapeAndOrbitalSpeed(altitude)
                                    assert(self.body)
                                    -- P = -GMm/r and KE = mv^2/2 (no lorentz factor used)
                                    -- mv^2/2 = GMm/r
                                    -- v^2 = 2GM/r
                                    -- v = sqrt(2GM/r1)
                                    local distance = altitude + self.body.radius

                                    if not float_eq(distance, 0) then
                                        local orbit = math.sqrt(self.body.GM/distance)
                                        return math.sqrt(2)*orbit, orbit
                                    end
                                    return nil, nil
                                end

                                function Kepler:orbitalParameters(overload, velocity)
                                    assert(self.body)
                                    assert(isTable(overload) or isString(overload))
                                    assert(isTable(velocity))
                                    local pos = (isString(overload) or PlanetRef.isMapPosition(overload)) and
                                                            self.body:convertToWorldCoordinates(overload) or
                                                vec3(overload)
                                    local v   = vec3(velocity)
                                    local r   = pos - self.body.center
                                    local v2  = v:len2()
                                    local d   = r:len()
                                    local mu  = self.body.GM
                                    local e   = ((v2 - mu/d)*r - r:dot(v)*v)/mu
                                    local a   = mu/(2*mu/d - v2)

                                    local ecc = e:len()
                                    local dir = e:normalize()
                                    local pd  = a*(1-ecc)
                                    local ad  = a*(1+ecc)
                                    local per = pd*dir + self.body.center
                                    local apo = ecc <= 1 and -ad*dir + self.body.center or nil
                                    local trm = math.sqrt(a*mu*(1-ecc*ecc))
                                    local Period = apo and 2*math.pi*math.sqrt(a^3/mu)
                                    local trueAnomaly = math.acos((e:dot(r))/(ecc*d))
                                    if r:dot(v) < 0 then
                                        trueAnomaly = -(trueAnomaly - 2*math.pi)
                                    end
                                    local EccentricAnomaly = math.acos((math.cos(trueAnomaly) + ecc)/(1 + ecc * math.cos(trueAnomaly)))
                                    local timeTau = EccentricAnomaly
                                    if timeTau < 0 then
                                        timeTau = timeTau + 2*math.pi
                                    end
                                    local MeanAnomaly = timeTau - ecc * math.sin(timeTau)
                                    local TimeSincePeriapsis = 0
                                    local TimeToPeriapsis = 0
                                    local TimeToApoapsis = 0
                                    if Period ~= nil then
                                        TimeSincePeriapsis = MeanAnomaly/(2*math.pi/Period)
                                        TimeToPeriapsis = Period - TimeSincePeriapsis
                                        TimeToApoapsis = TimeToPeriapsis + Period/2
                                        if trueAnomaly - math.pi > 0 then -- TBH I think something's wrong in my formulas because I needed this.
                                            TimeToPeriapsis = TimeSincePeriapsis
                                            TimeToApoapsis = TimeToPeriapsis + Period/2
                                        end
                                        if TimeToApoapsis > Period then
                                        TimeToApoapsis = TimeToApoapsis - Period
                                        end
                                    end

                                    return { periapsis       = { position           = per,
                                                                 speed              = trm/pd,
                                                                 circularOrbitSpeed = math.sqrt(mu/pd),
                                                                 altitude           = pd - self.body.radius},
                                             apoapsis        = apo and
                                                               { position           = apo,
                                                                 speed              = trm/ad,
                                                                 circularOrbitSpeed = math.sqrt(mu/ad),
                                                                 altitude           = ad - self.body.radius},
                                             currentVelocity = v,
                                             currentPosition = pos,
                                             eccentricity    = ecc,
                                             period          = apo and 2*math.pi*math.sqrt(a^3/mu),
                                             eccentricAnomaly = EccentricAnomaly,
                                             meanAnomaly = MeanAnomaly,
                                             timeToPeriapsis = TimeToPeriapsis,
                                             timeToApoapsis = TimeToApoapsis
                                           }
                                end

                                local function new(bodyParameters)
                                    local params = PlanetRef.BodyParameters(bodyParameters.planetarySystemId,
                                                                            bodyParameters.bodyId,
                                                                            bodyParameters.radius,
                                                                            bodyParameters.center,
                                                                            bodyParameters.GM)
                                    return setmetatable({body = params}, Kepler)
                                end

                                return setmetatable(Kepler, { __call = function(_,...) return new(...) end })
                            end -- function kepler()

                        --KINEMATICS
                            function kinematics()
                                local Kinematic = {} -- just a namespace

                                local C       = 30000000/3600
                                local C2      = C*C
                                local ITERATIONS = 100 -- iterations over engine "warm-up" period

                                local function lorentz(v) return 1/math.sqrt(1 - v*v/C2) end

                                function Kinematic.computeAccelerationTime(initial, acceleration, final)
                                    -- The low speed limit of following is: t=(vf-vi)/a (from: vf=vi+at)
                                    local k1 = C*math.asin(initial/C)
                                    return (C * math.asin(final/C) - k1)/acceleration
                                end

                                function Kinematic.computeDistanceAndTime(initial,
                                                                          final,
                                                                          restMass,
                                                                          thrust,
                                                                          t50,
                                                                          brakeThrust)
                                    t50            = t50 or 0
                                    brakeThrust    = brakeThrust or 0 -- usually zero when accelerating

                                    local tau0     = lorentz(initial)
                                    local speedUp  = initial <= final
                                    local a0       = thrust * (speedUp and 1 or -1)/restMass
                                    local b0       = -brakeThrust/restMass
                                    local totA     = a0+b0

                                    if speedUp and totA <= 0 or not speedUp and totA >= 0 then
                                        return -1, -1 -- no solution
                                    end

                                    local distanceToMax, timeToMax = 0, 0

                                    if a0 ~= 0 and t50 > 0 then
                                        local k1  = math.asin(initial/C)

                                        local c1  = math.pi*(a0/2+b0)
                                        local c2  = a0*t50
                                        local c3  = C*math.pi

                                        local v = function(t)
                                            local w  = (c1*t - c2*math.sin(math.pi*t/2/t50) + c3*k1)/c3
                                            local tan = math.tan(w)
                                            return C*tan/math.sqrt(tan*tan+1)
                                        end

                                        local speedchk = speedUp and function(s) return s >= final end or
                                                                     function(s) return s <= final end
                                        timeToMax  = 2*t50

                                        if speedchk(v(timeToMax)) then
                                            local lasttime = 0

                                            while math.abs(timeToMax - lasttime) > 0.5 do
                                                local t = (timeToMax + lasttime)/2
                                                if speedchk(v(t)) then
                                                    timeToMax = t 
                                                else
                                                    lasttime = t
                                                end
                                            end
                                        end

                                        local lastv = initial
                                        local tinc  = timeToMax/ITERATIONS

                                        for step = 1, ITERATIONS do
                                            local speed = v(step*tinc)
                                            distanceToMax = distanceToMax + (speed+lastv)*tinc/2
                                            lastv = speed
                                        end

                                        if timeToMax < 2*t50 then
                                            return distanceToMax, timeToMax
                                        end
                                        initial     = lastv
                                    end

                                    local k1       = C*math.asin(initial/C)
                                    local time     = (C * math.asin(final/C) - k1)/totA

                                    local k2       = C2 *math.cos(k1/C)/totA
                                    local distance = k2 - C2 * math.cos((totA*time + k1)/C)/totA

                                    return distance+distanceToMax, time+timeToMax
                                end

                                function Kinematic.computeTravelTime(initial, acceleration, distance)

                                    if distance == 0 then return 0 end

                                    if acceleration > 0 then
                                        local k1       = C*math.asin(initial/C)
                                        local k2       = C2*math.cos(k1/C)/acceleration
                                        return (C*math.acos(acceleration*(k2 - distance)/C2) - k1)/acceleration
                                    end
                                    assert(initial > 0, 'Acceleration and initial speed are both zero.')
                                    return distance/initial
                                end

                                function Kinematic.lorentz(v) return lorentz(v) end

                                return Kinematic
                            end -- kinematics()

                        --TRANSFORM
                            function transform()
                                local vec3  = require('cpml.vec3')
                                local utils = require('cpml.utils')
                                local clamp = utils.clamp

                                local Transform = {}

                                function Transform.computeHeading(planetCenter, position, direction)
                                    planetCenter   = vec3(planetCenter)
                                    position       = vec3(position)
                                    direction      = vec3(direction)
                                    local radius   = position - planetCenter
                                    if radius.x == 0 and radius.y == 0 then -- at north or south pole
                                        return radius.z >=0 and math.pi or 0
                                    end
                                    local chord    = planetCenter + vec3(0,0,radius:len()) - position
                                    local north    = chord:project_on_plane(radius):normalize_inplace()
                                    -- facing north, east is to the right
                                    local east     = north:cross(radius):normalize_inplace()
                                    local dir_prj  = direction:project_on_plane(radius):normalize_inplace()
                                    local adjacent = north:dot(dir_prj)
                                    local opposite = east:dot(dir_prj)
                                    local heading  = math.atan(opposite, adjacent) -- North==0

                                    if heading < 0 then heading = heading + 2*math.pi end
                                    if math.abs(heading - 2*math.pi) < .001 then heading = 0 end
                                    return heading
                                end

                                function Transform.computePRYangles(yaxis, zaxis, faxis, uaxis)
                                    yaxis = yaxis.x and yaxis or vec3(yaxis)
                                    zaxis = zaxis.x and zaxis or vec3(zaxis)
                                    faxis = faxis.x and faxis or vec3(faxis)
                                    uaxis = uaxis.x and uaxis or vec3(uaxis)
                                    local zproject = zaxis:project_on_plane(faxis):normalize_inplace()
                                    local adjacent = uaxis:dot(zproject)
                                    local opposite = faxis:cross(zproject):dot(uaxis)
                                    local roll     = math.atan(opposite, adjacent) -- rotate 'up' around 'fwd'
                                    local pitch    = math.asin(clamp(faxis:dot(zaxis), -1, 1))
                                    local fproject = faxis:project_on_plane(zaxis):normalize_inplace()
                                    local yaw      = math.asin(clamp(yaxis:cross(fproject):dot(zaxis), -1, 1))
                                    return pitch, roll, yaw
                                end

                                if library and library.systemResolution3 then

                                local solve = library.systemResolution3

                                function Transform.makeCoordinateConverters(coreUnit)
                                    local core     = coreUnit or core
                                    local vc1      = core.getConstructWorldOrientationRight()
                                    local vc2      = core.getConstructWorldOrientationForward()
                                    local vc3      = core.getConstructWorldOrientationUp()
                                    local vc1t     = solve(vc1, vc2, vc3, {1,0,0})
                                    local vc2t     = solve(vc1, vc2, vc3, {0,1,0})
                                    local vc3t     = solve(vc1, vc2, vc3, {0,0,1})
                                    return  function(world) -- transform to construct coordinates
                                                world = world.x and {world:unpack()} or world
                                                return vec3(solve(vc1, vc2, vc3, world))
                                            end,
                                            function(cref) -- transform to world coordinates
                                                cref = cref.x and {cref:unpack()} or cref
                                                return vec3(solve(vc1t, vc2t, vc3t, cref))
                                            end,
                                            vec3(vc1), vec3(vc2), vec3(vc3)
                                end

                                else

                                function Transform.makeCoordinateConverters(coreUnit)
                                    local core     = coreUnit or core
                                    local right    = vec3(core.getConstructWorldOrientationRight())
                                    local fwd      = vec3(core.getConstructWorldOrientationForward())
                                    local up       = vec3(core.getConstructWorldOrientationUp())
                                    return  function(world) -- transform to construct coordinates
                                                world = world.x and world or vec3(world)
                                                return vec3(right:dot(world), fwd:dot(world), up:dot(world))
                                            end,
                                            function(cref) -- transform to world coordinates
                                                cref = cref.x and cref or vec3(cref)
                                                return right*cref.x + fwd*cref.y + up*cref.z
                                            end,
                                            right, fwd, up
                                end

                                end

                                return Transform
                            end -- function transform()


                --AIR DATA
                    function air_data()

                        --ORBITAL DATA
                            function orbital_data()
                                local myPos = vec3(core.getConstructWorldPos())
                                local myVelocity = vec3(core.getWorldVelocity())

                                local Atlas = atlas()
                                local PlanetaryReference = planetref()
                                local Kepler = kepler()
                                local planetref = PlanetaryReference(Atlas)
                                local helios = planetref[0]
                                local closestbody = helios:closestBody(myPos)
                                local orbitInfo = Kepler(closestbody)
                                local orbit     = orbitInfo:orbitalParameters(myPos, myVelocity)
                                local periapsis  = orbit.periapsis.position

                                planet_name = closestbody.name
                                planet_pos = closestbody.center
                                planet_radius = closestbody.radius
                                orbit_ecc = math.floor(orbit.eccentricity*10000)/10000
                                orbit_per_pos = periapsis
                                if orbit.period == nil then orbit.period = 0 end
                                orbit_period_seconds = math.floor(orbit.period)
                                local T_time_h = math.floor(orbit_period_seconds/3600)
                                local T_time_m = math.floor(((orbit_period_seconds/3600) - T_time_h)*60)
                                local T_time_s = math.floor(((((orbit_period_seconds/3600) - T_time_h)*60)- T_time_m)*60)
                                orbit_period = T_time_h ..":".. T_time_m ..":".. T_time_s
                                orbit_apo_pos = apoapsis
                                if orbit.apoapsis == nil then orbit_apo_alt = 0 else
                                    orbit_apo_alt = math.floor(orbit.apoapsis.altitude) end
                                if orbit.apoapsis == nil then orbit_apo_speed = 0 else
                                    orbit_apo_speed = math.floor(orbit.apoapsis.speed) end
                                if (orbit_t_to_apo == nil or speed_hud == 0) then
                                    orbit_t_to_apo = "n/a"
                                else
                                    orbit_t_to_apo_seconds = math.floor(orbit.timeToApoapsis)
                                    local A_time_h = math.floor(orbit_t_to_apo_seconds/3600)
                                    local A_time_m = math.floor(((orbit_t_to_apo_seconds/3600) - A_time_h)*60)
                                    local A_time_s = math.floor(((((orbit_t_to_apo_seconds/3600) - A_time_h)*60) - A_time_m)*60)
                                    orbit_t_to_apo = A_time_h ..":".. A_time_m ..":".. A_time_s
                                end
                                if (orbit_t_to_per == nil or speed_hud == 0) then
                                    orbit_t_to_per = "n/a"
                                else
                                    orbit_t_to_per_seconds = math.floor(orbit.timeToPeriapsis)
                                    local P_time_h = math.floor(orbit_t_to_per_seconds/3600)
                                    local P_time_m = math.floor(((orbit_t_to_per_seconds/3600) - P_time_h)*60)
                                    local P_time_s = math.floor(((((orbit_t_to_per_seconds/3600) - P_time_h)*60) - P_time_m)*60)
                                    orbit_t_to_per = P_time_h ..":".. P_time_m ..":".. P_time_s
                                end
                                if orbit.periapsis == nil then orbit_per_alt = 0 else
                                    orbit_per_alt = math.floor(orbit.periapsis.altitude) end
                                if orbit.periapsis == nil then orbit_per_speed = 0 end
                                if orbit.periapsis.speed > 0 then
                                    orbit_per_speed = math.floor(orbit.periapsis.speed)
                                else
                                    orbit_per_speed = 0
                                    orbit_t_to_apo = 0
                                    orbit_t_to_per = 0
                                end

                                orbit_circular_speed = math.floor(orbit.periapsis.circularOrbitSpeed)

                                pe_dis = ((orbit_per_pos - myPos):len())/1000

                                my_planet_alt = (planet_pos - myPos):len()

                                if databank then
                                    if databank.getFloatValue("navigator_pe_target_altitude") then
                                        PeTargetAlt = math.floor(databank.getFloatValue("navigator_pe_target_altitude"))
                                    else
                                        PeTargetAlt = PeTargetAlt
                                    end
                                else
                                    PeTargetAlt = PeTargetAlt
                                end

                            end -- function orbital_data()
                            orbital_data()


                        --AUTOBRAKE

                            if databank then
                                if databank.getFloatValue("navigator_autobrake") ~= nil then
                                    autobrake_stops_at = databank.getFloatValue("navigator_autobrake")
                                else
                                    autobrake_stops_at = 2.3
                                end
                            else
                                autobrake_stops_at = 2.3 --export
                            end

                            autobrake = false
                            brake_active = [[ ]]
                            brake_status = [[ ]]
                            autobrake_ecam_mode = [[ ]]
                            autobrake_in = [[ Autobrake OFF ]]
                            function autobrake_function()
                                autobrake_ecam_mode = [[<span style=" color: yellow">Autobrake</span>&nbsp<span style=" color: #00FFFF">ARM</span>]]
                                brake_active = [[<span style=" color: red">BRK</span>]]
                                brake_status = [[<span style=" color: #00FFFF">ARM</span>]]
                                if distance_PPOS_B_hud ~= nil then
                                    if databank then
                                        if databank.getFloatValue("navigator_autobrake") ~= nil then
                                            autobrake_stops_at = databank.getFloatValue("navigator_autobrake")
                                        else
                                            autobrake_stops_at = 2.3
                                        end
                                    else
                                        autobrake_stops_at = 2.3 --export
                                    end
                                    autobrake_in = math.floor((distance_PPOS_B_hud - brake_su - autobrake_stops_at)*100)/100
                                    if distance_PPOS_B_hud <= (brake_su + autobrake_stops_at) then
                                        Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
                                        brakeInput = 1
                                        brake_status = [[<span style=" color: #7FFF00">ENG</span>]]
                                        autobrake_ecam_mode = [[<span style=" color: #7FFF00">Autobrake ON</span>]]
                                        unit.stopTimer("autobrake")
                                    else
                                        brakeInput = 0
                                    end
                                else
                                    if brakeInput == 0 then
                                        brake_status = [[<span style=" color: lightorange">No Dest</span>]]
                                        autobrake_ecam_mode = [[<span style=" color: lightorange">Autobrake NO Dest.</span>]]
                                    else
                                        brake_status = [[<span style=" color: #7FFF00">ENG</span>]]
                                        autobrake_ecam_mode = [[<span style=" color: #7FFF00">Autobrake ON</span>]]
                                        unit.stopTimer("autobrake")
                                    end
                                end
                            end -- function autobrake()


                        --ALTITUDE
                            altitude = math.floor(core.getAltitude())


                        --SPEED
                            speed_hud = math.floor((vec3(core.getVelocity()):len())*3.6)


                        --PARKING BRK
                            if speed_hud < 5 then
                                unit.setTimer("autobrake", 1)
                                brakeInput = 1
                                autobrake_ecam_mode = [[<span style=" color: #7FFF00">Autobrake ON</span>]]
                                autobrake = true
                            end


                        --ACCELERATION
                            acc_hud = math.floor(vec3(core.getWorldAcceleration()):len()/9.8*10)/10


                        --PITCH / ROLL
                            function f_pitch_roll()

                                function unit.getPitch()
                                    local world = vec3(core.getWorldVertical())
                                    local construct = vec3(core.getConstructWorldOrientationForward())
                                    local prod = math.asin(world:dot(construct)) * -constants.rad2deg
                                    return prod
                                end
                                pitch_hud = math.floor(unit.getPitch()*10)/10

                                function unit.getRoll()
                                    local world = vec3(core.getWorldVertical())
                                    local construct = vec3(core.getConstructWorldOrientationRight())
                                    local prod = math.asin(world:dot(construct)) * constants.rad2deg
                                    return prod
                                end
                                roll_hud = math.floor(gyro.getRoll()*10)/10

                                roll_direction = 0
                                if roll_hud > 0 then roll_direction = [[<span style=" font-size: 15px; color:#00FFFF"><</span>&nbsp]] .. roll_hud
                                    else if
                                        roll_hud < 0 then roll_direction = (roll_hud)*-1 .. [[&nbsp<span style=" font-size: 15px; color:#00FFFF">></span>]]
                                    end
                                end

                                if speed_hud < 10 then
                                    pitch_bird_hud = 0
                                    yaw_bird_hud = 0
                                else
                                    function unit.getBirdPitch()
                                    local up = vec3(core.getWorldVertical())
                                    local velocity_vector = vec3(core.getWorldVelocity()):normalize()
                                    local prod = math.asin(velocity_vector:dot(up)) * constants.rad2deg
                                    local prod = prod + pitch_hud
                                    if roll_hud > 90 or roll_hud < -90 then
                                        return -prod
                                    else
                                        return prod
                                    end
                                end -- function unit.getSpacePitch()
                                pitch_bird_hud = math.floor(unit.getBirdPitch()*10)/10

                                function unit.getBirdYaw()
                                    local right = vec3(core.getConstructWorldOrientationRight())
                                    local velocity_vector = vec3(core.getWorldVelocity()):normalize()  
                                    local prod = math.asin(velocity_vector:dot(right)) * constants.rad2deg
                                return prod
                                end -- function unit.getSpaceYaw()
                                yaw_bird_hud = math.floor(unit.getBirdYaw()*10)/10
                                end -- if

                            end -- function f_pitch_roll()
                            f_pitch_roll()


                        --SPACE ORIENTATION
                            autopilot_ecam_mode = [[ ]]
                            align_active_mode = [[ ]]
                            adjusting_mode = [[ ]]

                            function space_orientation()

                                if speed_hud == 0 then
                                    pitch_space_hud = 0
                                    yaw_space_hud = 0
                                else
                                    function unit.getSpacePitch()
                                        local up = vec3(core.getConstructWorldOrientationUp())
                                        local velocity_vector = vec3(core.getWorldVelocity()):normalize()
                                        local cross = vec3(up:cross(velocity_vector))
                                        local forward = vec3(core.getConstructWorldOrientationForward()):project_on_plane(cross):normalize()
                                        local prod = math.acos(velocity_vector:dot(forward)) * constants.rad2deg
                                        local side = math.asin(velocity_vector:dot(up)) * constants.rad2deg
                                        if side < 0 then prod = prod else prod = -prod end
                                        return prod
                                    end -- function unit.getSpacePitch()

                                    pitch_space_hud = math.floor(unit.getSpacePitch()*10)/10

                                    function unit.getSpaceYaw()
                                        local right = vec3(core.getConstructWorldOrientationRight())
                                        local velocity_vector = vec3(core.getWorldVelocity()):normalize()
                                        local cross = vec3(right:cross(velocity_vector))
                                        local forward = vec3(core.getConstructWorldOrientationForward()):project_on_plane(cross):normalize()
                                        local prod = math.acos(velocity_vector:dot(forward)) * constants.rad2deg
                                        local side = math.asin(velocity_vector:dot(right)) * constants.rad2deg
                                        if side > 0 then prod = prod else prod = -prod end
                                    return prod
                                    end -- function unit.getSpaceYaw()

                                    yaw_space_hud = math.floor(unit.getSpaceYaw()*10)/10
                                end

                                if databank then
                                    if (databank.getNbKeys() ~= 0 and databank.getStringValue("navigator_coordinates") ~= "n/a") then
                                        planet_B_coord = vec3FromStr(databank.getStringValue("navigator_coordinates"))
                                    else
                                        planet_B_coord = planet_pos
                                    end
                                else
                                    planet_B_coord = planet_pos
                                end

                                function unit.getWPPitch()
                                    local up = vec3(core.getConstructWorldOrientationUp())
                                    local myPos = vec3(core.getConstructWorldPos())
                                    local wp_vector = (planet_B_coord - myPos):normalize()
                                    local cross = vec3(up:cross(wp_vector))
                                    local forward = vec3(core.getConstructWorldOrientationForward()):project_on_plane(cross):normalize()
                                    local prod = math.acos(wp_vector:dot(forward)) * constants.rad2deg
                                    local side = math.asin(wp_vector:dot(up)) * constants.rad2deg
                                    if side < 0 then prod = prod else prod = -prod end
                                return prod
                                end -- function unit.getWPPitch()
                                pitch_WP_hud = math.floor(unit.getWPPitch()*10)/10

                                function unit.getWPYaw()
                                    local right = vec3(core.getConstructWorldOrientationRight())
                                    local myPos = vec3(core.getConstructWorldPos())
                                    local wp_vector = (planet_B_coord - myPos):normalize()
                                    local cross = vec3(right:cross(wp_vector))
                                    local forward = vec3(core.getConstructWorldOrientationForward()):project_on_plane(cross):normalize()  
                                    local prod = math.acos(wp_vector:dot(forward)) * constants.rad2deg
                                    local side = math.asin(wp_vector:dot(right)) * constants.rad2deg
                                    if side > 0 then prod = prod else prod = -prod end
                                return prod
                                end -- function unit.getWPYaw()
                                yaw_WP_hud = math.floor(unit.getWPYaw()*10)/10

                            end -- function space_orientation()
                            space_orientation()


                        --SHIP ALIGNER
                            auto_aligner = false
                            prograde_mode = false
                            orbit_maintainer = false
                            destination_mode = false

                            function auto_align()

                                if prograde_mode == true then
                                    target_pitch_to_align = pitch_space_hud
                                    target_yaw_to_align = yaw_space_hud
                                    align_active_mode = [[Aligning PROGRADE]]
                                end

                                if destination_mode == true then
                                    target_pitch_to_align = pitch_WP_hud
                                    target_yaw_to_align = yaw_WP_hud
                                    align_active_mode = [[Aligning DESTINATION]]
                                end

                                local up = vec3(core.getConstructWorldOrientationUp())
                                local right = vec3(core.getConstructWorldOrientationRight())
                                local constructAngularVelocity = vec3(core.getWorldAngularVelocity())
                                local pitchAngle = target_pitch_to_align
                                local yawAngle = target_yaw_to_align

                                local pitchAngleAbs = math.abs(pitchAngle)
                                local yawAngleAbs = math.abs(yawAngle)

                                local autoPitchThreshold = 0 --export
                                local autoPitchFactor = 0.8 --export
                                local autoYawThreshhold = 0 --export
                                local autoYawFactor = 0.3 --export
                                local torqueFactor = 2

                                if pitchAngleAbs > autoPitchThreshold or yawAngleAbs > autoYawThreshhold then

                                    local targetPitchDeg = utils.clamp(0,pitchAngleAbs-30, pitchAngleAbs+30);
                                    local targetYawDeg =  utils.clamp(0,yawAngleAbs-30, yawAngleAbs+30);

                                    if (pitchPID == nil) then
                                        pitchPID = pid.new(autoPitchFactor * 0.01, 0, autoPitchFactor * 0.1)
                                    end
                                    if (yawPid == nil) then
                                        yawPID = pid.new(autoYawFactor * 0.01, 0, autoYawFactor * 0.1)
                                    end

                                    pitchPID:inject(targetPitchDeg - pitchAngle)
                                    yawPID:inject(targetYawDeg - yawAngle)

                                    local autoPitchInput = pitchPID:get()
                                    local autoYawInput = yawPID:get()

                                    targetAngularVelocity = autoPitchInput * autoPitchFactor * right
                                                            + autoYawInput * autoYawFactor * up

                                    local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                                    local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())
                                    angularAcceleration = angularAcceleration - airAcceleration
                                    Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                                else
                                   targetAngularVelocity = 0
                                   Nav:setEngineTorqueCommand("torque", vec3.zero, targetAngularVelocity)

                                end
                            end -- function


                        --MAINTAINING ORBIT
                            function maintaining_orbit()

                                if (orbit_pg == true                    and
                                    auto_aligner == true                and
                                    orbit_ecc < 0.9                     and
                                    orbit_apo_alt ~= nil                and
                                    orbit_per_alt ~= nil                and
                                    orbit_t_to_per_seconds ~= nil       and
                                    orbit_t_to_apo_seconds ~= nil       and
                                    math.abs(target_pitch_to_align) < 2 and
                                    math.abs(target_yaw_to_align) < 2   and
                                    orbit_per_alt > 6000)               then

                                    if (orbit_per_alt < PeTargetAlt                         and
                                        orbit_t_to_per_seconds < orbit_t_to_apo_seconds     and
                                        orbit_t_to_per_seconds > 1/4*orbit_period_seconds   and
                                        orbit_ecc < 0.8)                                    then

                                        brakeInput = 0
                                        Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 100)
                                        adjusting_mode = [[Increasing PE]]

                                    elseif (orbit_per_alt > PeTargetAlt + 5000                  and
                                            orbit_t_to_per_seconds < orbit_t_to_apo_seconds     and
                                            orbit_t_to_per_seconds > 1/4*orbit_period_seconds   and
                                            orbit_ecc < 0.6)                                    then

                                            Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
                                            brakeInput = 1
                                            adjusting_mode = [[Decreasing PE]]
                                            
                                    elseif (orbit_per_alt < PeTargetAlt - 2000                  and
                                            orbit_t_to_per_seconds < orbit_t_to_apo_seconds     and
                                            orbit_t_to_per_seconds < 1/4*orbit_period_seconds   and
                                            orbit_ecc < 0.6)                                    then
                                    
                                            brakeInput = 0
                                            Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 100)
                                            adjusting_mode = [[Increasing PE]]

                                    elseif (orbit_t_to_per_seconds < 2) then

                                        if orbit_apo_alt > PeTargetAlt + 5000 then
                                            Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
                                            brakeInput = 1
                                            adjusting_mode = [[Decreasing AP]]
                                        else
                                            Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
                                            brakeInput = 0
                                            adjusting_mode = [[Maintaining ORBIT]]
                                        end

                                    elseif (orbit_apo_alt > PeTargetAlt + 5000              and
                                            orbit_t_to_apo_seconds < orbit_t_to_per_seconds and
                                            orbit_per_alt > 10000                           and
                                            orbit_ecc < 0.8                                 and
                                            orbit_apo_alt > orbit_per_alt + 1000 )           then

                                            Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
                                            brakeInput = 1
                                            adjusting_mode = [[Decreasing AP]]

                                    elseif (orbit_apo_alt < PeTargetAlt                         and
                                            orbit_t_to_apo_seconds < orbit_t_to_per_seconds     and
                                            orbit_t_to_per_seconds > 1/4*orbit_period_seconds   and
                                           (orbit_per_alt < PeTargetAlt                         or
                                            orbit_ecc < 0.8))                                   then

                                            brakeInput = 0
                                            Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 100)
                                            adjusting_mode = [[Increasing AP]]

                                    elseif (orbit_t_to_apo_seconds < 2) then

                                        if orbit_per_alt > PeTargetAlt + 5000 then
                                            Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
                                            brakeInput = 1
                                            adjusting_mode = [[Decreasing PE]]
                                        else
                                            Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
                                            adjusting_mode = [[Maintaining ORBIT]]
                                        end

                                    elseif (orbit_per_alt < 6000) then
                                        Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
                                        adjusting_mode = [[Unafe Orbit BRK ENG]]
                                        unit.setTimer("autobrake", 1)
                                        brakeInput = 1
                                        autobrake_ecam_mode = [[<span style=" color: #7FFF00">Autobrake ON</span>]]
                                        autobrake = true
                                    else
                                        Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
                                        brakeInput = 0
                                        adjusting_mode = [[Maintaining ORBIT]]
                                    end

                                else
                                    if  ((space_pg == true                          or
                                        loading_pg == true                          or
                                        atmo_pg == true)                            and
                                        adjusting_mode ~= [[Maintaining ORBIT]])   then

                                        adjusting_mode = [[ORB Mode to ARM]]
                                    else
                                        adjusting_mode = [[Orbiting ARM]]
                                    end
                                end
                            end -- function maintaining_orbit()


                        --RADIO ALTIMITER
                            function f_radioalt_hud()
                                radioalt_hud = 0
                                if radio_alt.getDistance then
                                    if math.floor(radio_alt.getDistance()) ~= -1 then
                                        radioalt_hud = [[ Radio Alt </td><td> ]] .. math.floor(radio_alt.getDistance()) .. [[<span style=" color:#00FFFF">&nbsp mt</span>]]
                                        else
                                        radioalt_hud = [[</td><td>]]
                                     end
                                end
                                if radio_alt.distance then
                                     if math.floor(radio_alt.distance()) ~= -1 then
                                        radioalt_hud = [[ Radio Alt </td><td> ]] .. math.floor(radio_alt.distance()) .. [[<span style=" color:#00FFFF">&nbsp mt</span>]]
                                        else
                                        radioalt_hud = [[</td><td>]]
                                     end
                                end
                            return radioalt_hud
                            end -- function f_radioalt_hud()
                            f_radioalt_hud()


                        --THROTTLE
                            thr = math.floor(unit.getThrottle())


                        --VERTICAL SPEED
                            local worldVelocity = vec3(core.getWorldVelocity())
                            local gravity = vec3(core.getWorldGravity())
                            vs_hud = math.floor(worldVelocity:dot(-gravity:normalize()))


                        --FUEL MASS
                            fuel_mass = 0
                            function total_fuel_mass()

                                local a_fuel_mass = 0
                                for i = 1, atmofueltank_size do
                                    a_fuel_mass = a_fuel_mass + atmofueltank[i].getItemsMass()
                                    t_a_fuel_mass = math.floor(a_fuel_mass/1000*10)/10
                                end

                                local s_fuel_mass = 0
                                for i = 1, spacefueltank_size do
                                    s_fuel_mass = s_fuel_mass + spacefueltank[i].getItemsMass()
                                    t_s_fuel_mass = math.floor(s_fuel_mass/1000*10)/10
                                end

                                local r_fuel_mass = 0
                                if rocketfueltank_size ~= 0 then
                                    for i = 1, rocketfueltank_size do
                                        r_fuel_mass = r_fuel_mass + rocketfueltank[i].getItemsMass()
                                        t_r_fuel_mass = math.floor(r_fuel_mass/1000*10)/10
                                    end
                                else
                                    t_r_fuel_mass = 0
                                end

                                fuel_mass = t_a_fuel_mass + t_s_fuel_mass + t_r_fuel_mass

                            return fuel_mass
                            end -- function total_fuel_mass()


                        --LOADING DATA
                            function f_loading_data()

                                if databank then
                                    if databank.getFloatValue("navigator_MTOW") ~= nil then
                                        MTOW = databank.getFloatValue("navigator_MTOW")
                                    else
                                        MTOW = 90000
                                    end
                                else
                                    MTOW = 90000 --export
                                end

                                cargo_m = 0
                                if container_size ~= 0 then
                                    for i = 1, container_size do
                                        cargo_m = cargo_m + container[i].getItemsMass()
                                        cargo_m_t = math.floor((cargo_m/1000)*10)/10
                                        cargo_m_t_hud = cargo_m_t
                                    end
                                else
                                    cargo_m_t = 0
                                    cargo_m_t_hud = "n/a"
                                end
                            return cargo_m_t, cargo_m_t_hud
                            end -- function cargo_data()
                            f_loading_data()


                        --GW, ZFW, DOW
                            gw_m = math.floor(core.getConstructMass()/1000*10)/10
                            zfw_m = 0
                            dow_m = 0


                        --MTOW Percent
                            MTOW_p = math.floor(gw_m*1000/MTOW*100)


                        --AVG FUEL PERCENTAGE
                            s_fuel_percent_avg_hud = 0
                            a_fuel_percent_avg_hud = 0
                            r_fuel_percent_avg_hud = 0

                            function avg_fuel_percentage()
                                local a_fuel_percent = 0
                                for i = 1, atmofueltank_size do
                                    if json.decode(atmofueltank[i].getData()).percentage then
                                        a_fuel_percent = a_fuel_percent + json.decode(atmofueltank[i].getData()).percentage
                                    end
                                end
                                a_fuel_percent_avg_hud = math.ceil(a_fuel_percent/atmofueltank_size)

                                local s_fuel_percent = 0
                                for i = 1, spacefueltank_size do
                                    if json.decode(spacefueltank[i].getData()).percentage then
                                        s_fuel_percent = s_fuel_percent + json.decode(spacefueltank[i].getData()).percentage
                                    end
                                end
                                s_fuel_percent_avg_hud = math.ceil(s_fuel_percent/spacefueltank_size)

                                if rocketfueltank_size ~= 0 then
                                    local r_fuel_percent = 0
                                    for i = 1, rocketfueltank_size do
                                        if json.decode(rocketfueltank[i].getData()).percentage then
                                            r_fuel_percent = r_fuel_percent + json.decode(rocketfueltank[i].getData()).percentage
                                        end
                                    end
                                    r_fuel_percent_avg_hud = math.ceil(r_fuel_percent/rocketfueltank_size)
                                else
                                    r_fuel_percent_avg_hud = [[n/a]]
                                end
                            end -- avg_fuel_percentage()
                            avg_fuel_percentage()


                        --ATMO FUEL WARNING
                            a_fuelspy_hud = [[<span style=" color:#141fad">A Fuel</span>]]
                            a_fuelwarning_hud = [[ ]]

                            function atmo_fuel_percent()
                                local fuelpercent = 0
                                a_fuelwarning_hud = [[ ]]
                                a_fuelspy_hud = [[<span style=" color:#141fad">A Fuel</span>]]
                                for i = 1, atmofueltank_size do
                                    if json.decode(atmofueltank[i].getData()).percentage then
                                        fuelpercent = json.decode(atmofueltank[i].getData()).percentage
                                        if fuelpercent < 20 and fuelpercent > 0 then
                                            a_fuelspy_hud = [[<span style=" color:orange">A Fuel</span>]] 
                                            a_fuelwarning_hud = a_fuelwarning_hud ..[[<span style=" color: orange">A Fuel Tank ]]..i..[[ LO LVL</span><br>]]
                                        elseif fuelpercent == 0 then
                                            a_fuelspy_hud = [[<span style=" color:red">A Fuel</span>]]
                                            a_fuelwarning_hud = a_fuelwarning_hud.. [[<span style=" color: red">A Fuel Tank ]]..i..[[ EMPTY</span><br>]]
                                        end
                                    end
                                end
                            return a_fuelspy_hud, a_fuelwarning_hud
                            end -- function atmo_fuel_percent()


                        --SPACE FUEL WARNING
                            s_fuelspy_hud = [[<span style=" color:#141fad">S Fuel</span>]]
                            s_fuelwarning_hud = [[ ]]

                            function space_fuel_percent()
                                local fuelpercent = 0
                                s_fuelwarning_hud = [[ ]]
                                s_fuelspy_hud = [[<span style=" color:#141fad">S Fuel</span>]]
                                for i = 1, spacefueltank_size do
                                    if json.decode(spacefueltank[i].getData()).percentage then
                                        fuelpercent = json.decode(spacefueltank[i].getData()).percentage
                                        if fuelpercent < 20 and fuelpercent > 0 then
                                            s_fuelspy_hud = [[<span style=" color:orange">S Fuel</span>]] 
                                            s_fuelwarning_hud = s_fuelwarning_hud ..[[<span style=" color: orange">S Fuel Tank ]]..i..[[ LO LVL</span><br>]]
                                        elseif fuelpercent == 0 then
                                            s_fuelspy_hud = [[<span style=" color:red">S Fuel</span>]]
                                            s_fuelwarning_hud = s_fuelwarning_hud.. [[<span style=" color: red">S Fuel Tank ]]..i..[[ EMPTY</span><br>]]
                                        end
                                    end
                                end
                            return s_fuelspy_hud, s_fuelwarning_hud
                            end -- function space_fuel_percent()


                        --ROCKET FUEL WARNING
                            r_fuelspy_hud = [[<span style=" color:#141fad">R Fuel</span>]]
                            r_fuelwarning_hud = [[ ]]
                            r_active_hud = [[#141fad]]

                            if rocketfueltank_size ~= 0 then
                                function rocket_fuel_percent()
                                    local fuelpercent = 0
                                    r_fuelwarning_hud = [[ ]]
                                    r_fuelspy_hud = [[<span style=" color:#141fad">R Fuel</span>]]
                                    for i = 1, rocketfueltank_size do
                                        if json.decode(rocketfueltank[i].getData()).percentage then
                                            fuelpercent = json.decode(rocketfueltank[i].getData()).percentage
                                            if fuelpercent < 20 and fuelpercent > 0 then
                                                r_fuelspy_hud = [[<span style=" color:orange">R Fuel</span>]] 
                                                r_fuelwarning_hud = r_fuelwarning_hud ..[[<span style=" color: orange">R Fuel Tank ]]..i..[[ LO LVL</span><br>]]
                                            elseif fuelpercent == 0 then
                                                r_fuelspy_hud = [[<span style=" color:red">R Fuel</span>]]
                                                r_fuelwarning_hud = r_fuelwarning_hud.. [[<span style=" color: red">R Fuel Tank ]]..i..[[ EMPTY</span><br>]]
                                            end
                                        end
                                    end
                                return r_fuelspy_hud, r_fuelwarning_hud
                                end -- function rocket_fuel_percent()

                                function r_warning_light()
                                    for i = 1, rocketfueltank_size do
                                        r_active_hud = json.decode(rocketfueltank[i].getData()).timeLeft
                                            if r_active_hud == "n/a" then
                                               r_active_hud = [[#141fad]]
                                            else
                                               r_active_hud = [[red]]
                                            end
                                    end
                                end -- function r_warning_light()
                                r_warning_light()

                            end -- if rocketfueltank_size ~= 0 then


                        --ECAM
                            function ECAM()

                                function autopilot_ecam()
                                    if (autopilot_ecam_mode == [[Autopilot ON - Mode 1]] or
                                        autopilot_ecam_mode == [[Autopilot ON - Mode 2]] or
                                        autopilot_ecam_mode == [[Autopilot ON - Mode 3]]) then
                                        br_1 = [[<br>]]
                                    else
                                        br_1 = [[ ]]
                                    end

                                    if (align_active_mode == [[Aligning PROGRADE]] or
                                        align_active_mode == [[Aligning DESTINATION]]) then
                                        br_2 = [[<br>]]
                                    else
                                        br_2 = [[ ]]
                                    end

                                    if (adjusting_mode == [[Maintaining ORBIT]] or
                                            adjusting_mode == [[Mainteining Orbit in: 3]] or
                                            adjusting_mode == [[Mainteining Orbit in: 2]] or
                                            adjusting_mode == [[Mainteining Orbit in: 1]] or
                                            adjusting_mode == [[Align to DEST in: 3]] or
                                            adjusting_mode == [[Align to DEST in: 2]] or
                                            adjusting_mode == [[Align to DEST in: 1]] or
                                            adjusting_mode == [[Increasing PE]] or
                                            adjusting_mode == [[Increasing AP]] or
                                            adjusting_mode == [[Decreasing PE]] or
                                            adjusting_mode == [[Decreasing AP]] or
                                            adjusting_mode == [[Orbiting ARM]] or
                                            adjusting_mode == [[Unafe Orbit BRK ENG]] or
                                            adjusting_mode == [[ORB Mode to ARM]]) then
                                        br_3 = [[<br>]]
                                    else
                                        br_3 = [[ ]]
                                    end

                                    local autopilot_ecam = [[<span style=" color: #7FFF00">]].. autopilot_ecam_mode ..[[</span><span style=" color: #00FFFF">]]
                                    local autopilot_ecam = autopilot_ecam .. br_1 .. align_active_mode
                                    local autopilot_ecam = autopilot_ecam .. br_2 .. adjusting_mode ..[[</span>]].. br_3
                                    return autopilot_ecam
                                end -- function autopilot_ecam()
                                autopilot_ecam()

                                function autobrake_ecam()
                                    if (autobrake_ecam_mode == [[<span style=" color: yellow">Autobrake</span>&nbsp<span style=" color: #00FFFF">ARM</span>]] or
                                        autobrake_ecam_mode == [[<span style=" color: #7FFF00">Autobrake ON</span>]] or
                                        autobrake_ecam_mode == [[<span style=" color: lightorange">Autobrake NO Dest.</span>]]) then
                                        br_4 = [[<br>]]
                                    else
                                        br_4 = [[ ]]
                                    end
                                    local autobrake_ecam = autopilot_ecam() .. autobrake_ecam_mode .. br_4
                                    return autobrake_ecam
                                end -- function autobrake_ecam()
                                autobrake_ecam()

                                function fuel_ecam()
                                    local fuel_ecam = autobrake_ecam() .. a_fuelwarning_hud
                                    fuel_ecam = fuel_ecam .. s_fuelwarning_hud
                                    fuel_ecam = fuel_ecam .. r_fuelwarning_hud
                                    return fuel_ecam
                                end -- function fuel_ecam()
                                fuel_ecam()

                            return fuel_ecam()
                            end -- function ECAM()
                            ECAM()


                        --ATMO FUEL MIN TIME
                            a_t_h = 0
                            a_t_m = 0
                            a_t_s = 0

                            function a_fuel_minimum_time()
                                local key = 1
                                local i = 1
                                local minutes_min = json.decode(atmofueltank[i].getData()).timeLeft
                                    while minutes_min == "n/a" do i = i + 1
                                        if i > atmofueltank_size then
                                            i = 1
                                            minutes_min = 0
                                        else
                                            minutes_min = json.decode(atmofueltank[i].getData()).timeLeft
                                        end
                                    end
                                    for k, v in ipairs(atmofueltank) do
                                        local timeleft = json.decode(atmofueltank[k].getData()).timeLeft
                                            if timeleft ~= "n/a" and timeleft > 0 then
                                                if timeleft < minutes_min then
                                                    key = k
                                                    minutes_min = timeleft
                                                end
                                            end
                                    end
                                a_t_h = minutes_min/3600
                                a_t_m = (a_t_h-(math.floor(a_t_h)))*60
                                a_t_s = (a_t_m-(math.floor(a_t_m)))*60

                            end -- function a_fuel_minimum_time()


                        --SPACE FUEL MIN TIME AND PERCENTAGE
                            s_t_h = 0
                            s_t_m = 0
                            s_t_s = 0

                            function s_fuel_minimum_time()
                                local key = 1
                                local i = 1
                                local minutes_min = json.decode(spacefueltank[i].getData()).timeLeft
                                while minutes_min == "n/a" do i = i + 1
                                    if i > spacefueltank_size then
                                        i = 1
                                        minutes_min = 0
                                    else
                                        minutes_min = json.decode(spacefueltank[i].getData()).timeLeft
                                    end
                                end
                                for k, v in ipairs(spacefueltank) do
                                    local timeleft = json.decode(spacefueltank[k].getData()).timeLeft
                                    if timeleft ~= "n/a" and timeleft > 0 then
                                        if timeleft < minutes_min then
                                            key = k
                                            minutes_min = timeleft
                                        end
                                    end
                                end
                                s_t_h = minutes_min/3600
                                s_t_m = (s_t_h-(math.floor(s_t_h)))*60
                                s_t_s = (s_t_m-(math.floor(s_t_m)))*60

                            end -- function s_fuel_minimum_time()


                        --ROCKET FUEL MIN TIME
                            r_t_h = 0
                            r_t_m = 0
                            r_t_s = 0

                            if rocketfueltank_size ~= 0 then
                                function r_fuel_minimum_time()
                                    local key = 1
                                    local i = 1
                                    local minutes_min = json.decode(rocketfueltank[i].getData()).timeLeft   
                                    while minutes_min == "n/a" do i = i + 1
                                        if i > rocketfueltank_size then
                                            i = 1
                                            minutes_min = 0
                                        else
                                            minutes_min = json.decode(rocketfueltank[i].getData()).timeLeft
                                        end
                                    end
                                    for k, v in ipairs(rocketfueltank) do
                                        local timeleft = json.decode(rocketfueltank[k].getData()).timeLeft
                                        if timeleft ~= "n/a" and timeleft > 0 then
                                            if timeleft < minutes_min then
                                                key = k
                                                minutes_min = timeleft
                                            end
                                        end
                                    end
                                    r_t_h = minutes_min/3600
                                    r_t_m = (r_t_h-(math.floor(r_t_h)))*60
                                    r_t_s = (r_t_m-(math.floor(r_t_m)))*60
                                end -- function r_fuel_minimum_time()
                            end -- if rocketfueltank_size ~= 0 then


                        --LANDING GEAR
                            function landing_gear()
                                ldg_st = unit.isAnyLandingGearExtended()
                                if ldg_st == 0 then
                                    ldg_st = [[red]]
                                else
                                    ldg_st = [[green]]
                                end
                            end -- function landing_gear()
                            landing_gear()


                        --LIGHTS
                            function f_lights_st()
                                lights_st = unit.isAnyHeadlightSwitchedOn()
                                if lights_st == 1 then
                                    lights_st_hud = [[#00FFFF]]
                                else
                                    lights_st_hud = [[#141fad]]
                                end
                            end -- function f_lights_st()
                            f_lights_st()


                        --RETRO ROCKET
                            function f_rrThrust_hud()
                                rrThrust_hud = 0
                                if json.decode(unit.getData()).maxBrake then
                                    local unit_data = json.decode(unit.getData())
                                    rrThrust_hud = (math.floor(unit_data.maxBrake/1000)) -- kN
                                end
                            end -- function rrThrust()
                            f_rrThrust_hud()


                        --BRAKING DISTANCE
                            final_speed_brk = 0
                            function braking_distance()

                                local c  = 30000*1000/3600
                                local c2 = c*c
                                local initialSp = (math.floor((vec3(core.getVelocity()):len())*3.6))*0.277777777778 -- INSERT Km/h
                                local finalSp = (final_speed_brk)*0.277777777778 -- INSERT Km/h
                                local restMass = (math.floor(core.getConstructMass()/1000*10)/10)*1000 -- INSERT t
                                local rrThrust = 0
                                if json.decode(unit.getData()).maxBrake then
                                    local unit_data = json.decode(unit.getData())
                                    rrThrust = (math.floor(unit_data.maxBrake/1000))*1000 -- INSERT kN
                                end

                                local totA   = -rrThrust * 1/restMass
                                local distance = 0
                                local time     = 0

                                if (initialSp > finalSp) then
                                    local k1    = c*math.asin(initialSp/c)
                                    local k2    = c2 *math.cos(k1/c)/totA
                                    local t     = (c * math.asin(finalSp/c) - k1)/totA
                                    local d     = k2 - c2 * math.cos((totA*t + k1)/c)/totA
                                    distance  = distance + d
                                    time      = time + t
                                end

                                brake_min = math.floor(time/60)
                                brake_sec = math.floor(((time/60)-brake_min)*60)

                                brake_su = math.floor(distance/200000*100)/100
                                brake_km = math.floor(distance/1000)

                            end -- function braking_distance()
                            braking_distance()


                        --SPACE DATA
                            function navigator_space_data()
                                if databank.getStringValue("navigator_target_destination") then
                                    navigator_target_destination_hud = databank.getStringValue("navigator_target_destination")
                                else
                                    navigator_target_destination_hud = "no Dest."
                                end

                                if (databank.getIntValue("navigator_eta_h") or databank.getIntValue("navigator_eta_m") or databank.getIntValue("navigator_eta_s")) then
                                    local time_h = databank.getIntValue("navigator_eta_h")
                                    local time_m = databank.getIntValue("navigator_eta_m")
                                    local time_s = databank.getIntValue("navigator_eta_s")
                                    navigator_eta_hud = time_h ..":".. time_m ..":".. time_s
                                else
                                    navigator_eta_hud = "0:0:0"
                                end

                                if databank.getFloatValue("navigator_speed") then
                                    navigator_speed_hud = math.floor(databank.getFloatValue("navigator_speed"))
                                else
                                    navigator_speed_hud = "0"
                                end

                                if databank.getFloatValue("navigator_distance") then
                                    if databank.getFloatValue("navigator_distance") == 0 then
                                        navigator_distance_hud = "n/a"
                                    else
                                        navigator_distance_hud = databank.getFloatValue("navigator_distance")
                                    end
                                end

                                if databank.getStringValue("navigator_coordinates") then
                                    navigator_coordinates_hud = databank.getStringValue("navigator_coordinates")
                                else
                                    navigator_coordinates_hud = "n/a"
                                end

                                if databank.getStringValue("navigator_from") then
                                    navigator_from_hud = databank.getStringValue("navigator_from")
                                else
                                    navigator_from_hud = "no From"
                                end

                                if databank.getStringValue("navigator_from_coordinates") then
                                    navigator_from_coordinates_hud = databank.getStringValue("navigator_from_coordinates")
                                else
                                    navigator_from_coordinates_hud = "n/a"
                                end

                            end -- function navigator_space_data()

                        --DATABANK CONDITION for SPACE DATA
                            function databank_condition()
                                if databank then
                                    if databank.getNbKeys() == 0 then
                                        navigator_target_destination_hud = "Console Off"
                                        navigator_eta_hud = "n/a"
                                        navigator_speed_hud = "n/a"
                                        navigator_distance_hud = "n/a"
                                        navigator_coordinates_hud = "n/a"
                                        navigator_from_hud = "n/a"
                                        navigator_from_coordinates_hud = "n/a"
                                    else
                                        navigator_space_data()
                                    end
                                else
                                    navigator_target_destination_hud = "Databank Not Installed"
                                    navigator_eta_hud = "n/a"
                                    navigator_speed_hud = "n/a"
                                    navigator_distance_hud = "n/a"
                                    navigator_coordinates_hud = "n/a"
                                    navigator_from_hud = "n/a"
                                    navigator_from_coordinates_hud = "n/a"
                                end
                            end -- function databank_condition()
                            databank_condition()

                    end -- air_data()


                --SVG
                    --SVG A FUEL
                        function a_fuel_svg()
                            return	[[
                                <svg width="30" height="75">
                                    <rect x="0" y="0" width="30" height="]] .. a_fuel_percent_avg_hud .. [[%" style=" fill: dodgerblue" transform="rotate(180, 15, 37)" />
                                </svg>
                            ]]
                        end -- function a_fuel_svg()


                    --SVG S FUEL
                        function s_fuel_svg()
                            return	[[<svg width="30" height="75">
                                    <rect x="0" y="0" width="30" height="]] .. s_fuel_percent_avg_hud .. [[%" style=" fill: yellow" transform="rotate(180, 15, 37)" />
                                    </svg>]]
                        end -- function s_fuel_svg()


                    --SVG R FUEL
                        function r_fuel_svg()
                            return	[[
                                <svg width="30" height="75">
                                    <rect x="0" y="0" width="30" height="]] .. r_fuel_percent_avg_hud .. [[%" style=" fill: slateblue" transform="rotate(180, 15, 37)" />
                                </svg>
                            ]]
                        end -- function r_fuel_svg()


                    --SVG MTOW
                        function MTOW_svg()
                            return	[[
                                <svg width="30" height="40">
                                    <rect x="0" y="0" width="30" height="]] .. MTOW_p .. [[%" style=" fill:yellow" transform="rotate(180, 15, 20)" />
                                </svg>
                            ]]
                        end -- function MTOW_svg()


                    --SVG THRUST
                        function thr_svg()
                            return	[[
                                <svg width="30" height="50">
                                    <rect x="0" y="0" width="30" height="]] .. thr .. [[%" style=" fill:#00FFFF" transform="rotate(180, 15, 25)" />
                                </svg>]]
                        end --function thr_svg()


                    --SVG ARTIFICIAL HORIZON
                        function art_h_svg()
                            return [[
                                <svg width="150" height="75">
                                    <g style=" stroke: yellow; stroke-width: 1; fill: none" transform=" rotate(]] .. roll_hud .. [[,75,35) translate(0 ]] .. pitch_hud .. [[)">
                                        <polyline points="65,-20 75,-10 85,-20" style=" stroke:#00FFFF"/> -- +45 deg down arrow
                                        <polyline points="65,-35 75,-25 85,-35" style=" stroke:#00FFFF"/> -- +60 deg down arrow
                                        <polyline points="65,-50 75,-40 85,-50" style=" stroke:#00FFFF"/> -- +75 deg down arrow
                                        <polyline points="65,-60 75,-70 85,-60" style=" stroke:#00FFFF"/> -- +75 deg up arrow
                                        <polyline points="65,-75 75,-85 85,-75" style=" stroke:#00FFFF"/> -- +60 deg up arrow
                                        <polyline points="65,-90 75,-100 85,-90" style=" stroke:#00FFFF"/> -- +45 deg up arrow
                                        <polyline points="65,90 75,80 85,90"/> -- -45 deg up arrow
                                        <polyline points="65,105 75,95 85,105"/> -- -60 deg up arrow
                                        <polyline points="65,120 75,110 85,120"/> -- -75 deg up arrow
                                        <polyline points="65,130 75,140 85,130"/> -- -75 deg down arrow
                                        <polyline points="65,145 75,155 85,145"/> -- -60 deg down arrow
                                        <polyline points="65,160 75,170 85,160"/> -- -60 deg down arrow

                                        <line x1="0" y1="35" x2="70" y2="35"/> -- left terrein line
                                        <line x1="80" y1="35" x2="150" y2="35"/> -- right terrein line
                                        <line x1="75" y1="5" x2="75" y2="-115" style=" stroke: #00FFFF"/> -- lower sky line
                                        <line x1="65" y1="5" x2="85" y2="5" style=" stroke: #00FFFF; stroke-width: 2"/> -- 30 deg up
                                        <line x1="65" y1="65" x2="85" y2="65" style=" stroke-width: 2"/> -- -30 deg down
                                        <line x1="75" y1="65" x2="75" y2="185" style=" stroke: red"/> -- too low pitch
                                    </g>
                                    <g style=" stroke: white; stroke-width: 1">
                                        <line x1="0" y1="35" x2="15" y2="35"/> -- 0 pitch left
                                        <line x1="135" y1="35" x2="150" y2="35"/> -- 0 pitch right
                                        <line x1="75" y1="0" x2="75" y2="5"/> -- 0 roll top
                                        <line x1="75" y1="70" x2="75" y2="75"/> -- 0 roll bottom
                                        <rect x="72.5" y="32.5" width="5" height="5" fill=" white"/> -- 0 box
                                    </g>
                                    <g style=" stroke: white; stroke-width: 1"  transform=" translate(]]..yaw_bird_hud.." "..pitch_bird_hud..[[)">
                                        <circle cx="75" cy="35" r="5" fill-opacity="0"/> -- bird
                                        <line x1="75" y1="20" x2="75" y2="30"/> -- bird tail
                                        <line x1="50" y1="35" x2="70" y2="35"/> -- bird left wing
                                        <line x1="80" y1="35" x2="100" y2="35"/> -- bird right wing
                                    </g>
                                </svg>
                            ]]
                        end -- function art_h_svg()


                    --SVG SPACE ORIENTATION
                        function space_orientation_svg()
                            return [[
                                <svg  width="100%" height="100%" viewbox="0 0 150 70" style="background-color: black">
                                    <g style=" stroke: white; stroke-width: 1; fill: none" transform=" translate(]]..yaw_space_hud.." "..pitch_space_hud..[[)">
                                        <circle cx="75" cy="35" r="10" style=" stroke-width: 2"/> -- vector 0
                                        <circle cx="-105" cy="35" r="5" fill="white"/> -- vector 180 0
                                        <circle cx="255" cy="35" r="5" fill="white"/> -- vector -180 0
                                        <circle cx="75" cy="-145" r="5" fill="white"/> -- vector 0 180
                                        <circle cx="75" cy="215" r="5" fill="white"/> -- vector 0 -180
                                        <circle cx="255" cy="215" r="5" fill="white"/> -- vector -180 -180
                                        <circle cx="-105" cy="-145" r="5" fill="white"/> -- vector 180 180
                                        <circle cx="255" cy="-145" r="5" fill="white"/> -- vector -180 180
                                        <circle cx="-105" cy="215" r="5" fill="white"/> -- vector 180 -180

                                        <polyline points="75,-65 85,-55 75,-45 65,-55 75,-65"/> -- ortogonal 0 90
                                        <polyline points="75,115 85,125 75,135 65,125 75,115"/> -- ortogonal 0 -90
                                        <polyline points="-105,-65 -95,-55 -105,-45 -115,-55 -105,-65"/> -- ortogonal 180 90
                                        <polyline points="255,-65 265,-55 255,-45 245,-55 255,-65"/> -- ortogonal -180 90
                                        <polyline points="255,115 265,125 255,135 245,125 255,115"/> -- ortogonal -180 -90
                                        <polyline points="-105,115 -95,125 -105,135 -115,125 -105,115"/> -- ortogonal 180 -90

                                        <rect x="-25" y="25" width="20" height="20"/> -- Vector 90 0
                                        <rect x="155" y="25" width="20" height="20"/> -- Vector -90 0
                                        <rect x="-25" y="205" width="20" height="20"/> -- Vector 90 -180
                                        <rect x="155" y="-155" width="20" height="20"/> -- Vector -90 180
                                        <rect x="-25" y="-155" width="20" height="20"/> -- Vector 90 180
                                        <rect x="155" y="205" width="20" height="20"/> -- Vector -90 -180
                                    </g>

                                    <g style=" stroke: white; stroke-width: 1">
                                        <line x1="75" y1="35" x2="]].. 75 + yaw_space_hud..[[" y2="]].. 35 + pitch_space_hud..[["/> -- Velocity Vector
                                    </g>

                                    <g style=" stroke: #00FFFF; stroke-width: 1">
                                        <line x1="75" y1="35" x2="]].. 75 + yaw_WP_hud..[[" y2="]].. 35 + pitch_WP_hud..[["/> -- Destination Vector
                                    </g>

                                    <g style=" stroke: #00FFFF; stroke-width: 2; fill: none" transform=" translate(]]..yaw_WP_hud.." "..pitch_WP_hud..[[)">
                                        <circle cx="75" cy="35" r="12"/> -- Destination
                                    </g>

                                    <g style=" stroke: yellow; stroke-width: 2">
                                        <line x1="65" y1="25" x2="85" y2="45"/> -- Pointer
                                        <line x1="65" y1="45" x2="85" y2="25"/> -- Pointer
                                    </g>

                                    <g style=" font-size:12px">
                                        <text fill="white" x="5" y="20">]]..yaw_space_hud..[[
                                            <tspan x="5" y="35" fill=" yellow">Yaw</tspan>
                                            <tspan x="5" y="50"  fill=" #00FFFF">]]..yaw_WP_hud..[[</tspan>
                                        </text>
                                        <text fill="white" x="120" y="20">]]..pitch_space_hud..[[
                                            <tspan x="120" y="35" fill=" yellow">Pitch</tspan>
                                            <tspan x="120" y="50"  fill=" #00FFFF">]]..pitch_WP_hud..[[</tspan>
                                        </text>
                                        </text>
                                            <text fill="red"  x="50%" y="90%" dominant-baseline="middle" text-anchor="middle">]].. align_active_mode ..[[
                                        </text>
                                        </text>
                                            <text fill="#00FFFF"  x="50%" y="10%" dominant-baseline="middle" text-anchor="middle">]].. adjusting_mode ..[[
                                        </text>
                                    </g>
                                </svg>
                            ]]
                        end -- space_orientation_svg()


                    --SVG ORBIT
                        orbit_t_to_apo_seconds = 0
                        ship_PPOS_svg = vec3(core.getConstructWorldPos())
                        function f_orbit_svg()

                            if orbit_period_seconds > 0 then

                                    map_scale_setting = 2500
                                    if scale == nil then
                                        scale = map_scale_setting
                                    end
                                    scale  = scale
                                    local fix    = 80
                                    local OrbCx  = (orbit_per_alt + orbit_apo_alt + 2*planet_radius)/2/scale + fix
                                    local OrbRx  = OrbCx - fix
                                    local PlCx   = (OrbRx - ( orbit_ecc * OrbRx)) + fix
                                    local Plr    = planet_radius/scale
                                    local OrbRy  = math.sqrt(OrbRx^2 - (orbit_ecc * OrbRx)^2)
                                    local ApCx   = OrbCx + OrbRx
                                    local ShCx1  = PlCx
                                    local ShCx2  = PlCx + my_planet_alt/scale
                                    local altitude = my_planet_alt - planet_radius
                                    local PeTargetAlt_svg = Plr + (PeTargetAlt/scale)

                                    local b = my_planet_alt/scale
                                    local c = (OrbCx - PlCx)*2
                                    local a = (OrbRx * 2) - b
                                    if orbit_t_to_apo ~= nil then
                                        if (orbit_period_seconds > 0 and orbit_t_to_apo ~= "n/a" and (orbit_t_to_apo_seconds / orbit_period_seconds) >= 0.5) then
                                            LineR = math.deg(math.acos((b^2 + c^2 - a^2) / (2 * b * c)))
                                            if (LineR ~= LineR and (orbit_t_to_apo_seconds / orbit_period_seconds) > 0.75) then
                                                LineR = 0
                                            elseif (LineR ~= LineR and (orbit_t_to_apo_seconds / orbit_period_seconds) < 0.75) then
                                                LineR = 180
                                            end
                                        else
                                            LineR = 360 - (math.deg(math.acos((b^2 + c^2 - a^2) / (2 * b * c))))
                                            if (LineR ~= LineR and (orbit_t_to_apo_seconds / orbit_period_seconds) > 0.25) then
                                                LineR = 180
                                            elseif (LineR ~= LineR and (orbit_t_to_apo_seconds / orbit_period_seconds) < 0.25) then
                                                LineR = 0
                                            end
                                        end
                                    end

                                    if orbit_per_alt < (PeTargetAlt - 1000) then
                                        OrbCo = [[ red ]]
                                    else
                                        OrbCo = [[ #00FFFF ]]
                                    end
                                    if orbit_ecc == 0 then
                                        orbit_Opacity = 0
                                    else
                                        orbit_Opacity = 100
                                    end

                                    if orbit_ecc < 1 then
                                        ship_PPOS_svg = vec3(core.getConstructWorldPos())
                                    end

                                    local OrbRy_max = 70
                                    local OrbRy_min = 35
                                    local ApCx_max = 330
                                    local ApCx_min = 200
                                    local min_scale = 1000

                                    if OrbRy > OrbRy_max then
                                        scale_O = scale*2
                                    end
                                    if OrbRy < OrbRy_max then
                                        if OrbRy < OrbRy_min then
                                            scale_O = scale/2
                                        else
                                            scale_O = scale
                                        end
                                    end

                                    if ApCx > ApCx_max then
                                        scale_A = scale*2
                                    end
                                    if ApCx < ApCx_max then
                                        if ApCx < ApCx_min then
                                            scale_A = scale/2
                                        else
                                            scale_A = scale
                                        end
                                    end

                                    scale = math.max(scale_O, scale_A, min_scale)

                                return [[
                                    <svg width="360" height="150">
                                        <circle id="TargetPEAlt" cx="]] .. PlCx .. [[" cy="75" r="]] .. PeTargetAlt_svg .. [[" stroke-width="1" stroke="white" fill="none" />
                                        <circle id="Planet" cx="]] .. PlCx .. [[" cy="75" r="]] .. Plr .. [[" fill="darkslategrey" />
                                        <ellipse id="Orbit" cx="]] .. OrbCx .. [[" cy="75" rx="]] .. OrbRx .. [[" ry="]] .. OrbRy .. [[" style=" fill: none; stroke: ]] .. OrbCo .. [[; stroke-width:1; opacity: ]] .. orbit_Opacity .. [[%" />
                                        <circle id="Pe" cx="]] .. fix .. [[" cy="75" r="3" stroke="green" stroke-width="1" fill="green" />
                                        <circle id="Ap" cx="]] .. ApCx .. [[" cy="75" r="3" stroke="green" stroke-width="2" fill="none" />
                                        <g transform=" rotate(]] .. LineR .. " " .. ShCx1 .. [[ 75)">
                                            <line id="ship" x1="]] .. ShCx1 .. [[" y1="75" x2="]] .. ShCx2 .. [[" y2="75" stroke="yellow" stroke-width="2"  opacity="100%"/>
                                        </g>
                                        <text x="10" y="20" fill="green" font-size="15px">Altitude:
                                            <tspan x="10" y="40" fill="yellow">]] .. math.floor(altitude/1000*10)/10 .. [[</tspan><tspan fill="#00FFFF"> Km</tspan>
                                        </text>
                                        <text x="10" y="130" fill="green" font-size="15px">Circ Orb Speed:
                                            <tspan x="10" y="150" fill="yellow">]] .. math.floor(orbit_circular_speed) .. [[</tspan><tspan fill="#00FFFF"> m/s</tspan>
                                        </text>
                                        <text x="250" y="20" fill="green" font-size="15px">Map Scale:
                                            <tspan x="250" y="40" fill="yellow">]] .. math.floor(scale) .. [[</tspan>
                                        </text>
                                        <text x="250" y="130" fill="green" font-size="15px">D To Pe:
                                            <tspan x="250" y="150" fill="yellow">]] .. math.floor(pe_dis) .. [[</tspan><tspan fill="#00FFFF"> Km</tspan>
                                        </text>
                                    </svg>
                                ]]
                            else
                                return interplanet_svg()
                            end -- if orbit_period_seconds > 0 then

                        end -- function f_orbit_svg()


                    --SVG INTERPLANET
                        nav_planet_scale = 80000 --export: to scale the FROM TO graphic
                        function interplanet_svg()

                            local myPos = vec3(core.getConstructWorldPos())

                            if databank then
                                if (databank.getNbKeys() ~= 0 and databank.getStringValue("navigator_from_coordinates") ~= "n/a" and databank.getStringValue("navigator_from") ~= "PPOS") then
                                    planet_A_coord = vec3FromStr(databank.getStringValue("navigator_from_coordinates"))
                                    from_name_hud = databank.getStringValue("navigator_from")
                                    planet_A_opacity = 100
                                    from_planet_radius = databank.getIntValue("navigator_from_planet_radius")
                                    planet_A_radius = (20 / nav_planet_scale)* from_planet_radius
                                    x1_path = 50 + planet_A_radius
                                    ship_x1 = 50 + planet_A_radius
                                    ship_x2 = 40 + planet_A_radius

                                elseif (databank.getNbKeys() ~= 0 and databank.getStringValue("navigator_from_coordinates") ~= "n/a" and databank.getStringValue("navigator_from") == "PPOS") then
                                    planet_A_coord = vec3FromStr(databank.getStringValue("navigator_from_coordinates"))
                                    from_name_hud = "PPOS"
                                    planet_A_opacity = 0
                                    planet_A_radius = 20
                                    x1_path = 50
                                    ship_x1 = 50
                                    ship_x2 = 40
                                else
                                    planet_A_coord = ship_PPOS_svg
                                    from_name_hud = "PPOS"
                                    planet_A_opacity = 0
                                    planet_A_radius = 20
                                    x1_path = 50
                                    ship_x1 = 50
                                    ship_x2 = 40
                                end

                                if (databank.getNbKeys() ~= 0 and databank.getStringValue("navigator_coordinates") ~= "n/a") then
                                    planet_B_coord = vec3FromStr(databank.getStringValue("navigator_coordinates"))
                                    to_name_hud = databank.getStringValue("navigator_target_destination")
                                    to_planet_radius = databank.getIntValue("navigator_target_planet_radius")
                                    planet_B_radius = (20 / nav_planet_scale)* to_planet_radius
                                    x2_path = 310 - planet_B_radius
                                else
                                    planet_B_coord = planet_pos
                                    to_name_hud = planet_name
                                    to_planet_radius = planet_radius
                                    planet_B_radius = (20 / nav_planet_scale)* to_planet_radius
                                    x2_path = 310 - planet_B_radius
                                end
                            else
                                planet_A_coord = ship_PPOS_svg
                                from_name_hud = "PPOS"
                                planet_A_opacity = 0
                                planet_B_coord = planet_pos
                                to_name_hud = planet_name
                                to_planet_radius = planet_radius
                                planet_B_radius = (20 / nav_planet_scale)* to_planet_radius
                                x2_path = 310 - planet_B_radius

                                x1_path = 50
                                planet_A_radius = 20
                                ship_x1 = 50
                                ship_x2 = 40
                            end -- if databank

                            distance_PPOS_B_hud = math.floor(((planet_B_coord - myPos):len())/1000/200*100)/100
                            local distance_PPOS_A_hud = math.floor(((planet_A_coord - myPos):len())/1000/200*100)/100

                            local ATA_h = (((planet_B_coord - myPos):len())/1000) / speed_hud -- Hours
                            local ATA_m = (ATA_h - math.floor(ATA_h))*60
                            local ATA_s = (ATA_m - math.floor(ATA_m))*60
                            local ATA_hud = math.floor(ATA_h) ..":".. math.floor(ATA_m) ..":".. math.floor(ATA_s)
                            if speed_hud == 0 then
                                ATA_hud = "n/a"
                            end

                            local tot_distance = distance_PPOS_A_hud + distance_PPOS_B_hud

                            x1_x2_path = x2_path - x1_path

                            if from_name_hud == "PPOS" then
                                ship_pos_svg = x1_x2_path - (distance_PPOS_B_hud / tot_distance)*x1_x2_path
                                if (distance_PPOS_B_hud / tot_distance) > 0.5 then
                                    ship_pos_svg = ship_pos_svg + ((to_planet_radius/1000/200) / tot_distance)*x1_x2_path
                                else
                                    ship_pos_svg = ship_pos_svg
                                end
                            elseif from_name_hud ~= "PPOS" then
                                ship_pos_svg = (distance_PPOS_A_hud / tot_distance)*x1_x2_path
                                if (distance_PPOS_A_hud / tot_distance) < 0.5 then
                                    ship_pos_svg = ship_pos_svg - ((from_planet_radius/1000/200) / tot_distance)*x1_x2_path
                                else
                                    ship_pos_svg = ship_pos_svg
                                end
                            end

                            return [[
                                <svg width="360" height="150">
                                    <line id="Path" x1="]].. x1_path ..[[" y1="55" x2="]].. x2_path ..[[" y2="55" stroke="yellow" stroke-width="1"/>
                                    
                                    <circle id="Planet_A" cx="50" cy="55" r="]].. planet_A_radius ..[[" style=" fill: darkslategrey; stroke: #00FFFF; stroke-width:1; opacity: ]].. planet_A_opacity ..[[" />
                                    <circle id="Planet_B" cx="310" cy="55" r="]].. planet_B_radius ..[[" style=" fill:darkslategrey; stroke: #00FFFF; stroke-width:1;" />

                                    <g transform=" translate(]].. ship_pos_svg .. [[ 0)">
                                        <polygon points="]].. ship_x1 ..[[,55 ]].. ship_x2 ..[[,63 ]].. ship_x2 ..[[,47" style=" fill:#00FFFF; stroke:green; stroke-width:1; fill-rule:evenodd" />
                                    </g>
                                    <text x="10" y="15" fill="green" font-size="14px">From:
                                        <tspan x="10" y="30" fill="#00FFFF">]] .. from_name_hud .. [[</tspan>
                                    </text>
                                    <text x="140" y="15" fill="green" font-size="14px">Dist:
                                        <tspan x="140" y="30" fill="yellow">]] .. tot_distance .. [[</tspan><tspan fill="#00FFFF"> Su</tspan>
                                    </text>
                                    <text x="250" y="15" fill="green" font-size="14px">To:
                                        <tspan x="250" y="30" fill="#00FFFF">]] .. to_name_hud .. [[</tspan>
                                    </text>
                                    <text x="10" y="90" fill="green" font-size="14px">Dist:
                                        <tspan x="10" y="105" fill="yellow">]] .. distance_PPOS_A_hud .. [[</tspan><tspan fill="#00FFFF"> Su</tspan>
                                    </text>
                                    <text x="140" y="90" fill="green" font-size="14px">ATA:
                                        <tspan x="140" y="105" fill="yellow">]] .. ATA_hud .. [[</tspan>
                                    </text>
                                    <text x="250" y="90" fill="green" font-size="14px">Dist:
                                        <tspan x="250" y="105" fill="yellow">]] .. distance_PPOS_B_hud .. [[</tspan><tspan fill="#00FFFF"> Su</tspan>
                                    </text>
                                    <text x="10" y="130" fill="green" font-size="14px">Circ Orb Speed:
                                    <tspan x="10" y="145" fill="yellow">]] .. math.floor(orbit_circular_speed) .. [[</tspan><tspan fill="#00FFFF"> m/s</tspan>
                                    </text>
                                    <text x="250" y="130" fill="green" font-size="14px">Dist To PE:
                                    <tspan x="250" y="145" fill="yellow">]] .. math.floor(pe_dis) .. [[</tspan><tspan fill="#00FFFF"> Km</tspan>
                                    </text>
                                </svg>
                            ]]
                        end -- function interplanet_svg()


                --HTML SCREENS

                    --RIGHT MONITOR
                        function monitor_right()
                            return [[
                                <div class="monitor_right"><div class="window center">
                                    <table style="border:1px solid yellow; text-align: center; vertical-align: top; color:yellow; font-size: 13px">
                                        <tr height="30vh" style="color: green"><th width="30vw">Speed</th><td width="10vw" rowspan="5"> </td><th width="30vw"> Pitch </th><th width="10vw" rowspan="5"> </th><th width="90vw"> Roll </th><th width="10vw" rowspan="5"> </th><th style=" text-align: left" colspan="2">Atmo F</th><th style=" text-align: left" colspan="2">Space F</th><th style=" text-align: left" colspan="2">Rockets F</th></tr>
                                        <tr height="30vh"><td>]] .. speed_hud .. [[</td><td>]] .. pitch_hud .. [[</td><td>]] .. roll_direction .. [[</td><td width="30vw">]] .. a_fuel_percent_avg_hud .. [[</td><td width="40vw"> % </td><td width="30vw">]] .. s_fuel_percent_avg_hud .. [[</td><td width="40vw"> % </td><td width="30vw">]] .. r_fuel_percent_avg_hud .. [[</td><td width="40vw"> % </th></tr>
                                        <tr height="30vh"><td style="color: #00FFFF">]] .. thr .. [[&nbsp%</td><td style=" text-align: right">]].. brake_active ..[[</td><td style=" text-align: left">]].. brake_status ..[[</td><td style="border:1px solid #00FFFF" rowspan="3">]] .. a_fuel_svg() .. [[</td><td>]] .. math.floor(a_t_h) .. [[</td><td style="border:1px solid #00FFFF" rowspan="3">]] .. s_fuel_svg() .. [[</td><td>]] .. math.floor(s_t_h) .. [[</td><td style="border:1px solid #00FFFF" rowspan="3">]] .. r_fuel_svg() .. [[</td><td>]] .. math.floor(r_t_h) .. [[</td></tr>
                                        <tr height="30vh"><td style="border:1px solid #00FFFF" rowspan="2">]] .. thr_svg() .. [[</td><th style=" text-align: right; color: green"> Alt </th><td>]] .. altitude .. [[</td><td>]] .. math.floor(a_t_m) .. [[</td><td>]] .. math.floor(s_t_m) .. [[</td><td>]] .. math.floor(r_t_m) .. [[</td></tr>
                                        <tr height="30vh"><th style=" text-align: right; color: green"> V/S </th><td>]] .. vs_hud .. [[</td><td>]] .. math.floor(a_t_s) .. [[</td><td>]] .. math.floor(s_t_s) .. [[</td><td>]] .. math.floor(r_t_s) .. [[</td></tr>
                                    </table>
                                </div></div>
                            ]]
                        end -- monitor_right()


                    --OPTION 1 (Loading page)
                        function monitor_left_loading()
                            return [[
                                <div class="monitor_left"><div class="window center">
                                    <table style="border:1px solid yellow; text-align: center; vertical-align: top; color:yellow; font-size: 12px">
                                        <tr height="25vh"><td width="5vw" rowspan="5"></td><td style=" color: green" colspan="3">Annunciator Lights</td><td width="5vw" rowspan="5"> </td><td style=" color: green; border:1px solid yellow"> Load </td><th style=" border: 1px solid yellow; color: green" colspan="3" width="180vw">Load &nbsp &nbsp DOW: &nbsp &nbsp<span style=" color: yellow">]] .. dow_m .. [[&nbsp<span style=" color: #00FFFF">t</span></span></th></tr>
                                        <tr height="25vh"><td width="40vw" style=" border: 1px solid slategray; color:]] .. ldg_st .. [[">LDG</td><td width="40vw" style=" border: 1px solid slategray; color:]] .. lights_st_hud .. [["> Œ </td><td width="40vw" style=" border: 1px solid slategray; color: ]] .. r_active_hud .. [[">ROCKET</td><td width="50vw" style=" color: #00FFFF; border:1px solid yellow"> AI </td><td style=" text-align: left"><span style=" color: green">&nbsp Load &nbsp</span></td><td style=" text-align: right">]] .. cargo_m_t_hud .. [[<span style=" color: #00FFFF">&nbsp t &nbsp</span></td><td style=" font-size: 10px; color: green">MTOW <span style=" color: #00FFFF">]] ..math.floor(MTOW/1000*10)/10 .. [[&nbspt</span></td></tr>
                                        <tr height="25vh"><td style=" border: 1px solid slategray">]] .. a_fuelspy_hud ..[[</td><td style=" border: 1px solid slategray">]] .. s_fuelspy_hud ..[[</td><td style=" border: 1px solid slategray">]] .. r_fuelspy_hud ..[[</td><td style=" color: #00FFFF; border:1px solid yellow"> SPC </td><td style=" text-align: left"><span style=" color: green">&nbsp ZFW &nbsp</span></td><td style=" text-align: right">]] .. zfw_m .. [[<span style=" color: #00FFFF">&nbsp t &nbsp</span></td><td>]] .. MTOW_p .. [[&nbsp %</td></tr>
                                        <tr height="25vh"><td style=" border: 1px solid slategray; font-size: 12px; text-align: left; vertical-align: top" rowspan="3" colspan="3">]] .. ECAM() .. [[</td><td style=" color: #00FFFF; border:1px solid yellow"> ORB </td><td style=" text-align: left"><span style=" color: green">&nbsp Fuel &nbsp</span></td><td style=" text-align: right">]] .. fuel_mass .. [[<span style=" color: #00FFFF">&nbsp t &nbsp</span></td><td style="border: 1px solid #00FFFF; vertical-align: top" rowspan="2">]] .. MTOW_svg() .. [[</td></tr>
                                        <tr height="25vh"><td style=" color: #00FFFF; border:1px solid yellow"> slot5 </td><td style=" text-align: left"><span style=" color: green">&nbsp GW &nbsp</span></td><td style=" text-align: right">]] .. gw_m .. [[<span style=" color: #00FFFF">&nbsp t &nbsp</span></td></tr>
                                        <tr> <td></td> <td></td> <td style=" border:1px solid yellow" colspan="4"> </td></tr>
                                    </table>
                                </div></div>
                            ]]
                        end -- monitor_left_loading()


                    --OPTION 2 (AI page)
                        function monitor_left_atmo()
                            return [[
                                <div class="monitor_left"><div class="window center">
                                    <table style="border:1px solid yellow; text-align: center; vertical-align: top; color:yellow; font-size: 12px">
                                        <tr height="25vh"><td width="5vw" rowspan="5"> </td><td style=" color: green" colspan="3">Annunciator Lights</td><td width="5vw" rowspan="5"> </td><td style=" color: #00FFFF; border:1px solid yellow"> Load </td><th style=" border: 1px solid yellow; color: green" colspan="2" width="180vw"> AI &nbsp&nbsp<span style=" color: yellow">]].. acc_hud ..[[</span>&nbsp<span style=" color: #00FFFF">g</span></th></tr>
                                        <tr height="25vh"><td width="40vw" style=" border: 1px solid slategray; color:]] .. ldg_st .. [[">LDG</td><td width="40vw" style=" border: 1px solid slategray; color:]] .. lights_st_hud .. [["> Œ </td><td width="40vw" style=" border: 1px solid slategray; color: ]] .. r_active_hud .. [[">ROCKET</td><td width="50vw" style=" color: green; border:1px solid yellow"> AI </td><td style=" color: red">]] .. radioalt_hud .. [[</td></tr>
                                        <tr height="25vh"><td style=" border: 1px solid slategray">]] .. a_fuelspy_hud ..[[</td><td style=" border: 1px solid slategray">]] .. s_fuelspy_hud ..[[</td><td style=" border: 1px solid slategray">]] .. r_fuelspy_hud ..[[</td><td style=" color: #00FFFF; border:1px solid yellow"> SPC </td><td colspan="2" rowspan="3">]] .. art_h_svg() .. [[</td></tr>
                                        <tr height="25vh"><td style=" border: 1px solid slategray; font-size: 12px; text-align: left; vertical-align: top" rowspan="3" colspan="3">]] .. ECAM() .. [[</td><td style=" color: #00FFFF; border:1px solid yellow"> ORB </td></tr>
                                        <tr height="25vh"><td style=" color: #00FFFF; border:1px solid yellow"> slot5 </td></tr>
                                        <tr> <td></td> <td></td> <td style=" border:1px solid yellow" colspan="3"> </td></tr>
                                    </table>
                                </div></div>
                            ]]
                        end -- monitor_left_atmo()


                    --OPTION 3 (Space page)
                        final_speed_brk = 0
                        function monitor_left_space()
                            return [[
                                <div class="monitor_left">
                                    <table width="360vw" class="window" style="border:1px solid yellow; text-align: left; color:yellow; font-size: 14px">
                                        <tr height="30vh"><td width="5vw"></td><th style=" color: green">From:</th><td style=" color: #00FFFF">]].. navigator_from_hud ..[[</td><th style=" color: green">To:</th><td style=" color: #00FFFF">]].. navigator_target_destination_hud ..[[</th></tr>
                                        <tr height="30vh"><td></td><th style=" color: green">Dist.</th><td>]] .. navigator_distance_hud .. [[<span style=" color: #00FFFF">&nbsp Su</span></td><td colspan="2" rowspan="4" width="180vw" height="120vh" style=" vertical-align: middle">]] .. space_orientation_svg() .. [[</td></tr>
                                        <tr height="30vh"><td></td><th style=" color: green">At Speed:</th><td>]] .. navigator_speed_hud .. [[<span style=" color: #00FFFF">&nbsp Km/h</span></td></tr>
                                        <tr height="30vh"><td></td><th style=" color: green">ETA:</th><td>]].. navigator_eta_hud ..[[</td></tr>
                                        <tr height="30vh"><td></td><th style=" color: green">Spare</th><td style=" font-size: 12px">Spare</td></tr>
                                    </table>
                                </div>

                                <div class="monitor_right" align="right">
                                    <table class="window" style="border:1px solid yellow; text-align: center; color:yellow; font-size: 30px">
                                        <tr height="150vh"><td width="360vw" style=" vertical-align: middle">]] .. interplanet_svg() .. [[<td></tr>
                                        <tr><td style=" text-align: left; color:yellow; font-size: 13px">Auto Brake in: &nbsp<span style=" color:white">]] .. autobrake_in .. [[</span>&nbsp<span style=" color:#00FFFF">Su</span> - <span style=" color:white">]].. autobrake_stops_at ..[[</span>&nbsp<span style=" color:#00FFFF">Su</span>&nbsp From Dest.</td></tr>
                                    </table>
                                </div>

                                <div class="monitor_left"><div class="window center">
                                    <table style="border:1px solid yellow; text-align: center; vertical-align: top; color:yellow; font-size: 12px">
                                        <tr height="25vh"><td width="5vw" rowspan="5"> </td><td style=" color: green" colspan="3">Annunciator Lights</td><td width="5vw" rowspan="5"> </td><td width="50vw" style=" color: #00FFFF; border:1px solid yellow"> Load </td><th style=" border: 1px solid yellow; color: green" colspan="2" width="180vw"> Space </th></tr>
                                        <tr height="25vh"><td width="40vw" style=" border: 1px solid slategray; color:]] .. ldg_st .. [[">LDG</td><td width="40vw" style=" border: 1px solid slategray; color:]] .. lights_st_hud .. [["> Œ </td><td width="40vw" style=" border: 1px solid slategray; color: ]] .. r_active_hud .. [[">ROCKET</td><td style=" color: #00FFFF; border:1px solid yellow"> AI </td><td style=" color: green">Stop in:</td><td>]] .. brake_min .. [[<span style=" color:#00FFFF">' &nbsp</span>]] .. brake_sec .. [[<span style=" color:#00FFFF">"</span></td></tr>
                                        <tr height="25vh"><td style=" border: 1px solid slategray">]] .. a_fuelspy_hud ..[[</td><td style=" border: 1px solid slategray">]] .. s_fuelspy_hud ..[[</td><td style=" border: 1px solid slategray">]] .. r_fuelspy_hud ..[[</td><td style=" color: green; border:1px solid yellow"> SPC </td><td> </td><td>]] .. brake_su .. [[<span style=" color:#00FFFF">&nbsp Su</span></td></tr>
                                        <tr height="25vh"><td style=" border: 1px solid slategray; font-size: 12px; text-align: left; vertical-align: top" rowspan="3" colspan="3">]] .. ECAM() .. [[</td><td style=" color: #00FFFF; border:1px solid yellow"> ORB </td><td style=" color: green"> Braking </td><td>]] .. brake_km .. [[<span style=" color:#00FFFF">&nbsp Km</span></td></tr>
                                        <tr height="25vh"><td style=" color: #00FFFF; border:1px solid yellow"> slot5 </td><td>]] .. rrThrust_hud .. [[<span style=" color:#00FFFF">&nbsp kN</span></td><td> </td></tr>
                                        <tr> <td></td> <td></td> <td style=" border:1px solid yellow" colspan="3"> </td></tr>
                                    </table>
                                </div></div>
                            ]]
                        end -- monitor_left_space()


                    --OPTION 4 (Orbit page)
                        function monitor_left_orbit()
                            final_speed_brk = (orbit_circular_speed)/1000*60*60
                            return [[
                                 <div class="monitor_left">
                                    <table class="window" style="border:1px solid yellow; text-align: left; color:yellow; font-size: 14px">
                                        <tr height="30vh"><td width="5"></td><th width="180vw" colspan="2" style=" align: center; vertical-align: top; font-size:16px; color: green">ORBIT</th><th width="180vw" colspan="2" style=" vertical-align: top; color: #00FFFF">]] .. planet_name .. [[&nbsp&nbsp<span style=" color: yellow">]].. math.floor(my_planet_alt/1000/200*100)/100 ..[[</span>&nbsp<span style=" color: #00FFFF">Su</span></th></tr>
                                        <tr height="30vh"><td width="5"></td><td style=" color: green">Ecc</td><td>]] .. orbit_ecc .. [[</td><td style=" color: green">T</td><td>]] .. orbit_period .. [[</td></tr>
                                        <tr height="30vh"><td width="5"></td><td style=" color: green">Pe Alt &nbsp<span style=" color: #00FFFF">mt</span></td><td>]] .. orbit_per_alt .. [[</td><td style=" color: green">Ap Alt &nbsp<span style=" color: #00FFFF">mt</span></td><td>]] .. orbit_apo_alt .. [[</td></tr>
                                        <tr height="30vh"><td width="5"></td><td style=" color: green">Pe Speed &nbsp<span style=" color: #00FFFF">m/s</span></td><td>]] .. orbit_per_speed .. [[</td><td style=" color: green">Ap Speed &nbsp<span style=" color: #00FFFF">m/s</span></td><td>]] .. orbit_apo_speed .. [[</td></tr>
                                        <tr height="30vh"><td width="5"></td><td style=" color: green">T to Pe</td><td>]] .. orbit_t_to_per .. [[</td><td style=" color: green">T to Ap</td><td>]] .. orbit_t_to_apo .. [[</td></tr>
                                    </table>
                                </div>

                                <div class="monitor_right" align="right">
                                    <table class="window" style="border:1px solid yellow; text-align: center; color:yellow; font-size: 30px">
                                        <tr height="150vh"><td width="360vw" style=" vertical-align: middle">]] .. f_orbit_svg() .. [[<td></tr>
                                        <tr><td style=" text-align: left; color:green; font-size: 14px">Target PE Altitude &nbsp<span style=" color:white">]] .. PeTargetAlt .. [[</span>&nbsp<span style=" color:#00FFFF">mt</span></td></tr>
                                    </table>
                                </div>

                                <div class="monitor_left"><div class="window center">
                                    <table style="border:1px solid yellow; text-align: center; vertical-align: top; color:yellow; font-size: 12px">
                                        <tr height="25vh"><td width="5vw" rowspan="5"> </td><td style=" color: green" colspan="3">Annunciator Lights</td><td width="5vw" rowspan="5"> </td><td style=" color: #00FFFF; border:1px solid yellow"> Load </td><th style=" border: 1px solid yellow; color: green" colspan="2" width="180vw"> Orbit &nbsp&nbsp<span style=" color: yellow">]].. math.floor(speed_hud/3.6) ..[[</span><span style=" color: #00FFFF">&nbsp m/s</span></tr>
                                        <tr height="25vh"><td width="40vw" style=" border: 1px solid slategray; color:]] .. ldg_st .. [[">LDG</td><td width="40vw" style=" border: 1px solid slategray; color:]] .. lights_st_hud .. [["> Œ </td><td width="40vw" style=" border: 1px solid slategray; color: ]] .. r_active_hud .. [[">ROCKET</td><td width="50vw" style=" color: #00FFFF; border:1px solid yellow"> AI </td><td style=" color: green">Brake in:</td><td style=" color: yellow">]] .. brake_km .. [[&nbsp<span style=" color: #00FFFF">Km</span></td></tr>
                                        <tr height="25vh"><td style=" border: 1px solid slategray">]] .. a_fuelspy_hud ..[[</td><td style=" border: 1px solid slategray">]] .. s_fuelspy_hud ..[[</td><td style=" border: 1px solid slategray">]] .. r_fuelspy_hud ..[[</td><td style=" color: #00FFFF; border:1px solid yellow"> SPC </td><td colspan="2" rowspan="3"  width="180vw" height=" 75vh" style=" vertical-align: middle">]] .. space_orientation_svg() .. [[</td></tr>
                                        <tr height="25vh"><td style=" border: 1px solid slategray; font-size: 12px; text-align: left; vertical-align: top" rowspan="3" colspan="3">]] .. ECAM() .. [[</td><td style=" color: green; border:1px solid yellow"> ORB </td></tr>
                                        <tr height="25vh"><td style=" color: #00FFFF; border:1px solid yellow"> slot5 </td></tr>
                                        <tr> <td></td> <td></td> <td style=" border:1px solid yellow" colspan="3"> </td></tr>
                                    </table>
                                </div></div>
                            ]]
                        end -- monitor_left_orbit()


                --HTML ASSEMBLER
                    function html_assemble()

                        air_data()

                        left_panel = monitor_left_loading()
                        right_panel = monitor_right()

                        hud = right_panel
                        hud = hud .. left_panel

                        system.setScreen(hud)

                        system.showScreen(1)

                    end -- function html_assemble()
                    html_assemble()



                --TIMER
                    unit.setTimer("loading_pg", 1)
        tick:
            args: [loading_pg]
            lua: |
                --FUEL WARNINGS CAUTIONS
                    atmo_fuel_percent() -- a_fuelspy_hud, a_fuelwarning_hud
                    space_fuel_percent() -- s_fuelspy_hud, s_fuelwarning_hud
                    if rocketfueltank_size ~= 0 then
                    rocket_fuel_percent() -- r_fuelspy_hud, r_fuelwarning_hud
                    end

                    a_fuel_minimum_time() -- a_t_h, a_t_m, a_t_s 
                    s_fuel_minimum_time() -- s_t_h, s_t_m, s_t_s
                    if rocketfueltank_size ~= 0 then
                    r_fuel_minimum_time() -- r_t_h, r_t_m, r_t_s
                    r_warning_light() -- r_active_hud
                    end	

                    avg_fuel_percentage() -- a_fuel_percent_avg_hud


                --LANDING GEAR
                    landing_gear() -- ldg_st


                --LIGHTS
                    f_lights_st() -- lights_st


                --CARGO
                    f_loading_data() -- cargo_m_t


                --GW, ZFW, DOW
                    gw_m = math.floor(core.getConstructMass()/1000*10)/10
                    zfw_m = gw_m - fuel_mass
                    dow_m = gw_m - fuel_mass - cargo_m_t


                --MTOW Percent
                    MTOW_p = math.floor(gw_m*1000/MTOW*100)


                --FUEL MASS
                    total_fuel_mass() -- fuel_mass


                --SCREEN ASSEMBLER
                    right_panel = monitor_right()
                    left_panel = monitor_left_loading()
                    hud = right_panel
                    hud = hud .. left_panel
                    system.setScreen(hud)
        tick:
            args: [atmo_pg]
            lua: |
                --FUEL WARNINGS CAUTIONS
                    atmo_fuel_percent() -- a_fuelspy_hud, a_fuelwarning_hud
                    space_fuel_percent() -- s_fuelspy_hud, s_fuelwarning_hud
                    if rocketfueltank_size ~= 0 then
                    rocket_fuel_percent() -- r_fuelspy_hud, r_fuelwarning_hud
                    end

                    a_fuel_minimum_time() -- a_t_h, a_t_m, a_t_s 
                    s_fuel_minimum_time() -- s_t_h, s_t_m, s_t_s
                    if rocketfueltank_size ~= 0 then
                    r_fuel_minimum_time() -- r_t_h, r_t_m, r_t_s
                    r_warning_light() -- r_active_hud
                    end

                    avg_fuel_percentage() -- a_fuel_percent_avg_hud


                --LANDING GEAR
                    landing_gear() -- ldg_st


                --LIGHTS
                    f_lights_st() -- lights_st


                --RADIO ALTIMITER
                    f_radioalt_hud()


                --ACCELERATION
                    acc_hud = math.floor(vec3(core.getWorldAcceleration()):len()/9.8*10)/10


                --SCREEN ASSEMBLER
                    left_panel = monitor_left_atmo()
                    hud = right_panel
                    hud = hud .. left_panel
                    system.setScreen(hud)
        tick:
            args: [orbit_pg]
            lua: |
                --FUEL WARNINGS CAUTIONS
                    atmo_fuel_percent() -- a_fuelspy_hud, a_fuelwarning_hud
                    space_fuel_percent() -- s_fuelspy_hud, s_fuelwarning_hud
                    if rocketfueltank_size ~= 0 then
                    rocket_fuel_percent() -- r_fuelspy_hud, r_fuelwarning_hud
                    end

                    a_fuel_minimum_time() -- a_t_h, a_t_m, a_t_s 
                    s_fuel_minimum_time() -- s_t_h, s_t_m, s_t_s
                    if rocketfueltank_size ~= 0 then
                    r_fuel_minimum_time() -- r_t_h, r_t_m, r_t_s
                    r_warning_light() -- r_active_hud
                    end

                    avg_fuel_percentage() -- a_fuel_percent_avg_hud


                --LANDING GEAR
                    landing_gear() -- ldg_st


                --LIGHTS
                    f_lights_st() -- lights_st


                --RETRO ROCKET
                    f_rrThrust_hud()


                --BRAKING DISTANCE
                    braking_distance()


                --ORBITAL DATA
                    orbital_data()


                --SPACE ORIENTATION
                    space_orientation()


                --SPACE DATA
                    databank_condition()


                --SCREEN ASSEMBLER
                    left_panel = monitor_left_orbit()
                    hud = right_panel
                    hud = hud .. left_panel
                    system.setScreen(hud)
        tick:
            args: [space_pg]
            lua: |
                --FUEL WARNINGS CAUTIONS
                    atmo_fuel_percent() -- a_fuelspy_hud, a_fuelwarning_hud
                    space_fuel_percent() -- s_fuelspy_hud, s_fuelwarning_hud
                    if rocketfueltank_size ~= 0 then
                    rocket_fuel_percent() -- r_fuelspy_hud, r_fuelwarning_hud
                    end

                    a_fuel_minimum_time() -- a_t_h, a_t_m, a_t_s 
                    s_fuel_minimum_time() -- s_t_h, s_t_m, s_t_s
                    if rocketfueltank_size ~= 0 then
                    r_fuel_minimum_time() -- r_t_h, r_t_m, r_t_s
                    r_warning_light() -- r_active_hud
                    end

                    avg_fuel_percentage() -- a_fuel_percent_avg_hud


                --LANDING GEAR
                    landing_gear() -- ldg_st


                --LIGHTS
                    f_lights_st() -- lights_st


                --RETRO ROCKET
                    f_rrThrust_hud()


                --ORBITAL DATA
                    orbital_data()


                --BRAKING DISTANCE
                    braking_distance()


                --AUTOBRAKE SETTING
                    if databank then
                        if databank.getFloatValue("navigator_autobrake") ~= nil then
                            autobrake_stops_at = databank.getFloatValue("navigator_autobrake")
                        else
                            autobrake_stops_at = 2.3
                        end
                            else
                        autobrake_stops_at = 2.3
                    end


                --SPACE ORIENTATION
                    space_orientation()


                --SPACE DATA
                    databank_condition()


                --SCREEN ASSEMBLER
                    left_panel = monitor_left_space()
                    hud = right_panel
                    hud = hud .. left_panel
                    system.setScreen(hud)
        tick:
            args: [autobrake]
            lua: |
                --AUTOBRAKE
                    autobrake_function()
        tick:
            args: [maintaning_orbit]
            lua: |
                --MAINTAINING ORBIT
                    maintaining_orbit()
        tick:
            args: [delay3sec]
            lua: |
                --3 SECONDS DELAY
                    if (autopilot_ecam_mode == [[Autopilot ON - Mode 2]]) then
                        orbiting_mode_delay()
                    elseif (autopilot_ecam_mode == [[Autopilot ON - Mode 3]]) then
                        destination_mode_delayed()
                    end
        tick:
            args: [countdown]
            lua: |
                --3 SECONDS COUNTDOWN
                    if (autopilot_ecam_mode == [[Autopilot ON - Mode 2]]) then
                        time_to_align = time_to_align - 1
                        adjusting_mode = [[Mainteining Orbit in: ]] .. time_to_align
                    elseif (autopilot_ecam_mode == [[Autopilot ON - Mode 3]]) then
                        time_to_align = time_to_align - 1
                        adjusting_mode = [[Align to DEST in: ]] .. time_to_align
                    end
        stop:
            lua: |
                _autoconf.hideCategoryPanels()
                if antigrav ~= nil then antigrav.hide() end
                if warpdrive ~= nil then warpdrive.hide() end
                if gyro ~= nil then gyro.hide() end
                core.hide()
                Nav.control.switchOffHeadlights()

                system.showScreen(0)
    system:
        start:
            lua: |
                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput = 0
        flush:
            lua: |
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu

                local pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                local autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(core.getConstructWorldOrientationUp())
                local constructForward = vec3(core.getConstructWorldOrientationForward())
                local constructRight = vec3(core.getConstructWorldOrientationRight())
                local constructVelocity = vec3(core.getWorldVelocity())
                local constructVelocityDir = vec3(core.getWorldVelocity()):normalize()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)

                -- Rotation
                local constructAngularVelocity = vec3(core.getWorldAngularVelocity())
                local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                + finalRollInput * rollSpeedFactor * constructForward
                                                + finalYawInput * yawSpeedFactor * constructUp

                -- In atmosphere?
                if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                    local autoRollRollThreshold = 1.0
                    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                        if (rollPID == nil) then
                            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        rollPID:inject(targetRollDeg - currentRollDeg)
                        local autoRollInput = rollPID:get()

                        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    end
                    local turnAssistRollThreshold = 20.0
                    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                        local rollVerticalRatio = 0
                        if rescaleRollDegAbs < 90 then
                            rollVerticalRatio = rescaleRollDegAbs / 90
                        elseif rescaleRollDegAbs < 180 then
                            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                        end

                        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio

                        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio

                        targetAngularVelocity = targetAngularVelocity
                                            + turnAssistPitchInput * constructRight
                                            + turnAssistYawInput * constructUp
                    end
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end

                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')

                --PROGRADE ALIGNER
                if auto_aligner == true then
                    auto_align()
                end
        update:
            lua: |
                Nav:update()

                --START HUD CODE
                local data_change = false


                --ALTITUDE
                if math.floor(core.getAltitude()) ~= altitude then
                    data_change = true
                    right_panel = monitor_right()
                end
                altitude = math.floor(core.getAltitude())

                --PITCH / ROLL
                if math.floor(unit.getPitch()*10)/10 ~= pitch_hud then
                    f_pitch_roll()
                    data_change = true
                    right_panel = monitor_right()
                end

                if math.floor(gyro.getRoll()*10)/10 ~= roll_hud then
                    f_pitch_roll()
                    data_change = true
                    right_panel = monitor_right()
                end

                f_pitch_roll()

                --SPEED
                if math.floor((vec3(core.getVelocity()):len())*3.6) ~= speed_hud then
                    data_change = true
                    right_panel = monitor_right()
                end

                speed_hud = math.floor((vec3(core.getVelocity()):len())*3.6)

                --THROTTLE
                if math.floor(unit.getThrottle()) ~= thr then
                    data_change = true
                    right_panel = monitor_right()
                end

                thr = math.floor(unit.getThrottle())

                --V/S
                local worldVelocity = vec3(core.getWorldVelocity())
                local gravity = vec3(core.getWorldGravity())
                if math.floor(worldVelocity:dot(-gravity:normalize())) ~= vs_hud then
                    data_change = true
                    right_panel = monitor_right()    
                end

                local worldVelocity = vec3(core.getWorldVelocity())
                local gravity = vec3(core.getWorldGravity())
                vs_hud = math.floor(worldVelocity:dot(-gravity:normalize()))


                if  data_change == true then
                    hud = right_panel
                    hud = hud .. left_panel
                    system.setScreen(hud)
                end
        actionStart:
            args: [option1]
            lua: |
                --LOADING page
                    unit.stopTimer("atmo_pg")
                    unit.stopTimer("space_pg")
                    unit.stopTimer("orbit_pg")

                    loading_pg = true
                    atmo_pg = false
                    orbit_pg = false
                    space_pg = false

                    left_panel = monitor_left_loading()

                    hud = right_panel
                        hud = hud .. left_panel
                        system.setScreen(hud)

                    unit.setTimer("loading_pg", 1)
        actionStart:
            args: [option2]
            lua: |
                --ATMO page
                    unit.stopTimer("loading_pg")
                    unit.stopTimer("space_pg")
                    unit.stopTimer("orbit_pg")

                    loading_pg = false
                    atmo_pg = true
                    orbit_pg = false
                    space_pg = false

                    left_panel = monitor_left_atmo()

                    hud = right_panel
                        hud = hud .. left_panel
                        system.setScreen(hud)

                    unit.setTimer("atmo_pg", 1/30)
        actionStart:
            args: [option3]
            lua: |
                --SPACE page
                    unit.stopTimer("loading_pg")
                    unit.stopTimer("atmo_pg")
                    unit.stopTimer("orbit_pg")

                    loading_pg = false
                    atmo_pg = false
                    orbit_pg = false
                    space_pg = true

                    left_panel = monitor_left_space()

                    hud = right_panel
                        hud = hud .. left_panel
                        system.setScreen(hud)

                    unit.setTimer("space_pg", 1/10)
        actionStart:
            args: [option4]
            lua: |
                --ORBIT page
                    unit.stopTimer("loading_pg")
                    unit.stopTimer("atmo_pg")
                    unit.stopTimer("space_pg")

                    loading_pg = false
                    atmo_pg = false
                    orbit_pg = true
                    space_pg = false

                    left_panel = monitor_left_orbit()

                    hud = right_panel
                        hud = hud .. left_panel
                        system.setScreen(hud)

                    unit.setTimer("orbit_pg", 1/10)
        actionStart:
            args: [option6]
            lua: |
                --SHIP ALIGNER
                    if (space_pg == true or orbit_pg == true) then
                        if auto_aligner == false then
                            auto_aligner = true
                            prograde_mode = true
                            autopilot_ecam_mode = [[Autopilot ON - Mode 1]]

                        elseif (auto_aligner == true and prograde_mode == true and orbit_maintainer == false) then
                            orbit_maintainer = true
                            autopilot_ecam_mode = [[Autopilot ON - Mode 2]]
                            unit.setTimer("delay3sec", 3)
                            time_to_align = 4
                            unit.setTimer("countdown", 1)
                            function orbiting_mode_delay()
                                unit.setTimer("maintaning_orbit", 1/30)
                                unit.stopTimer("delay3sec")
                                unit.stopTimer("countdown")
                            end -- function orbiting_mode_delay()

                        elseif (auto_aligner == true and prograde_mode == true and orbit_maintainer == true) then
                            unit.stopTimer("maintaning_orbit")
                            orbit_maintainer = false
                            adjusting_mode = [[ ]]
                            prograde_mode = false
                            autopilot_ecam_mode = [[Autopilot ON - Mode 3]]
                            unit.setTimer("delay3sec", 3)
                            time_to_align = 4
                            unit.setTimer("countdown", 1)
                            function destination_mode_delayed()
                                destination_mode = true
                                unit.stopTimer("delay3sec")
                                unit.stopTimer("countdown")
                                adjusting_mode = [[ ]]
                            end -- function destination_mode_delayed()

                        elseif (auto_aligner == true and (destination_mode == true or prograde_mode == false)) then
                            unit.stopTimer("delay3sec")
                            unit.stopTimer("countdown")
                            auto_aligner = false
                            destination_mode = false
                            align_active_mode = [[ ]]
                            autopilot_ecam_mode = [[ ]]
                            adjusting_mode = [[ ]]
                        end

                    elseif (atmo_pg == true) then
                        unit.stopTimer("delay3sec")
                        unit.stopTimer("countdown")
                        unit.stopTimer("maintaning_orbit")
                        auto_aligner = false
                        prograde_mode = false
                        destination_mode = false
                        align_active_mode = [[ ]]
                        adjusting_mode = [[ ]]
                        autopilot_ecam_mode = [[ ]]
                    end
        actionStart:
            args: [option7]
            lua: |
                --AUTOBRAKE
                    if (autobrake == true or brakeInput == 1)then
                        unit.stopTimer("autobrake")
                        brake_status = [[ ]]
                        brake_active = [[ ]]
                        autobrake_in = [[ Autobrake OFF ]]
                        autobrake_ecam_mode = [[ ]]
                        brakeInput = 0
                        autobrake = false
                    elseif autobrake == false then
                        unit.setTimer("autobrake", 1)
                        autobrake = true
                    end
        actionStart:
            args: [option8]
            lua: |
                --RADAR SHOW
                    if du_radar_widgets == false then
                        _autoconf.displayCategoryPanel(radar, radar_size, "Periscope", "periscope")
                        if radar_size>0 then
                                _autoconf.displayCategoryPanel(radar, radar_size, "Radar", "radar")
                        end
                        du_radar_widgets = true
                --RADAR HIDE
                    elseif du_radar_widgets == true then
                        _autoconf.hideCategoryPanels()
                        du_radar_widgets = false
                    end
        actionStart:
            args: [option9]
            lua: |
                --WIDGETS SHOW
                    if du_widgets == false then
                        unit.show()
                        if spacefueltank_size > 0 then
                            _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, "Space Fuel", "fuel_container")
                        end
                        core.show()
                        if atmofueltank_size > 0 then
                            _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, "Atmo Fuel", "fuel_container")
                        end
                        gyro.show()
                        if antigrav ~= nil then antigrav.show() end
                        if warpdrive ~= nil then warpdrive.show() end
                        du_widgets = true
                --WIDGETS HIDE
                    elseif du_widgets == true then
                        unit.hide()
                        core.hide()
                        gyro.hide()
                        if antigrav ~= nil then antigrav.hide() end
                        if warpdrive ~= nil then warpdrive.hide() end
                        _autoconf.hideCategoryPanels()
                        du_widgets = false
                        du_radar_widgets = false
                    end
        actionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end

        actionStart:
            args: [light]
            lua: |
                if Nav.control.isAnyHeadlightSwitchedOn() == 1 then
                    Nav.control.switchOffHeadlights()
                else
                    Nav.control.switchOnHeadlights()
                end

        actionStart:
            args: [forward]
            lua: pitchInput = pitchInput - 1
        actionStop:
            args: [forward]
            lua: pitchInput = pitchInput + 1
        actionStart:
            args: [backward]
            lua: pitchInput = pitchInput + 1
        actionStop:
            args: [backward]
            lua: pitchInput = pitchInput - 1
        actionStart:
            args: [left]
            lua: rollInput = rollInput - 1
        actionStop:
            args: [left]
            lua: rollInput = rollInput + 1
        actionStart:
            args: [right]
            lua: rollInput = rollInput + 1
        actionStop:
            args: [right]
            lua: rollInput = rollInput - 1

        actionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        actionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

        actionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        actionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

        actionStart:
            args: [up]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
        actionStop:
            args: [up]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
        actionStart:
            args: [down]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
        actionStop:
            args: [down]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)

        actionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

        actionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)


        actionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

        actionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

        actionStart:
            args: [yawright]
            lua: yawInput = yawInput - 1
        actionStop:
            args: [yawright]
            lua: yawInput = yawInput + 1
        actionStart:
            args: [yawleft]
            lua: yawInput = yawInput + 1
        actionStop:
            args: [yawleft]
            lua: yawInput = yawInput - 1
        actionStart:
            args: [brake]
            lua: |
                brakeInput = brakeInput + 1
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        actionStop:
            args: [brake]
            lua: brakeInput = brakeInput - 1

        actionLoop:
            args: [brake]
            lua: |
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        actionStart:
            args: [booster]
            lua: Nav:toggleBoosters()
        actionStart:
            args: [stopengines]
            lua: Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
        actionStart:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
        actionLoop:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
        actionStart:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
        actionLoop:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)

        actionStart:
            args: [antigravity]
            lua: if antigrav ~= nil then antigrav.toggle() end
        actionStart:
            args: [warp]
            lua: if warpdrive ~= nil then warpdrive.activateWarp() end