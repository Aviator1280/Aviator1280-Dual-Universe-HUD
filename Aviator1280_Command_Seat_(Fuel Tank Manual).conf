name: Aviator1280_Command_Seat_(Fuel_Tank_Manual)

slots:
 core:
  class: CoreUnit
 gyro:
  class: GyroUnit
 warpdrive:
  class: WarpDriveUnit
 atmofueltank:
  class: AtmoFuelContainer
  select: manual
 spacefueltank:
  class: SpaceFuelContainer
  select: manual
 rocketfueltank:
  class: RocketFuelContainer
  select: manual
 weapon:
  class: WeaponUnit
  select: manual
 radar:
  class: RadarPVPUnit
  select: manual
 container:
  class: ItemContainer
  select: manual
 databank:
  class: databank
 radio_alt:
  class: VerticalBooster
  select: manual
 radio_alt:
  class: Hovercraft
  select: manual
 radio_alt:
  class: TelemeterUnit
  select: manual
 antigrav:
  class: AntiGravityGeneratorUnit
handlers:
 unit:
  start:
   lua: |
    --[[

    Author: Aviator1280

    --]]

    --DU CODE
     pitchInput = 0
     rollInput = 0
     yawInput = 0
     brakeInput = 0

     Nav = Navigator.new(system, core, unit)
     Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {100, 500, 1000, 5000})
     Nav.axisCommandManager:setTargetGroundAltitude(0)

     -- element widgets
     -- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.
     _autoconf.displayCategoryPanel(weapon, weapon_size, "Weapons", "weapon", true)
     core.show()
     _autoconf.displayCategoryPanel(radar, radar_size, "Periscope", "periscope")
     placeRadar = true
     if atmofueltank_size > 0 then
      _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, "Atmo Fuel", "fuel_container")
      if placeRadar then
       _autoconf.displayCategoryPanel(radar, radar_size, "Radar", "radar")
       placeRadar = false
      end
     end
     if spacefueltank_size > 0 then
      _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, "Space Fuel", "fuel_container")
      if placeRadar then
       _autoconf.displayCategoryPanel(radar, radar_size, "Radar", "radar")
       placeRadar = false
      end
     end
     _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, "Rocket Fuel", "fuel_container")
     if placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels
      _autoconf.displayCategoryPanel(radar, radar_size, "Radar", "radar")
      placeRadar = false
     end
     if antigrav ~= nil then antigrav.show() end
     if gyro ~= nil then gyro.show() end

     throttleStep = 0.25 --export: When pressing the SpeedUp/SpeedDown buttons, this step will be using to increment/decrement the throttle<br>Valid values: From 0.01 to 1
     throttleStep = utils.clamp(throttleStep, 0.01, 1)

     -- freeze the player in he is remote controlling the construct
     if Nav.control.isRemoteControlled() == 1 then
      system.freeze(1)
     end

     -- landing gear
     -- make sure every gears are synchonized with the first
     gearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean
     if gearExtended then
      Nav.control.extendLandingGears()
     else
      Nav.control.retractLandingGears()
     end

    --START HUD CODE
     loading_pg = true

    --LUA PARAMETERS
     Helper = true --export: Show/Hide Helper when entering the seat/cockpit
     Parking_Brake_Set = true --export: Parking Brake ON/OFF when entering the seat/cockpit
     Autobrake_Stop_Distance = 2.3 --export: Distance at which the Ship Will stop (!WARNING! consider Planets/Moons radius)
     Widgets_ON_OFF = false --export: DU Widgets ON/OFF when entering the seat/cockpit
     if Widgets_ON_OFF == false then
      unit.hide()
      core.hide()
      if gyro ~= nil then gyro.hide() end
      if antigrav ~= nil then antigrav.hide() end
      if warpdrive ~= nil then warpdrive.hide() end
      _autoconf.hideCategoryPanels()
      du_widgets = false
      du_radar_widgets = false
     else
      du_widgets = true
      du_radar_widgets = true
     end
     Maximum_Take_Off_Weight = 730000 --export: In Kg
     if databank then
      if databank.getFloatValue("navigator_pe_target_altitude") ~= nil then
       PeTargetAlt = databank.getFloatValue("navigator_pe_target_altitude")
      else
       PeTargetAlt = 20000
      end
     else
      Periapsis_Target_Altitude= 20000 --export: In meters
      PeTargetAlt = Periapsis_Target_Altitude
     end
     Planet_Scale_SPC_Mode = 80000 --export: Planets/Moons Scale
     DMG_REP_Scale = 3 --export: Change Size Of Layout TOP And SIDE VIEW
     DMG_REP_TOP_VIEW_Up_Down = -20 --export: (Higer value for Up) (Lower for Down)
     DMG_REP_TOP_VIEW_LH_RH = 30 --export: (Higher value for Right) (Lower for Left)
     DMG_REP_SIDE_VIEW_Up_Down = 40 --export: (Higher value for Down) (Lower for Up)
     DMG_REP_SIDE_VIEW_LH_RH = 100 --export: (Higer value for Right) (Lower for Left)

    --TOOLS
     --STRING CONVERTER TO VEC3
      function vec3FromStr(vStr)
       local v3 = {};
       for num in string.gmatch(vStr, "[-%d%.]+") do
        local vN = string.gsub(num, "%+", "")
        table.insert(v3, tonumber(vN))
       end
       return vec3(table.unpack(v3))
      end

     --AUTHOR JAYLE BREAK ( https://gitlab.com/JayleBreak/dualuniverse/-/tree/master/DUflightfiles/autoconf/custom )
      --ATLAS
       function atlas()
        return {
        [0] = {
          [1]={
         GM=6930729684,
         bodyId=1,
         center={x=17465536.000,y=22665536.000,z=-34464.000},
         name='Madis',
         planetarySystemId=0,
         radius=44300
          },
          [2]={
         GM=157470826617,
         bodyId=2,
         center={x=-8.000,y=-8.000,z=-126303.000},
         name='Alioth',
         planetarySystemId=0,
         radius=126068
          },
          [3]={
         GM=11776905000,
         bodyId=3,
         center={x=29165536.000,y=10865536.000,z=65536.000},
         name='Thades',
         planetarySystemId=0,
         radius=49000
          },
          [4]={
         GM=14893847582,
         bodyId=4,
         center={x=-13234464.000,y=55765536.000,z=465536.000},
         name='Talemai',
         planetarySystemId=0,
         radius=57450
          },
          [5]={
         GM=16951680000,
         bodyId=5,
         center={x=-43534464.000,y=22565536.000,z=-48934464.000},
         name='Feli',
         planetarySystemId=0,
         radius=60000
          },
          [6]={
         GM=10502547741,
         bodyId=6,
         center={x=52765536.000,y=27165538.000,z=52065535.000},
         name='Sicari',
         planetarySystemId=0,
         radius=51100
          },
          [7]={
         GM=13033380591,
         bodyId=7,
         center={x=58665538.000,y=29665535.000,z=58165535.000},
         name='Sinnen',
         planetarySystemId=0,
         radius=54950
          },
          [8]={
         GM=18477723600,
         bodyId=8,
         center={x=80865538.000,y=54665536.000,z=-934463.940},
         name='Teoma',
         planetarySystemId=0,
         radius=62000
          },
          [9]={
         GM=18606274330,
         bodyId=9,
         center={x=-94134462.000,y=12765534.000,z=-3634464.000},
         name='Jago',
         planetarySystemId=0,
         radius=61590
          },
          [10]={
         GM=78480000,
         bodyId=10,
         center={x=17448118.224,y=22966846.286,z=143078.820},
         name='Madis Moon 1',
         planetarySystemId=0,
         radius=10000
          },
          [11]={
         GM=237402000,
         bodyId=11,
         center={x=17194626.000,y=22243633.880,z=-214962.810},
         name='Madis Moon 2',
         planetarySystemId=0,
         radius=11000
          },
          [12]={
         GM=265046609,
         bodyId=12,
         center={x=17520614.000,y=22184730.000,z=-309989.990},
         name='Madis Moon 3',
         planetarySystemId=0,
         radius=15005
          },
          [21]={
         GM=2118960000,
         bodyId=21,
         center={x=457933.000,y=-1509011.000,z=115524.000},
         name='Alioth Moon 1',
         planetarySystemId=0,
         radius=30000
          },
          [22]={
         GM=2165833514,
         bodyId=22,
         center={x=-1692694.000,y=729681.000,z=-411464.000},
         name='Alioth Moon 4',
         planetarySystemId=0,
         radius=30330
          },
          [26]={
         GM=68234043600,
         bodyId=26,
         center={x=-1404835.000,y=562655.000,z=-285074.000},
         name='Sanctuary',
         planetarySystemId=0,
         radius=83400
          },
          [30]={
         GM=211564034,
         bodyId=30,
         center={x=29214402.000,y=10907080.695,z=433858.200},
         name='Thades Moon 1',
         planetarySystemId=0,
         radius=14002
          },
          [31]={
         GM=264870000,
         bodyId=31,
         center={x=29404193.000,y=10432768.000,z=19554.131},
         name='Thades Moon 2',
         planetarySystemId=0,
         radius=15000
          },
          [40]={
         GM=141264000,
         bodyId=40,
         center={x=-13503090.000,y=55594325.000,z=769838.640},
         name='Talemai Moon 2',
         planetarySystemId=0,
         radius=12000
          },
          [41]={
         GM=106830900,
         bodyId=41,
         center={x=-12800515.000,y=55700259.000,z=325207.840},
         name='Talemai Moon 3',
         planetarySystemId=0,
         radius=11000
          },
          [42]={
         GM=264870000,
         bodyId=42,
         center={x=-13058408.000,y=55781856.000,z=740177.760},
         name='Talemai Moon 1',
         planetarySystemId=0,
         radius=15000
          },
          [50]={
         GM=499917600,
         bodyId=50,
         center={x=-43902841.780,y=22261034.700,z=-48862386.000},
         name='Feli Moon 1',
         planetarySystemId=0,
         radius=14000
          },
          [70]={
         GM=396912600,
         bodyId=70,
         center={x=58969616.000,y=29797945.000,z=57969449.000},
         name='Sinnen Moon 1',
         planetarySystemId=0,
         radius=17000
          },
          [100]={
         GM=13975172474,
         bodyId=100,
         center={x=98865536.000,y=-13534464.000,z=-934461.990},
         name='Lacobus',
         planetarySystemId=0,
         radius=55650
          },
          [101]={
         GM=264870000,
         bodyId=101,
         center={x=98905288.170,y=-13950921.100,z=-647589.530},
         name='Lacobus Moon 3',
         planetarySystemId=0,
         radius=15000
          },
          [102]={
         GM=444981600,
         bodyId=102,
         center={x=99180968.000,y=-13783862.000,z=-926156.400},
         name='Lacobus Moon 1',
         planetarySystemId=0,
         radius=18000
          },
          [103]={
         GM=211503600,
         bodyId=103,
         center={x=99250052.000,y=-13629215.000,z=-1059341.400},
         name='Lacobus Moon 2',
         planetarySystemId=0,
         radius=14000
          },
          [110]={
         GM=9204742375,
         bodyId=110,
         center={x=14165536.000,y=-85634465.000,z=-934464.300},
         name='Symeon',
         planetarySystemId=0,
         radius=49050
          },
          [120]={
         GM=7135606629,
         bodyId=120,
         center={x=2865536.700,y=-99034464.000,z=-934462.020},
         name='Ion',
         planetarySystemId=0,
         radius=44950
          },
          [121]={
         GM=106830900,
         bodyId=121,
         center={x=2472916.800,y=-99133747.000,z=-1133582.800},
         name='Ion Moon 1',
         planetarySystemId=0,
         radius=11000
          },
          [122]={
         GM=176580000,
         bodyId=122,
         center={x=2995424.500,y=-99275010.000,z=-1378480.700},
         name='Ion Moon 2',
         planetarySystemId=0,
         radius=15000
          }  
         }
        }
       end -- function atlas()

      --PLANETREF
       function planetref()
        local function isNumber(n)  return type(n)     == 'number' end
        local function isSNumber(n) return type(tonumber(n)) == 'number' end
        local function isTable(t)   return type(t)     == 'table'  end
        local function isString(s)  return type(s)     == 'string' end
        local function isVector(v)  return isTable(v) and isNumber(v.x and v.y and v.z) end

        local function isMapPosition(m) return isTable(m) and isNumber(m.latitude  and
                          m.longitude and
                          m.altitude  and
                          m.bodyId and
                          m.systemId) end

        local deg2rad = math.pi/180
        local rad2deg = 180/math.pi
        local epsilon = 1e-10
        local num  = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'
        local posPattern = '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' ..
               num ..  ',' .. num .. '}'

        local utils  = require('cpml.utils')
        local vec3   = require('cpml.vec3')
        local clamp  = utils.clamp

        local function float_eq(a,b)
         if a == 0 then return math.abs(b) < 1e-09 end
         if b == 0 then return math.abs(a) < 1e-09 end
         return math.abs(a - b) < math.max(math.abs(a),math.abs(b))*epsilon
        end

        local function formatNumber(n)
         local result = string.gsub(
             string.reverse(string.format('%.4f',n)),
             '^0*%.?','')
         return result == '' and '0' or string.reverse(result)
        end

        local function formatValue(obj)
         if isVector(obj) then
          return string.format('{x=%.3f,y=%.3f,z=%.3f}', obj.x, obj.y, obj.z)
         end

         if isTable(obj) and not getmetatable(obj) then
          local list = {}
          local nxt  = next(obj)

          if type(nxt) == 'nil' or nxt == 1 then
           list = obj
          else
           for k,v in pairs(obj) do
            local value = formatValue(v)
            if type(k) == 'number' then
             table.insert(list, string.format('[%s]=%s', k, value))
            else
             table.insert(list, string.format('%s=%s',   k, value))
            end
           end
          end
          return string.format('{%s}', table.concat(list, ','))
         end

         if isString(obj) then
          return string.format("'%s'", obj:gsub("'",[[\']]))
         end
         return tostring(obj)
        end

        local BodyParameters = {}
        BodyParameters.__index = BodyParameters
        BodyParameters.__tostring =
         function(obj, indent)
          local sep = indent or ''
          local keys = {}
          for k in pairs(obj) do table.insert(keys, k) end
          table.sort(keys)
          local list = {}
          for _, k in ipairs(keys) do
           local value = formatValue(obj[k])
           if type(k) == 'number' then
            table.insert(list, string.format('[%s]=%s', k, value))
           else
            table.insert(list, string.format('%s=%s', k, value))
           end
          end
          if indent then
           return string.format('%s%s',
                 indent,
                 table.concat(list, ',\n' .. indent))
          end
          return string.format('{%s}', table.concat(list, ','))
         end
        BodyParameters.__eq = function(lhs, rhs)
          return lhs.planetarySystemId == rhs.planetarySystemId and
              lhs.bodyId   == rhs.bodyId   and
              float_eq(lhs.radius, rhs.radius)      and
              float_eq(lhs.center.x, rhs.center.x)     and
              float_eq(lhs.center.y, rhs.center.y)     and
              float_eq(lhs.center.z, rhs.center.z)     and
              float_eq(lhs.GM, rhs.GM)
         end

        local function mkBodyParameters(systemId, bodyId, radius, worldCoordinates, GM)

         assert(isSNumber(systemId),
             'Argument 1 (planetarySystemId) must be a number:' .. type(systemId))
         assert(isSNumber(bodyId),
             'Argument 2 (bodyId) must be a number:' .. type(bodyId))
         assert(isSNumber(radius),
             'Argument 3 (radius) must be a number:' .. type(radius))
         assert(isTable(worldCoordinates),
             'Argument 4 (worldCoordinates) must be a array or vec3.' ..
             type(worldCoordinates))
         assert(isSNumber(GM),
             'Argument 5 (GM) must be a number:' .. type(GM))
         return setmetatable({planetarySystemId = tonumber(systemId),
               bodyId   = tonumber(bodyId),
               radius   = tonumber(radius),
               center   = vec3(worldCoordinates),
               GM    = tonumber(GM) }, BodyParameters)
        end

        local MapPosition = {}
        MapPosition.__index = MapPosition
        MapPosition.__tostring = function(p)
          return string.format('::pos{%d,%d,%s,%s,%s}',
                p.systemId,
                p.bodyId,
                formatNumber(p.latitude*rad2deg),
                formatNumber(p.longitude*rad2deg),
                formatNumber(p.altitude))
         end
        MapPosition.__eq    = function(lhs, rhs)
          return lhs.bodyId   == rhs.bodyId     and
              lhs.systemId == rhs.systemId   and
              float_eq(lhs.latitude,   rhs.latitude)  and
              float_eq(lhs.altitude,   rhs.altitude)  and
              (float_eq(lhs.longitude, rhs.longitude) or
            float_eq(lhs.latitude, math.pi/2)   or
            float_eq(lhs.latitude, -math.pi/2))
         end

        local function mkMapPosition(overload, bodyId, latitude, longitude, altitude)
         local systemId = overload -- Id or '::pos{...}' string

         if isString(overload) and not longitude and not altitude and
                 not bodyId and not latitude then
          systemId, bodyId, latitude, longitude, altitude =
                   string.match(overload, posPattern)
          assert(systemId, 'Argument 1 (position string) is malformed.')
         else
          assert(isSNumber(systemId),
              'Argument 1 (systemId) must be a number:' .. type(systemId))
          assert(isSNumber(bodyId),
              'Argument 2 (bodyId) must be a number:' .. type(bodyId))
          assert(isSNumber(latitude),
              'Argument 3 (latitude) must be in degrees:' .. type(latitude))
          assert(isSNumber(longitude),
              'Argument 4 (longitude) must be in degrees:' .. type(longitude))
          assert(isSNumber(altitude),
              'Argument 5 (altitude) must be in meters:' .. type(altitude))
         end
         systemId  = tonumber(systemId)
         bodyId = tonumber(bodyId)
         latitude  = tonumber(latitude)
         longitude = tonumber(longitude)
         altitude  = tonumber(altitude)

         if bodyId == 0 then -- this is a hack to represent points in space
          return setmetatable({latitude  = latitude,
                longitude = longitude,
                altitude  = altitude,
                bodyId = bodyId,
                systemId  = systemId}, MapPosition)
         end
         return setmetatable({latitude  = deg2rad*clamp(latitude, -90, 90),
               longitude = deg2rad*(longitude % 360),
               altitude  = altitude,
               bodyId = bodyId,
               systemId  = systemId}, MapPosition)
        end

        local PlanetarySystem = {}
        PlanetarySystem.__index = PlanetarySystem

        PlanetarySystem.__tostring =
         function (obj, indent)
          local sep = indent and (indent .. '  ' )
          local bdylist = {}
          local keys = {}
          for k in pairs(obj) do table.insert(keys, k) end
          table.sort(keys)
          for _, bi in ipairs(keys) do
           bdy = obj[bi]
           local bdys = BodyParameters.__tostring(bdy, sep)
           if indent then
            table.insert(bdylist,
                string.format('[%s]={\n%s\n%s}',
                     bi, bdys, indent))
           else
            table.insert(bdylist, string.format('  [%s]=%s', bi, bdys))
           end
          end
          if indent then
           return string.format('\n%s%s%s',
                 indent,
                 table.concat(bdylist, ',\n' .. indent),
                 indent)
          end
          return string.format('{\n%s\n}', table.concat(bdylist, ',\n'))
         end

        local function mkPlanetarySystem(referenceTable)
         local atlas = {}
         local pid
         for _, v in pairs(referenceTable) do
          local id = v.planetarySystemId

          if type(id) ~= 'number' then
           error('Invalid planetary system ID: ' .. tostring(id))
          elseif pid and id ~= pid then
           error('Mismatch planetary system IDs: ' .. id .. ' and '
              .. pid)
          end
          local bid = v.bodyId
          if type(bid) ~= 'number' then
           error('Invalid body ID: ' .. tostring(bid))
          elseif atlas[bid] then
           error('Duplicate body ID: ' .. tostring(bid))
          end
          setmetatable(v.center, getmetatable(vec3.unit_x))
          atlas[bid] = setmetatable(v, BodyParameters)
          pid = id
         end
         return setmetatable(atlas, PlanetarySystem)
        end

        PlanetaryReference = {}

        local function mkPlanetaryReference(referenceTable)
         return setmetatable({ galaxyAtlas = referenceTable or {} },
                PlanetaryReference)
        end

        PlanetaryReference.__index  =
         function(t,i)
          if type(i) == 'number' then
           local system = t.galaxyAtlas[i]
           return mkPlanetarySystem(system)
          end
          return rawget(PlanetaryReference, i)
         end
        PlanetaryReference.__pairs  =
         function(obj)
          return  function(t, k)
             local nk, nv = next(t, k)
             return nk, nv and mkPlanetarySystem(nv)
            end, obj.galaxyAtlas, nil
         end
        PlanetaryReference.__tostring  =
         function (obj)
          local pslist = {}
          for _,ps in pairs(obj or {}) do
           local psi = ps:getPlanetarySystemId()
           local pss = PlanetarySystem.__tostring(ps, ' ')
           table.insert(pslist,
               string.format('  [%s]={%s\n  }', psi, pss))
          end
          return string.format('{\n%s\n}\n', table.concat(pslist,',\n'))
         end

        PlanetaryReference.BodyParameters = mkBodyParameters

        PlanetaryReference.MapPosition = mkMapPosition

        PlanetaryReference.PlanetarySystem = mkPlanetarySystem

        function PlanetaryReference.createBodyParameters(planetarySystemId,
                     bodyId,
                     surfaceArea,
                     aPosition,
                     verticalAtPosition,
                     altitudeAtPosition,
                     gravityAtPosition)
         assert(isSNumber(planetarySystemId),
             'Argument 1 (planetarySystemId) must be a number:' ..
             type(planetarySystemId))
         assert(isSNumber(bodyId),
             'Argument 2 (bodyId) must be a number:' .. type(bodyId))
         assert(isSNumber(surfaceArea),
             'Argument 3 (surfaceArea) must be a number:' .. type(surfaceArea))
         assert(isTable(aPosition),
             'Argument 4 (aPosition) must be an array or vec3:' ..
             type(aPosition))
         assert(isTable(verticalAtPosition),
             'Argument 5 (verticalAtPosition) must be an array or vec3:' ..
             type(verticalAtPosition))
         assert(isSNumber(altitudeAtPosition),
             'Argument 6 (altitude) must be in meters:' ..
             type(altitudeAtPosition))
         assert(isSNumber(gravityAtPosition),
             'Argument 7 (gravityAtPosition) must be number:' ..
             type(gravityAtPosition))
         local radius   = math.sqrt(surfaceArea/4/math.pi)
         local distance = radius + altitudeAtPosition
         local center   = vec3(aPosition) + distance*vec3(verticalAtPosition)
         local GM    = gravityAtPosition * distance * distance
         return mkBodyParameters(planetarySystemId, bodyId, radius, center, GM)
        end

        PlanetaryReference.isMapPosition  = isMapPosition

        function PlanetaryReference:getPlanetarySystem(overload)
         if self.galaxyAtlas then
          local planetarySystemId = overload

          if isMapPosition(overload) then
           planetarySystemId = overload.systemId
          end

          if type(planetarySystemId) == 'number' then
           local system = self.galaxyAtlas[i]
           if system then
            if getmetatable(nv) ~= PlanetarySystem then
             system = mkPlanetarySystem(system)
            end
            return system
           end
          end
         end
         return nil
        end

        function PlanetarySystem:castIntersections(origin,
                     direction,
                     sizeCalculator,
                     bodyIds)
         local sizeCalculator = sizeCalculator or 
               function (body) return 1.05*body.radius end
         local candidates = {}

         if bodyIds then
          for _,i in ipairs(bodyIds) do candidates[i] = self[i] end
         else
          bodyIds = {}
          for k,body in pairs(self) do
           table.insert(bodyIds, k)
           candidates[k] = body
          end
         end
         local function compare(b1,b2)
          local v1 = candidates[b1].center - origin
          local v2 = candidates[b2].center - origin
          return v1:len() < v2:len()
         end
         table.sort(bodyIds, compare)
         local dir = direction:normalize()

         for i, id in ipairs(bodyIds) do
          local body   = candidates[id]
          local c_oV3  = body.center - origin
          local radius = sizeCalculator(body)
          local dot = c_oV3:dot(dir)
          local desc   = dot^2 - (c_oV3:len2() - radius^2)

          if desc >= 0 then
           local root  = math.sqrt(desc)
           local farSide  = dot + root
           local nearSide = dot - root
           if nearSide > 0 then
            return body, farSide, nearSide
           elseif farSide > 0 then
            return body, farSide, nil
           end
          end
         end
         return nil, nil, nil
        end

        function PlanetarySystem:closestBody(coordinates)
         assert(type(coordinates) == 'table', 'Invalid coordinates.')
         local minDistance2, body
         local coord = vec3(coordinates)

         for _,params in pairs(self) do
          local distance2 = (params.center - coord):len2()
          if not body or distance2 < minDistance2 then
           body   = params
           minDistance2 = distance2
          end
         end
         return body
        end

        function PlanetarySystem:convertToBodyIdAndWorldCoordinates(overload)
         local mapPosition = overload
         if isString(overload) then
          mapPosition = mkMapPosition(overload)
         end

         if mapPosition.bodyId == 0 then
          return 0, vec3(mapPosition.latitude,
                mapPosition.longitude,
                mapPosition.altitude)
         end
         local params = self:getBodyParameters(mapPosition)

         if params then
          return mapPosition.bodyId,
              params:convertToWorldCoordinates(mapPosition)
         end
        end

        function PlanetarySystem:getBodyParameters(overload)
         local bodyId = overload

         if isMapPosition(overload) then
          bodyId = overload.bodyId
         end
         assert(isSNumber(bodyId),
              'Argument 1 (bodyId) must be a number:' .. type(bodyId))

         return self[bodyId]
        end

        function PlanetarySystem:getPlanetarySystemId()
         local k, v = next(self)
         return v and v.planetarySystemId
        end

        function BodyParameters:convertToMapPosition(worldCoordinates)
         assert(isTable(worldCoordinates),
             'Argument 1 (worldCoordinates) must be an array or vec3:' ..
             type(worldCoordinates))
         local worldVec  = vec3(worldCoordinates) 

         if self.bodyId == 0 then
          return setmetatable({latitude  = worldVec.x,
                longitude = worldVec.y,
                altitude  = worldVec.z,
                bodyId = 0,
                systemId  = self.planetarySystemId}, MapPosition)
         end
         local coords = worldVec - self.center
         local distance  = coords:len()
         local altitude  = distance - self.radius
         local latitude  = 0
         local longitude = 0

         if not float_eq(distance, 0) then
          local phi = math.atan(coords.y, coords.x)
          longitude = phi >= 0 and phi or (2*math.pi + phi)
          latitude  = math.pi/2 - math.acos(coords.z/distance)
         end
         return setmetatable({latitude  = latitude,
               longitude = longitude,
               altitude  = altitude,
               bodyId = self.bodyId,
               systemId  = self.planetarySystemId}, MapPosition)
        end

        function BodyParameters:convertToWorldCoordinates(overload)
         local mapPosition = isString(overload) and
                     mkMapPosition(overload) or overload
         if mapPosition.bodyId == 0 then -- support deep space map position
          return vec3(mapPosition.latitude,
             mapPosition.longitude,
             mapPosition.altitude)
         end
         assert(isMapPosition(mapPosition),
             'Argument 1 (mapPosition) is not an instance of "MapPosition".')
         assert(mapPosition.systemId == self.planetarySystemId,
             'Argument 1 (mapPosition) has a different planetary system ID.')
         assert(mapPosition.bodyId == self.bodyId,
             'Argument 1 (mapPosition) has a different planetary body ID.')
         local xproj = math.cos(mapPosition.latitude)
         return self.center + (self.radius + mapPosition.altitude) *
             vec3(xproj*math.cos(mapPosition.longitude),
            xproj*math.sin(mapPosition.longitude),
            math.sin(mapPosition.latitude))
        end

        function BodyParameters:getAltitude(worldCoordinates)
         return (vec3(worldCoordinates) - self.center):len() - self.radius
        end

        function BodyParameters:getDistance(worldCoordinates)
         return (vec3(worldCoordinates) - self.center):len()
        end

        function BodyParameters:getGravity(worldCoordinates)
         local radial = self.center - vec3(worldCoordinates) -- directed towards body
         local len2   = radial:len2()
         return (self.GM/len2) * radial/math.sqrt(len2)
        end

        return setmetatable(PlanetaryReference,
             { __call = function(_,...)
                 return mkPlanetaryReference(...)
                  end })
       end

      --KEPLER
       function kepler()
        local vec3    = require('cpml.vec3')
        local PlanetRef  = planetref()

        local function isString(s) return type(s)   == 'string' end
        local function isTable(t)  return type(t)   == 'table'  end

        local function float_eq(a,b)
         if a == 0 then return math.abs(b) < 1e-09 end
         if b == 0 then return math.abs(a) < 1e-09 end
         return math.abs(a - b) < math.max(math.abs(a),math.abs(b))*epsilon
        end

        Kepler = {}
        Kepler.__index = Kepler

        function Kepler:escapeAndOrbitalSpeed(altitude)
         assert(self.body)
         local distance = altitude + self.body.radius

         if not float_eq(distance, 0) then
          local orbit = math.sqrt(self.body.GM/distance)
          return math.sqrt(2)*orbit, orbit
         end
         return nil, nil
        end

        function Kepler:orbitalParameters(overload, velocity)
         assert(self.body)
         assert(isTable(overload) or isString(overload))
         assert(isTable(velocity))
         local pos = (isString(overload) or PlanetRef.isMapPosition(overload)) and
               self.body:convertToWorldCoordinates(overload) or
            vec3(overload)
         local v   = vec3(velocity)
         local r   = pos - self.body.center
         local v2  = v:len2()
         local d   = r:len()
         local mu  = self.body.GM
         local e   = ((v2 - mu/d)*r - r:dot(v)*v)/mu
         local a   = mu/(2*mu/d - v2)

         local ecc = e:len()
         local dir = e:normalize()
         local pd  = a*(1-ecc)
         local ad  = a*(1+ecc)
         local per = pd*dir + self.body.center
         local apo = ecc <= 1 and -ad*dir + self.body.center or nil
         local trm = math.sqrt(a*mu*(1-ecc*ecc))
         local Period = apo and 2*math.pi*math.sqrt(a^3/mu)
         local trueAnomaly = math.acos((e:dot(r))/(ecc*d))
         if r:dot(v) < 0 then
          trueAnomaly = -(trueAnomaly - 2*math.pi)
         end
         local EccentricAnomaly = math.acos((math.cos(trueAnomaly) + ecc)/(1 + ecc * math.cos(trueAnomaly)))
         local timeTau = EccentricAnomaly
         if timeTau < 0 then
          timeTau = timeTau + 2*math.pi
         end
         local MeanAnomaly = timeTau - ecc * math.sin(timeTau)
         local TimeSincePeriapsis = 0
         local TimeToPeriapsis = 0
         local TimeToApoapsis = 0
         if Period ~= nil then
          TimeSincePeriapsis = MeanAnomaly/(2*math.pi/Period)
          TimeToPeriapsis = Period - TimeSincePeriapsis
          TimeToApoapsis = TimeToPeriapsis + Period/2
          if trueAnomaly - math.pi > 0 then
           TimeToPeriapsis = TimeSincePeriapsis
           TimeToApoapsis = TimeToPeriapsis + Period/2
          end
          if TimeToApoapsis > Period then
          TimeToApoapsis = TimeToApoapsis - Period
          end
         end

         return { periapsis    = { position     = per,
                 speed     = trm/pd,
                 circularOrbitSpeed = math.sqrt(mu/pd),
                 altitude     = pd - self.body.radius},
            apoapsis  = apo and
                  { position     = apo,
                 speed     = trm/ad,
                 circularOrbitSpeed = math.sqrt(mu/ad),
                 altitude     = ad - self.body.radius},
            currentVelocity = v,
            currentPosition = pos,
            eccentricity = ecc,
            period    = apo and 2*math.pi*math.sqrt(a^3/mu),
            eccentricAnomaly = EccentricAnomaly,
            meanAnomaly = MeanAnomaly,
            timeToPeriapsis = TimeToPeriapsis,
            timeToApoapsis = TimeToApoapsis
             }
        end

        local function new(bodyParameters)
         local params = PlanetRef.BodyParameters(bodyParameters.planetarySystemId,
                   bodyParameters.bodyId,
                   bodyParameters.radius,
                   bodyParameters.center,
                   bodyParameters.GM)
         return setmetatable({body = params}, Kepler)
        end

        return setmetatable(Kepler, { __call = function(_,...) return new(...) end })
       end

     --AUTHOR CATHARIUS ( https://github.com/Catharius/DU-MINIMALIST-HUD )
      --DAMAGE REPORT MODULE
       -- LUA PARAMETERS
        DAMAGE_size_ratio = DMG_REP_Scale
        DAMAGE_rotate_layout_top = -90
        DAMAGE_rotate_x_top = 90
        DAMAGE_rotate_y_top = 30
        DAMAGE_translate_x_top = DMG_REP_TOP_VIEW_Up_Down
        DAMAGE_translate_y_top = DMG_REP_TOP_VIEW_LH_RH
        DAMAGE_rotate_layout_side = 0
        DAMAGE_rotate_x_side = 0
        DAMAGE_rotate_y_side = 0
        DAMAGE_translate_x_side = DMG_REP_SIDE_VIEW_LH_RH
        DAMAGE_translate_y_side = DMG_REP_SIDE_VIEW_Up_Down

       -- General Functions
        function round(num, numDecimalPlaces)
         return tonumber(string.format("%." .. (numDecimalPlaces or 0) .. "f", num))
        end

        function getElemCategory(elemtype)
         elem_category="UNKNOWN"
         if elemtype ~= nil then
          local critical_part_list = {"DYNAMIC CORE","RESURRECTION NODE","RADAR"}
          local avionics_part_list = {"ENGINE","FUEL-TANK","ADJUSTOR","VERTICAL BOOSTER","RETRO-ROCKET BRAKE","WING","ATMOSPHERIC AIRBRAKE"}
          local weapon_part_list = {"GUNNER MODULE","LASER","COMMAND SEAT CONTROLLER","COCKPIT","CANNON","MISSILE","RAILGUN"}

          -- CRITICALS
           for _,reftype in ipairs(critical_part_list) do
            if string.match(elemtype, reftype) then
             elem_category="CRITICALS"
             break
            end
           end

          -- AVIONICS
           if elem_category == "UNKNOWN" then
            for _,reftype in ipairs(avionics_part_list) do
             if string.match(elemtype, reftype) then
              elem_category="AVIONICS"
              break
             end
            end

          -- WEAPONS
            if elem_category == "UNKNOWN" then
             for _,reftype in ipairs(weapon_part_list) do
              -- Avoid mistaking laser emitter for a weapon...
              if elemtype == "LASER" then
               elem_category="WEAPON"
               break 
              elseif string.match(elemtype, reftype) then
               elem_category="WEAPON"
               break
              end
             end
            end
           end
          end
         return elem_category
        end

       -- Element Class
        Element = {}
        Element.__index = Element

        function Element.new(elem_id,elem_type,elem_category, elem_name, elem_pos_x, elem_pos_y, elem_pos_z)
         local self = setmetatable({}, Element)
         self.elem_id = elem_id
         self.elem_type = elem_type
         self.elem_category = elem_category
         self.elem_name = elem_name
         self.elem_pos_x = elem_pos_x
         self.elem_pos_y = elem_pos_y
         self.elem_pos_z = elem_pos_z
         return self
        end

       -- DamageModule Class
        DamageModule = {}
        DamageModule.__index = DamageModule

        function DamageModule.new()
         local self = setmetatable({}, DamageModule)
         self.elem_list = {}
         self.dmg_module_size_ratio = 0

         -- Getting the core offset
          -- XS CORE
           local core_offset = -5
           self.dmg_module_size_ratio = 10
           local core_hp = core.getElementHitPointsById(core.getId())
          -- L CORE
           if core_hp > 10000 then
            core_offset = -128
            self.dmg_module_size_ratio = 1
          -- M CORE
           elseif core_hp > 1000 then
            core_offset = -64
            self.dmg_module_size_ratio = 2
          -- S CORE
           elseif core_hp > 150 then
            core_offset = -32
            self.dmg_module_size_ratio = 5
           end

           self.core_offset=core_offset

          -- Adjustments
           self.dmg_module_size_ratio=self.dmg_module_size_ratio+DAMAGE_size_ratio

           self.max_x= -999999999
           self.min_x= 999999999
           self.max_y= -999999999
           self.min_y = 999999999
           self.max_z= -999999999
           self.min_z = 999999999

         -- Storing Ship Element
          for i,idelem in ipairs(core.getElementIdList()) do
           local elem_type = core.getElementTypeById(idelem):upper()
           local elem_categ = getElemCategory(elem_type)
           local elem_name = core.getElementNameById(idelem)
           local x,y,z = table.unpack(core.getElementPositionById(idelem))
           x=(x+core_offset)*self.dmg_module_size_ratio
           y=(y+core_offset)*self.dmg_module_size_ratio
           z=(z+core_offset)*self.dmg_module_size_ratio
           if self.min_x > x then
            self.min_x = x
           end
           if self.min_y > y then
            self.min_y = y
           end
           if self.min_z > z then
            self.min_z = z
           end
           if self.max_x < x then
            self.max_x = x
           end
           if self.max_y < y then
            self.max_y = y
           end
           if self.max_z < z then
            self.max_z = z
           end
           self:add(Element.new(idelem,elem_type, elem_categ, elem_name, x, y, z))
          end

         -- Computing ship size
          self.ship_width = 0
          if self.min_x < 0 then
           self.ship_width = self.ship_width + (self.min_x)*-1
          else
           self.ship_width = self.ship_width + self.min_x
          end
          if self.max_x < 0 then
           self.ship_width = self.ship_width + (self.max_x)*-1
          else
           self.ship_width = self.ship_width + self.max_x
          end
          self.ship_height = 0
          if self.min_y < 0 then
           self.ship_height = self.ship_height + (self.min_y)*-1
          else
           self.ship_height = self.ship_height + self.min_y
          end
          if self.max_y < 0 then
           self.ship_height = self.ship_height + (self.max_y)*-1
          else
           self.ship_height = self.ship_height + self.max_y
          end
          self.ship_z = 0
          if self.min_z < 0 then
           self.ship_z = self.ship_z + (self.min_z)*-1
          else
           self.ship_z = self.ship_z + self.min_z
          end
          if self.max_z < 0 then
           self.ship_z = self.ship_z + (self.max_z)*-1
          else
           self.ship_z = self.ship_z + self.max_z
          end
         return self
        end

        function DamageModule.add(self,element)
         table.insert(self.elem_list, element)
        end

        function DamageModule.renderHTML(self)
         top_view_html_hud = ""
         side_view_html_hud = ""
         dead_elem_list_hud = ""
         high_damage_list_hud = ""
         medium_damage_list_hud = ""
         light_damage_list_hud = ""
         local label_x = self.max_x-self.min_x
         local maxtoptv = -99999999999
         local maxtopsv = -99999999999

          for _,elem in ipairs(self.elem_list) do
           local elem_hp = core.getElementHitPointsById(elem.elem_id)
           local elemmax_hp = core.getElementMaxHitPointsById(elem.elem_id)
           local elem_hp_percentage = (elem_hp*100)/elemmax_hp
           local elem_restore = core.getRemainingRestorations(elem.elem_id)
           local color=""
           local opacity=0.2
           elem_hp_percentage = round(elem_hp_percentage)
           if elem_hp_percentage >= 100 then
            color="#9BFFAC"
           elseif elem_hp_percentage >= 75 then
            opacity=0.3
            color="#FFDD8E"
            light_damage_list_hud = light_damage_list_hud..[[<span class="ldmg">&nbsp]]..elem.elem_name..[[</span>&nbsp<span class="r">]]..elem_hp_percentage..[[%</span><span class="f_right">(]]..elem_restore..[[)</span><br>]]
           elseif elem_hp_percentage >= 50 then
            color="#FF9E66"
            opacity=0.4
            medium_damage_list_hud = medium_damage_list_hud..[[<span class="mdmg">&nbsp]]..elem.elem_name..[[</span>&nbsp<span class="r">]]..elem_hp_percentage..[[%</span><span class="f_right">(]]..elem_restore..[[)</span><br>]]
           elseif elem_hp_percentage > 0 then
            color="#FF2819"
            opacity=0.5
            high_damage_list_hud = high_damage_list_hud..[[<span class="hdmg">&nbsp]]..elem.elem_name..[[</span>&nbsp<span class="r">]]..elem_hp_percentage..[[%</span><span class="f_right">(]]..elem_restore..[[)</span><br>]]
           elseif elem_hp_percentage == 0 then
            color="#7F120C"
            opacity=1
            dead_elem_list_hud = dead_elem_list_hud..[[<span class="dead">&nbsp]]..elem.elem_name..[[</span>&nbsp<span class="r">0%</span><span class="f_right">(]]..elem_restore..[[)</span><br>]]
           end
           local left = 0
           local top = 0
          -- We are using quadrants to place points correctly
           -- 1 2
           -- 3 4
          -- Top view x,y
           if (elem.elem_pos_x>=self.min_x and elem.elem_pos_x<=0) and (elem.elem_pos_y>=0 and elem.elem_pos_y<=self.max_y) then
            -- 1
            left = (self.min_x*-1) + elem.elem_pos_x
            top = self.max_y - elem.elem_pos_y
           elseif (elem.elem_pos_x>0 and elem.elem_pos_x<=self.max_x) and (elem.elem_pos_y>=0 and elem.elem_pos_y<=self.max_y) then
            -- 2
            left = (self.min_x*-1) + elem.elem_pos_x
            top = self.max_y - elem.elem_pos_y
           elseif (elem.elem_pos_x>=self.min_x and elem.elem_pos_x<=0) and (elem.elem_pos_y>=self.min_y and elem.elem_pos_y<0) then
            -- 3
            left = (self.min_x*-1) + elem.elem_pos_x
            top = self.max_y + (elem.elem_pos_y*-1)
           elseif (elem.elem_pos_x>0 and elem.elem_pos_x<=self.max_x) and (elem.elem_pos_y>=self.min_y and elem.elem_pos_y<0) then
            -- 4
            left = (self.min_x*-1) + elem.elem_pos_x
            top = self.max_y + (elem.elem_pos_y*-1)
           end
           if maxtoptv < top then
            maxtoptv = top
           end
           top_view_html_hud = top_view_html_hud..[[<g transform=" rotate(]].. DAMAGE_rotate_layout_top ..[[,]].. DAMAGE_rotate_x_top ..[[,]].. DAMAGE_rotate_y_top ..[[) translate(]].. DAMAGE_translate_x_top ..[[,]].. DAMAGE_translate_y_top ..[[)"><circle fill-opacity="]]..opacity..[[" cx="]]..left..[[" cy="]]..top..[[" r="5" fill="]]..color..[[" /></g>]]
          -- Side view y,z
           if (elem.elem_pos_y>=self.min_y and elem.elem_pos_y<=0) and (elem.elem_pos_z>=0 and elem.elem_pos_z<=self.max_z) then 
            -- 1
            left = (self.min_y*-1) + elem.elem_pos_y
            top = self.max_z - elem.elem_pos_z
           elseif (elem.elem_pos_y>0 and elem.elem_pos_y<=self.max_y) and (elem.elem_pos_z>=0 and elem.elem_pos_z<=self.max_z) then 
            -- 2
            left = (self.min_y*-1) + elem.elem_pos_y
            top = self.max_z - elem.elem_pos_z
           elseif (elem.elem_pos_y>=self.min_y and elem.elem_pos_y<=0) and (elem.elem_pos_z>=self.min_z and elem.elem_pos_z<0) then 
            -- 3
            left = (self.min_y*-1) + elem.elem_pos_y
            top = self.max_z + (elem.elem_pos_z*-1)
           elseif (elem.elem_pos_y>0 and elem.elem_pos_y<=self.max_y) and (elem.elem_pos_z>=self.min_z and elem.elem_pos_z<0) then 
            -- 4
            left = (self.min_y*-1) + elem.elem_pos_y
            top = self.max_z + (elem.elem_pos_z*-1)
           end
           if maxtopsv < top then
            maxtopsv = top
           end
           side_view_html_hud = side_view_html_hud..[[<g transform=" rotate(]].. DAMAGE_rotate_layout_side ..[[,]].. DAMAGE_rotate_x_side ..[[,]].. DAMAGE_rotate_y_side ..[[) translate(]].. DAMAGE_translate_x_side ..[[,]].. DAMAGE_translate_y_side ..[[)"><circle fill-opacity="]]..opacity..[[" cx="]]..left..[[" cy="]]..top..[[" r="5" fill="]]..color..[[" /></g>]]
          end

          -- Top view code x,y
           top_view_html_hud = [[<svg width="360" height="150">]]..top_view_html_hud
           top_view_html_hud = top_view_html_hud ..[[</svg>]]
          -- side view y,z
           side_view_html_hud = [[<svg width="360" height="150">]]..side_view_html_hud
           side_view_html_hud = side_view_html_hud ..[[</svg>]]

         return {dead_elem_list_hud,
          high_damage_list_hud,
          medium_damage_list_hud,
          light_damage_list_hud,
          top_view_html_hud,
          side_view_html_hud}
        end

       dmgrep = DamageModule.new()

    --AIR DATA
     function air_data()
      --ORBITAL DATA
       function orbital_data()
        local myPos = vec3(core.getConstructWorldPos())
        local myVelocity = vec3(core.getWorldVelocity())

        local Atlas = atlas()
        local PlanetaryReference = planetref()
        local Kepler = kepler()
        local planetref = PlanetaryReference(Atlas)
        local helios = planetref[0]
        local closestbody = helios:closestBody(myPos)
        local orbitInfo = Kepler(closestbody)
        local orbit  = orbitInfo:orbitalParameters(myPos, myVelocity)
        local periapsis  = orbit.periapsis.position

        planet_name = closestbody.name
        planet_pos = closestbody.center
        planet_radius = closestbody.radius
        orbit_ecc = math.floor(orbit.eccentricity*10000)/10000
        orbit_per_pos = periapsis
        if orbit.period == nil then orbit.period = 0 end
        orbit_period_seconds = math.floor(orbit.period)
        local T_time_h = math.floor(orbit_period_seconds/3600)
        local T_time_m = math.floor(((orbit_period_seconds/3600) - T_time_h)*60)
        local T_time_s = math.floor(((((orbit_period_seconds/3600) - T_time_h)*60)- T_time_m)*60)
        orbit_period = T_time_h ..":".. T_time_m ..":".. T_time_s
        orbit_apo_pos = apoapsis
        if orbit.apoapsis == nil then orbit_apo_alt = 0 else
         orbit_apo_alt = math.floor(orbit.apoapsis.altitude) end
        if orbit.apoapsis == nil then orbit_apo_speed = 0 else
         orbit_apo_speed = math.floor(orbit.apoapsis.speed) end
        if (orbit_t_to_apo == nil or speed_hud == 0) then
         orbit_t_to_apo = "n/a"
        else
         orbit_t_to_apo_seconds = math.floor(orbit.timeToApoapsis)
         local A_time_h = math.floor(orbit_t_to_apo_seconds/3600)
         local A_time_m = math.floor(((orbit_t_to_apo_seconds/3600) - A_time_h)*60)
         local A_time_s = math.floor(((((orbit_t_to_apo_seconds/3600) - A_time_h)*60) - A_time_m)*60)
         orbit_t_to_apo = A_time_h ..":".. A_time_m ..":".. A_time_s
        end
        if (orbit_t_to_per == nil or speed_hud == 0) then
         orbit_t_to_per = "n/a"
        else
         orbit_t_to_per_seconds = math.floor(orbit.timeToPeriapsis)
         local P_time_h = math.floor(orbit_t_to_per_seconds/3600)
         local P_time_m = math.floor(((orbit_t_to_per_seconds/3600) - P_time_h)*60)
         local P_time_s = math.floor(((((orbit_t_to_per_seconds/3600) - P_time_h)*60) - P_time_m)*60)
         orbit_t_to_per = P_time_h ..":".. P_time_m ..":".. P_time_s
        end
        if orbit.periapsis == nil then orbit_per_alt = 0 else
         orbit_per_alt = math.floor(orbit.periapsis.altitude) end
        if orbit.periapsis == nil then orbit_per_speed = 0 end
        if orbit.periapsis.speed > 0 then
         orbit_per_speed = math.floor(orbit.periapsis.speed)
        else
         orbit_per_speed = 0
         orbit_t_to_apo = 0
         orbit_t_to_per = 0
        end

        orbit_circular_speed = math.floor(orbit.periapsis.circularOrbitSpeed)

        pe_dis = ((orbit_per_pos - myPos):len())/1000

        my_planet_alt = (planet_pos - myPos):len()

        if databank then
         if databank.getFloatValue("navigator_pe_target_altitude") ~= 0 then
          PeTargetAlt = math.floor(databank.getFloatValue("navigator_pe_target_altitude"))
         else
          PeTargetAlt = PeTargetAlt
         end
        else
         PeTargetAlt = PeTargetAlt
        end
       end -- function orbital_data()
       orbital_data()

      --AUTOBRAKE
       if databank then
        if databank.getFloatValue("navigator_autobrake") ~= nil then
         autobrake_stops_at = databank.getFloatValue("navigator_autobrake")
        else
         autobrake_stops_at = Autobrake_Stop_Distance
        end
       else
        autobrake_stops_at = Autobrake_Stop_Distance
       end
       autobrake = false
       autobrake_arm = false
       autobrake_ecam_mode = [[ ]]
       autobrake_in = [[ Autobrake OFF ]]

       function autobrake_function()
        autobrake_ecam_mode = [[<span style=" color: yellow">Autobrake</span>&nbsp<span style=" color: #00FFFF">ARM</span>]]
        if (distance_PPOS_B_hud ~= nil and space_pg == true) then
         if databank then
          if databank.getFloatValue("navigator_autobrake") ~= nil then
           autobrake_stops_at = databank.getFloatValue("navigator_autobrake")
          else
           autobrake_stops_at = 2.3
          end
         else
          autobrake_stops_at = 2.3
         end
         autobrake_in = math.floor((distance_PPOS_B_hud - brake_su - autobrake_stops_at)*100)/100
         if distance_PPOS_B_hud <= (brake_su + autobrake_stops_at) then
          Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
          brakeInput = brakeInput + 1
          autobrake = true
          autobrake_arm = false
          autobrake_ecam_mode = [[<span style=" color: #7FFF00">Autobrake ON</span>]]
          unit.stopTimer("autobrake")
         else
          brakeInput = brakeInput - 1
          autobrake = false
         end
        elseif (atmo_pg == true or loading_pg == true) then
         Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
         brakeInput = brakeInput + 1
         autobrake = true
         autobrake_arm = false
         autobrake_ecam_mode = [[<span style=" color: #7FFF00">Parking ON</span>]]
         unit.stopTimer("autobrake")
        else
         if (brakeInput == 0) then
          autobrake_ecam_mode = [[<span style=" color: lightorange">LOAD/AI/SPC to ARM</span>]]
          autobrake = false
         else
          autobrake_ecam_mode = [[<span style=" color: #7FFF00">Autobrake ON</span>]]
          autobrake = true
          autobrake_arm = false
          unit.stopTimer("autobrake")
         end
        end
       end

      --ALTITUDE
       altitude = math.floor(core.getAltitude())

      --SPEED
       speed_hud = math.floor((vec3(core.getVelocity()):len())*3.6)

      --PARKING BRK
       if Parking_Brake_Set == true then
        if speed_hud < 5 then
         brakeInput = brakeInput + 1
          autobrake = true
          autobrake_ecam_mode = [[<span style=" color: #7FFF00">Parking ON</span>]]
        end
       end

      --ACCELERATION
       acc_hud = math.floor(vec3(core.getWorldAcceleration()):len()/9.8*10)/10

      --PITCH / ROLL
       function f_pitch_roll()

        function unit.getPitch()
         local world = vec3(core.getWorldVertical())
         local construct = vec3(core.getConstructWorldOrientationForward())
         local prod = math.asin(world:dot(construct)) * -constants.rad2deg
         return prod
        end
        pitch_hud = math.floor(unit.getPitch()*10)/10

        function unit.getRoll()
         local worldVertical = vec3(core.getWorldVertical())
         local constructForward = vec3(core.getConstructWorldOrientationForward())
         local constructRight = vec3(core.getConstructWorldOrientationRight())
         local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
         local currentRollDegAbs = math.abs(currentRollDeg)
         local currentRollDegSign = utils.sign(currentRollDeg)
        return currentRollDeg
        end
        roll_hud = math.floor(unit.getRoll()*10)/10

        roll_direction = 0
        if roll_hud < 0 then roll_direction = [[<span style=" font-size: 15px; color:#00FFFF"><</span>&nbsp]] .. roll_hud
        elseif roll_hud > 0 then roll_direction = (roll_hud)*-1 .. [[&nbsp<span style=" font-size: 15px; color:#00FFFF">></span>]]
        end

        if speed_hud < 10 then
         pitch_bird_hud = 0
         yaw_bird_hud = 0
        else
         function unit.getBirdPitch()
          local up = vec3(core.getWorldVertical())
          local velocity_vector = vec3(core.getWorldVelocity()):normalize()
          local prod = math.asin(velocity_vector:dot(up)) * constants.rad2deg
          local prod = prod + pitch_hud
          if roll_hud > 90 or roll_hud < -90 then
           return -prod
          else
           return prod
          end
         end
         pitch_bird_hud = math.floor(unit.getBirdPitch()*10)/10

         function unit.getBirdYaw()
          local right = vec3(core.getConstructWorldOrientationRight())
          local velocity_vector = vec3(core.getWorldVelocity()):normalize()  
          local prod = math.asin(velocity_vector:dot(right)) * constants.rad2deg
          return prod
         end
         yaw_bird_hud = math.floor(unit.getBirdYaw()*10)/10
        end

       end
       f_pitch_roll()

      --SPACE ORIENTATION
       autopilot_ecam_mode = [[ ]]
       align_active_mode = [[ ]]
       adjusting_mode = [[ ]]

       function space_orientation()

        if speed_hud == 0 then
         pitch_space_hud = 0
         yaw_space_hud = 0
        else
         function unit.getSpacePitch()
          local up = vec3(core.getConstructWorldOrientationUp())
          local velocity_vector = vec3(core.getWorldVelocity()):normalize()
          local cross = vec3(up:cross(velocity_vector))
          local forward = vec3(core.getConstructWorldOrientationForward()):project_on_plane(cross):normalize()
          local prod = math.acos(velocity_vector:dot(forward)) * constants.rad2deg
          local side = math.asin(velocity_vector:dot(up)) * constants.rad2deg
          if side < 0 then prod = prod else prod = -prod end
          return prod
         end -- function unit.getSpacePitch()

         pitch_space_hud = math.floor(unit.getSpacePitch()*10)/10

         function unit.getSpaceYaw()
          local right = vec3(core.getConstructWorldOrientationRight())
          local velocity_vector = vec3(core.getWorldVelocity()):normalize()
          local cross = vec3(right:cross(velocity_vector))
          local forward = vec3(core.getConstructWorldOrientationForward()):project_on_plane(cross):normalize()
          local prod = math.acos(velocity_vector:dot(forward)) * constants.rad2deg
          local side = math.asin(velocity_vector:dot(right)) * constants.rad2deg
          if side > 0 then prod = prod else prod = -prod end
         return prod
         end -- function unit.getSpaceYaw()

         yaw_space_hud = math.floor(unit.getSpaceYaw()*10)/10
        end

        if databank then
         if (databank.getNbKeys() ~= 0 and databank.getStringValue("navigator_coordinates") ~= "n/a") then
          planet_B_coord = vec3FromStr(databank.getStringValue("navigator_coordinates"))
         else
          planet_B_coord = planet_pos
         end
        else
         planet_B_coord = planet_pos
        end

        function unit.getWPPitch()
         local up = vec3(core.getConstructWorldOrientationUp())
         local myPos = vec3(core.getConstructWorldPos())
         local wp_vector = (planet_B_coord - myPos):normalize()
         local cross = vec3(up:cross(wp_vector))
         local forward = vec3(core.getConstructWorldOrientationForward()):project_on_plane(cross):normalize()
         local prod = math.acos(wp_vector:dot(forward)) * constants.rad2deg
         local side = math.asin(wp_vector:dot(up)) * constants.rad2deg
         if side < 0 then prod = prod else prod = -prod end
        return prod
        end
        pitch_WP_hud = math.floor(unit.getWPPitch()*10)/10

        function unit.getWPYaw()
         local right = vec3(core.getConstructWorldOrientationRight())
         local myPos = vec3(core.getConstructWorldPos())
         local wp_vector = (planet_B_coord - myPos):normalize()
         local cross = vec3(right:cross(wp_vector))
         local forward = vec3(core.getConstructWorldOrientationForward()):project_on_plane(cross):normalize()
         local prod = math.acos(wp_vector:dot(forward)) * constants.rad2deg
         local side = math.asin(wp_vector:dot(right)) * constants.rad2deg
         if side > 0 then prod = prod else prod = -prod end
        return prod
        end
        yaw_WP_hud = math.floor(unit.getWPYaw()*10)/10

       end
       space_orientation()

      --SHIP ALIGNER
       auto_aligner = false
       prograde_mode = false
       orbit_maintainer = false
       destination_mode = false

       function auto_align()

        if prograde_mode == true then
         target_pitch_to_align = pitch_space_hud
         target_yaw_to_align = yaw_space_hud
         align_active_mode = [[Aligning PROGRADE]]
        end

        if destination_mode == true then
         target_pitch_to_align = pitch_WP_hud
         target_yaw_to_align = yaw_WP_hud
         align_active_mode = [[Aligning DESTINATION]]
        end

        local up = vec3(core.getConstructWorldOrientationUp())
        local right = vec3(core.getConstructWorldOrientationRight())
        local constructAngularVelocity = vec3(core.getWorldAngularVelocity())
        local pitchAngle = target_pitch_to_align
        local yawAngle = target_yaw_to_align

        local pitchAngleAbs = math.abs(pitchAngle)
        local yawAngleAbs = math.abs(yawAngle)

        local autoPitchThreshold = 0 --export: For Automatic Aligner
        local autoPitchFactor = 0.8 --export: For Automatic Aligner
        local autoYawThreshhold = 0 --export: For Automatic Aligner
        local autoYawFactor = 0.3 --export: For Automatic Aligner
        local torqueFactor = 2 --export: For Automatic Aligner

        if pitchAngleAbs > autoPitchThreshold or yawAngleAbs > autoYawThreshhold then
         local targetPitchDeg = utils.clamp(0,pitchAngleAbs-30, pitchAngleAbs+30);
         local targetYawDeg =  utils.clamp(0,yawAngleAbs-30, yawAngleAbs+30);
         if (pitchPID == nil) then
          pitchPID = pid.new(autoPitchFactor * 0.01, 0, autoPitchFactor * 0.1)
         end
         if (yawPid == nil) then
          yawPID = pid.new(autoYawFactor * 0.01, 0, autoYawFactor * 0.1)
         end
         pitchPID:inject(targetPitchDeg - pitchAngle)
         yawPID:inject(targetYawDeg - yawAngle)
         local autoPitchInput = pitchPID:get()
         local autoYawInput = yawPID:get()
         targetAngularVelocity = autoPitchInput * autoPitchFactor * right
               + autoYawInput * autoYawFactor * up
         local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
         local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())
         angularAcceleration = angularAcceleration - airAcceleration
         Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)
        else
           targetAngularVelocity = 0
           Nav:setEngineTorqueCommand("torque", vec3.zero, targetAngularVelocity)
        end
       end -- function

      --MAINTAINING ORBIT
       function maintaining_orbit()
        if (orbit_pg == true and
         auto_aligner == true and
         orbit_ecc < 0.9 and
         orbit_apo_alt ~= nil and
         orbit_per_alt ~= nil and
         orbit_t_to_per_seconds ~= nil and
         orbit_t_to_apo_seconds ~= nil and
         math.abs(target_pitch_to_align) < 2 and
         math.abs(target_yaw_to_align) < 2 and
         orbit_per_alt > 6000) then

         if (orbit_per_alt < PeTargetAlt and
          orbit_t_to_per_seconds < orbit_t_to_apo_seconds and
          orbit_t_to_per_seconds > 1/4*orbit_period_seconds and
          orbit_ecc < 0.8) then

          brakeInput = 0
          autobrake = false
          Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 100)
          adjusting_mode = [[Increasing PE]]

         elseif (orbit_per_alt > PeTargetAlt + 5000 and
           orbit_t_to_per_seconds < orbit_t_to_apo_seconds and
           orbit_t_to_per_seconds > 1/4*orbit_period_seconds and
           orbit_ecc < 0.6) then

           Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
           brakeInput = 1
           autobrake = true
           adjusting_mode = [[Decreasing PE]]

         elseif (orbit_per_alt < PeTargetAlt - 2000 and
           orbit_t_to_per_seconds < orbit_t_to_apo_seconds and
           orbit_t_to_per_seconds < 1/4*orbit_period_seconds and
           orbit_ecc < 0.6) then

           brakeInput = 0
           autobrake = false
           Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 100)
           adjusting_mode = [[Increasing PE]]

         elseif (orbit_t_to_per_seconds < 2) then

          if orbit_apo_alt > PeTargetAlt + 5000 then
           Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
           brakeInput = 1
           autobrake = true
           adjusting_mode = [[Decreasing AP]]
          else
           Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
           brakeInput = 0
           autobrake = false
           adjusting_mode = [[Maintaining ORBIT]]
          end

         elseif (orbit_apo_alt > PeTargetAlt + 5000 and
           orbit_t_to_apo_seconds < orbit_t_to_per_seconds and
           orbit_per_alt > 10000 and
           orbit_ecc < 0.8 and
           orbit_apo_alt > orbit_per_alt + 1000 ) then

           Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
           brakeInput = 1
           autobrake = true
           adjusting_mode = [[Decreasing AP]]

         elseif (orbit_apo_alt < PeTargetAlt and
           orbit_t_to_apo_seconds < orbit_t_to_per_seconds and
           orbit_t_to_per_seconds > 1/4*orbit_period_seconds and
             (orbit_per_alt < PeTargetAlt or
           orbit_ecc < 0.8)) then

           brakeInput = 0
           autobrake = false
           Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 100)
           adjusting_mode = [[Increasing AP]]

         elseif (orbit_t_to_apo_seconds < 2) then

          if orbit_per_alt > PeTargetAlt + 5000 then
           Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
           brakeInput = 1
           autobrake = true
           adjusting_mode = [[Decreasing PE]]
          else
           Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
           adjusting_mode = [[Maintaining ORBIT]]
          end

         elseif (orbit_per_alt < 6000) then
          Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
          adjusting_mode = [[Unafe Orbit BRK ENG]]
          unit.setTimer("autobrake", 1/2)
          brakeInput = 1
          autobrake = true
          autobrake_ecam_mode = [[<span style=" color: #7FFF00">Autobrake ON</span>]]
         else
          Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
          brakeInput = 0
          autobrake = false
          adjusting_mode = [[Maintaining ORBIT]]
         end

        else
         if  ((space_pg == true or
          loading_pg == true or
          atmo_pg == true) and
          adjusting_mode ~= [[Maintaining ORBIT]]) then

          adjusting_mode = [[ORB Mode to ARM]]
         else
          adjusting_mode = [[Orbiting ARM]]
         end
        end
       end

      --RADIO ALTIMITER
       function f_radioalt_hud()
        radioalt_hud = [[R.A. <span class="white">n/a</span>]]
        if radio_alt_1 then
         if radio_alt_1.getDistance then
          if math.floor(radio_alt_1.getDistance()) ~= -1 then
           radioalt_hud = [[ R.A.&nbsp<span class="white">]]..math.floor(radio_alt_1.getDistance())..[[</span>&nbsp<span class="cyan">m</span>]]
          else
           radioalt_hud = ""
          end
         end
         if radio_alt_1.distance then
          if math.floor(radio_alt_1.distance()) ~= -1 then
           radioalt_hud = [[ R.A.&nbsp<span class="white">]]..math.floor(radio_alt_1.distance())..[[</span>&nbsp<span class="cyan">m</span>]]
          else
           radioalt_hud = ""
          end
         end
        else
         radioalt_hud = [[R.A. <span class="white">n/a</span>]]
        end
        return radioalt_hud
       end
       f_radioalt_hud()

      --DISTANCE TO WP FOR AI
       function distance_to_wp_ai()
        if databank then
         if (databank.getNbKeys() ~= 0 and databank.getStringValue("navigator_coordinates") ~= "n/a") then
          local WP_coordinates = vec3FromStr(databank.getStringValue("navigator_coordinates"))
          local myPos = vec3(core.getConstructWorldPos())
          distance_to_wp = string.format("%.1f",((WP_coordinates - myPos):len())/1000)
          wp_color = "#00FFFF"
         else
          distance_to_wp = "n/a"
          wp_color = "none"
         end
        else
         distance_to_wp = "n/a"
         wp_color = "none"
        end
        return distance_to_wp
       end
       distance_to_wp_ai()

      --THROTTLE
       thr = math.floor(unit.getThrottle())

      --VERTICAL SPEED
       local worldVelocity = vec3(core.getWorldVelocity())
       local gravity = vec3(core.getWorldGravity())
       vs_hud = math.floor(worldVelocity:dot(-gravity:normalize()))

      --FUEL MASS
       fuel_mass = 0
       function total_fuel_mass()

        local a_fuel_mass = 0
        for i = 1, atmofueltank_size do
         a_fuel_mass = a_fuel_mass + atmofueltank[i].getItemsMass()
         t_a_fuel_mass = math.floor(a_fuel_mass/1000*10)/10
        end

        local s_fuel_mass = 0
        if spacefueltank_size ~= 0 then
         for i = 1, spacefueltank_size do
          s_fuel_mass = s_fuel_mass + spacefueltank[i].getItemsMass()
          t_s_fuel_mass = math.floor(s_fuel_mass/1000*10)/10
         end
        else
         t_s_fuel_mass = 0
        end

        local r_fuel_mass = 0
        if rocketfueltank_size ~= 0 then
         for i = 1, rocketfueltank_size do
          r_fuel_mass = r_fuel_mass + rocketfueltank[i].getItemsMass()
          t_r_fuel_mass = math.floor(r_fuel_mass/1000*10)/10
         end
        else
         t_r_fuel_mass = 0
        end

        fuel_mass = t_a_fuel_mass + t_s_fuel_mass + t_r_fuel_mass

       return fuel_mass
       end -- function total_fuel_mass()

      --LOADING DATA
       function f_loading_data()

        if databank then
         if databank.getFloatValue("navigator_MTOW") ~= nil then
          MTOW = databank.getFloatValue("navigator_MTOW")
         else
          MTOW = Maximum_Take_Off_Weight
         end
        else
         MTOW = Maximum_Take_Off_Weight
        end

        cargo_m = 0
        if container_size ~= 0 then
         for i = 1, container_size do
          cargo_m = cargo_m + container[i].getItemsMass()
          cargo_m_t = math.floor((cargo_m/1000)*10)/10
          cargo_m_t_hud = cargo_m_t
         end
        else
         cargo_m_t = 0
         cargo_m_t_hud = "n/a"
        end
       return cargo_m_t, cargo_m_t_hud
       end -- function cargo_data()
       f_loading_data()

      --GW, ZFW, DOW
       gw_m = math.floor(core.getConstructMass()/1000*10)/10
       zfw_m = 0
       dow_m = 0

      --MTOW PERCENTAGE
       MTOW_p = math.floor(gw_m*1000/MTOW*100)

      --NUMBER OF TANKS
       a_fuel_tank_n = atmofueltank_size
       if spacefueltank_size ~= 0 then
        s_fuel_tank_n = spacefueltank_size
       else
        s_fuel_tank_n = "0"
       end
       if rocketfueltank_size ~= 0 then
        r_fuel_tank_n = rocketfueltank_size
       else
        r_fuel_tank_n = "0"
       end

      --AVG FUEL PERCENTAGE
       s_fuel_percent_avg_hud = 0
       a_fuel_percent_avg_hud = 0
       r_fuel_percent_avg_hud = 0

       function avg_fuel_percentage()
        local a_fuel_percent = 0
        for i = 1, atmofueltank_size do
         if json.decode(atmofueltank[i].getData()).percentage then
          a_fuel_percent = a_fuel_percent + json.decode(atmofueltank[i].getData()).percentage
         end
        end
        a_fuel_percent_avg_hud = math.ceil(a_fuel_percent/atmofueltank_size)

        if spacefueltank_size ~= 0 then
         local s_fuel_percent = 0
         for i = 1, spacefueltank_size do
          if json.decode(spacefueltank[i].getData()).percentage then
           s_fuel_percent = s_fuel_percent + json.decode(spacefueltank[i].getData()).percentage
          end
         end
         s_fuel_percent_avg_hud = math.ceil(s_fuel_percent/spacefueltank_size)
        else
         s_fuel_percent_avg_hud = [[n/a]]
        end

        if rocketfueltank_size ~= 0 then
         local r_fuel_percent = 0
         for i = 1, rocketfueltank_size do
          if json.decode(rocketfueltank[i].getData()).percentage then
           r_fuel_percent = r_fuel_percent + json.decode(rocketfueltank[i].getData()).percentage
          end
         end
         r_fuel_percent_avg_hud = math.ceil(r_fuel_percent/rocketfueltank_size)
        else
         r_fuel_percent_avg_hud = [[n/a]]
        end
       end
       avg_fuel_percentage()

      --ATMO FUEL WARNING
       a_fuelspy_hud = [[<span style=" color:#141fad">A Fuel</span>]]
       a_fuelwarning_hud = [[ ]]

       function atmo_fuel_percent()
        local fuelpercent = 0
        a_fuelwarning_hud = [[ ]]
        a_fuelspy_hud = [[<span style=" color:#141fad">A Fuel</span>]]
        for i = 1, atmofueltank_size do
         if json.decode(atmofueltank[i].getData()).percentage then
          fuelpercent = json.decode(atmofueltank[i].getData()).percentage
          if fuelpercent < 20 and fuelpercent > 0 then
           a_fuelspy_hud = [[<span style=" color:orange">A Fuel</span>]] 
           a_fuelwarning_hud = a_fuelwarning_hud ..[[<span style=" color: orange">A Fuel Tank ]]..i..[[ LO LVL</span><br>]]
          elseif fuelpercent == 0 then
           a_fuelspy_hud = [[<span style=" color:red">A Fuel</span>]]
           a_fuelwarning_hud = a_fuelwarning_hud.. [[<span style=" color: red">A Fuel Tank ]]..i..[[ EMPTY</span><br>]]
          end
         end
        end
       return a_fuelspy_hud, a_fuelwarning_hud
       end -- function atmo_fuel_percent()

      --SPACE FUEL WARNING
       s_fuelspy_hud = [[<span style=" color:#141fad">S Fuel</span>]]
       s_fuelwarning_hud = [[ ]]

       if spacefueltank_size ~= 0 then
        function space_fuel_percent()
         local fuelpercent = 0
         s_fuelwarning_hud = [[ ]]
         s_fuelspy_hud = [[<span style=" color:#141fad">S Fuel</span>]]
         for i = 1, spacefueltank_size do
          if json.decode(spacefueltank[i].getData()).percentage then
           fuelpercent = json.decode(spacefueltank[i].getData()).percentage
           if fuelpercent < 20 and fuelpercent > 0 then
            s_fuelspy_hud = [[<span style=" color:orange">S Fuel</span>]] 
            s_fuelwarning_hud = s_fuelwarning_hud ..[[<span style=" color: orange">S Fuel Tank ]]..i..[[ LO LVL</span><br>]]
           elseif fuelpercent == 0 then
            s_fuelspy_hud = [[<span style=" color:red">S Fuel</span>]]
            s_fuelwarning_hud = s_fuelwarning_hud.. [[<span style=" color: red">S Fuel Tank ]]..i..[[ EMPTY</span><br>]]
           end
          end
         end
         return s_fuelspy_hud, s_fuelwarning_hud
        end
       end

      --ROCKET FUEL WARNING
       r_fuelspy_hud = [[<span style=" color:#141fad">R Fuel</span>]]
       r_fuelwarning_hud = [[ ]]
       r_active_hud = [[#141fad]]

       if rocketfueltank_size ~= 0 then
        function rocket_fuel_percent()
         local fuelpercent = 0
         r_fuelwarning_hud = [[ ]]
         r_fuelspy_hud = [[<span style=" color:#141fad">R Fuel</span>]]
         for i = 1, rocketfueltank_size do
          if json.decode(rocketfueltank[i].getData()).percentage then
           fuelpercent = json.decode(rocketfueltank[i].getData()).percentage
           if fuelpercent < 20 and fuelpercent > 0 then
            r_fuelspy_hud = [[<span style=" color:orange">R Fuel</span>]] 
            r_fuelwarning_hud = r_fuelwarning_hud ..[[<span style=" color: orange">R Fuel Tank ]]..i..[[ LO LVL</span><br>]]
           elseif fuelpercent == 0 then
            r_fuelspy_hud = [[<span style=" color:red">R Fuel</span>]]
            r_fuelwarning_hud = r_fuelwarning_hud.. [[<span style=" color: red">R Fuel Tank ]]..i..[[ EMPTY</span><br>]]
           end
          end
         end
         return r_fuelspy_hud, r_fuelwarning_hud
        end

        function r_warning_light()
         for i = 1, rocketfueltank_size do
          r_active_hud = json.decode(rocketfueltank[i].getData()).timeLeft
           if r_active_hud == "n/a" then
              r_active_hud = [[#141fad]]
           else
              r_active_hud = [[red]]
           end
         end
        end -- function r_warning_light()
        r_warning_light()

       end

      --ECAM
       function ECAM()

        function autopilot_ecam()
         if (autopilot_ecam_mode == [[Autopilot ON - Mode 1]] or
          autopilot_ecam_mode == [[Autopilot ON - Mode 2]] or
          autopilot_ecam_mode == [[Autopilot ON - Mode 3]]) then
          br_1 = [[<br>]]
         else
          br_1 = [[ ]]
         end

         if (align_active_mode == [[Aligning PROGRADE]] or
          align_active_mode == [[Aligning DESTINATION]]) then
          br_2 = [[<br>]]
         else
          br_2 = [[ ]]
         end

         if (adjusting_mode == [[Maintaining ORBIT]] or
           adjusting_mode == [[Mainteining Orbit in: 3]] or
           adjusting_mode == [[Mainteining Orbit in: 2]] or
           adjusting_mode == [[Mainteining Orbit in: 1]] or
           adjusting_mode == [[Align to DEST in: 3]] or
           adjusting_mode == [[Align to DEST in: 2]] or
           adjusting_mode == [[Align to DEST in: 1]] or
           adjusting_mode == [[Increasing PE]] or
           adjusting_mode == [[Increasing AP]] or
           adjusting_mode == [[Decreasing PE]] or
           adjusting_mode == [[Decreasing AP]] or
           adjusting_mode == [[Orbiting ARM]] or
           adjusting_mode == [[Unafe Orbit BRK ENG]] or
           adjusting_mode == [[ORB Mode to ARM]]) then
          br_3 = [[<br>]]
         else
          br_3 = [[ ]]
         end

         local autopilot_ecam = [[<span style=" color: #7FFF00">]]..autopilot_ecam_mode..[[</span><span style=" color: #00FFFF">]]
         local autopilot_ecam = autopilot_ecam..br_1..align_active_mode
         local autopilot_ecam = autopilot_ecam..br_2..adjusting_mode..[[</span>]]..br_3
         return autopilot_ecam
        end
        autopilot_ecam()

        function autobrake_ecam()
         if (autobrake_ecam_mode == [[<span style=" color: yellow">Autobrake</span>&nbsp<span style=" color: #00FFFF">ARM</span>]] or
          autobrake_ecam_mode == [[<span style=" color: #7FFF00">Autobrake ON</span>]] or
          autobrake_ecam_mode == [[<span style=" color: #7FFF00">Parking ON</span>]] or
          autobrake_ecam_mode == [[<span style=" color: lightorange">LOAD/AI/SPC to ARM</span>]]) then
          br_4 = [[<br>]]
         else
          br_4 = [[ ]]
         end
         local autobrake_ecam = autopilot_ecam()..autobrake_ecam_mode..br_4
         return autobrake_ecam
        end
        autobrake_ecam()

        function fuel_ecam()
         local fuel_ecam = autobrake_ecam()..a_fuelwarning_hud
         fuel_ecam = fuel_ecam..s_fuelwarning_hud
         fuel_ecam = fuel_ecam..r_fuelwarning_hud
         return fuel_ecam
        end
        fuel_ecam()

        function ship_config()
         local ship_config_ecam = fuel_ecam()
         if radio_alt_1 then
          ship_config_ecam = ship_config_ecam
         else
          ship_config_ecam = ship_config_ecam..[[<span class="ecam_rec">R.A. Not Installed</span><br>]]
         end
         if container_1 then
          ship_config_ecam = ship_config_ecam
         else
          ship_config_ecam = ship_config_ecam..[[<span class="ecam_rec">Containers Not Linked</span><br>]]
         end
         if databank then
          if (databank.getStringValue("databank_verification") ~= "Verified") then
           ship_config_ecam = ship_config_ecam..[[<span class="ecam_rec">Inizialize Databank</span><br>]]
          else
           ship_config_ecam = ship_config_ecam
          end
         else
          ship_config_ecam = ship_config_ecam..[[<span class="ecam_rec">Databank Not Installed</span>]]
         end
         return ship_config_ecam
        end
        ship_config()

        return ship_config()
       end
       ECAM()


      --ATMO FUEL MIN TIME
       a_t_h = 0
       a_t_m = 0
       a_t_s = 0

       function a_fuel_minimum_time()
        local key = 1
        local i = 1
        local minutes_min = json.decode(atmofueltank[i].getData()).timeLeft
         while minutes_min == "n/a" do i = i + 1
          if i > atmofueltank_size then
           i = 1
           minutes_min = 0
          else
           minutes_min = json.decode(atmofueltank[i].getData()).timeLeft
          end
         end
         for k, v in ipairs(atmofueltank) do
          local timeleft = json.decode(atmofueltank[k].getData()).timeLeft
           if timeleft ~= "n/a" and timeleft > 0 then
            if timeleft < minutes_min then
             key = k
             minutes_min = timeleft
            end
           end
         end
        a_t_h = minutes_min/3600
        a_t_m = (a_t_h-(math.floor(a_t_h)))*60
        a_t_s = (a_t_m-(math.floor(a_t_m)))*60

       end -- function a_fuel_minimum_time()

      --SPACE FUEL MIN TIME AND PERCENTAGE
       s_t_h = 0
       s_t_m = 0
       s_t_s = 0

       if spacefueltank_size ~= 0 then
        function s_fuel_minimum_time()
         local key = 1
         local i = 1
         local minutes_min = json.decode(spacefueltank[i].getData()).timeLeft
         while minutes_min == "n/a" do i = i + 1
          if i > spacefueltank_size then
           i = 1
           minutes_min = 0
          else
           minutes_min = json.decode(spacefueltank[i].getData()).timeLeft
          end
         end
         for k, v in ipairs(spacefueltank) do
          local timeleft = json.decode(spacefueltank[k].getData()).timeLeft
          if timeleft ~= "n/a" and timeleft > 0 then
           if timeleft < minutes_min then
            key = k
            minutes_min = timeleft
           end
          end
         end
         s_t_h = minutes_min/3600
         s_t_m = (s_t_h-(math.floor(s_t_h)))*60
         s_t_s = (s_t_m-(math.floor(s_t_m)))*60
        end
       end


      --ROCKET FUEL MIN TIME
       r_t_h = 0
       r_t_m = 0
       r_t_s = 0

       if rocketfueltank_size ~= 0 then
        function r_fuel_minimum_time()
         local key = 1
         local i = 1
         local minutes_min = json.decode(rocketfueltank[i].getData()).timeLeft   
         while minutes_min == "n/a" do i = i + 1
          if i > rocketfueltank_size then
           i = 1
           minutes_min = 0
          else
           minutes_min = json.decode(rocketfueltank[i].getData()).timeLeft
          end
         end
         for k, v in ipairs(rocketfueltank) do
          local timeleft = json.decode(rocketfueltank[k].getData()).timeLeft
          if timeleft ~= "n/a" and timeleft > 0 then
           if timeleft < minutes_min then
            key = k
            minutes_min = timeleft
           end
          end
         end
         r_t_h = minutes_min/3600
         r_t_m = (r_t_h-(math.floor(r_t_h)))*60
         r_t_s = (r_t_m-(math.floor(r_t_m)))*60
        end
       end

      --LANDING GEAR
       function landing_gear()
        ldg_st = unit.isAnyLandingGearExtended()
        if ldg_st == 0 then
         ldg_st = [[red]]
        else
         ldg_st = [[green]]
        end
       end
       landing_gear()

      --LIGHTS
       function f_lights_st()
        lights_st = unit.isAnyHeadlightSwitchedOn()
        if lights_st == 1 then
         lights_st_hud = [[#00FFFF]]
        else
         lights_st_hud = [[#141fad]]
        end
       end
       f_lights_st()

      --CHECK FOR DAMAGES
       dmg_color = "#00FFFF"
       function dmg_checker()
        local ElementsID = core.getElementIdList()
        local eleMaxHp = core.getElementMaxHitPointsById
        local eleHp = core.getElementHitPointsById
        for k in pairs(ElementsID) do
         local hp = 0
         local mhp = 0
         mhp = eleMaxHp(ElementsID[k])
         hp = eleHp(ElementsID[k])
         if ((mhp - hp) > 2) then
          dmg_color = "red"
          break
         else
          dmg_color = "#00FFFF"
         end
        end
       end
       dmg_checker()

      --RETRO ROCKET
       function f_rrThrust_hud()
        rrThrust_hud = 0
        if json.decode(unit.getData()).maxBrake then
         local unit_data = json.decode(unit.getData())
         rrThrust_hud = (math.floor(unit_data.maxBrake/1000)) -- kN
        end
       end
       f_rrThrust_hud()

      --BRAKING DISTANCE
       final_speed_brk = 0
       function braking_distance()

        local c  = 30000*1000/3600
        local c2 = c*c
        local initialSp = (math.floor((vec3(core.getVelocity()):len())*3.6))*0.277777777778 -- INSERT Km/h

        local finalSp = (final_speed_brk)*0.277777777778 -- INSERT Km/h
        local restMass = (math.floor(core.getConstructMass()/1000*10)/10)*1000 -- INSERT t
        local rrThrust = 0
        if json.decode(unit.getData()).maxBrake then
         local unit_data = json.decode(unit.getData())
         rrThrust = (math.floor(unit_data.maxBrake/1000))*1000 -- INSERT kN
        end

        local totA = -rrThrust * 1/restMass
        local distance = 0
        local time = 0

        if (initialSp > finalSp) then
         local k1 = c*math.asin(initialSp/c)
         local k2 = c2 *math.cos(k1/c)/totA
         local t  = (c * math.asin(finalSp/c) - k1)/totA
         local d  = k2 - c2 * math.cos((totA*t + k1)/c)/totA
         distance  = distance + d
         time = time + t
        end

        brake_min = math.floor(time/60)
        brake_sec = math.floor(((time/60)-brake_min)*60)

        brake_su = math.floor(distance/200000*100)/100
        brake_km = math.floor(distance/1000)
       end
       braking_distance()

      --SPACE DATA
       function navigator_space_data()
        if databank.getStringValue("navigator_target_destination") then
         navigator_target_destination_hud = databank.getStringValue("navigator_target_destination")
        else
         navigator_target_destination_hud = "no Dest."
        end

        if (databank.getIntValue("navigator_eta_h") or databank.getIntValue("navigator_eta_m") or databank.getIntValue("navigator_eta_s")) then
         local time_h = databank.getIntValue("navigator_eta_h")
         local time_m = databank.getIntValue("navigator_eta_m")
         local time_s = databank.getIntValue("navigator_eta_s")
         navigator_eta_hud = time_h ..":".. time_m ..":".. time_s
        else
         navigator_eta_hud = "0:0:0"
        end

        if databank.getFloatValue("navigator_speed") then
         navigator_speed_hud = math.floor(databank.getFloatValue("navigator_speed"))
        else
         navigator_speed_hud = 0
        end

        if databank.getFloatValue("navigator_distance") then
         if databank.getFloatValue("navigator_distance") == 0 then
          navigator_distance_hud = 0
         else
          navigator_distance_hud = databank.getFloatValue("navigator_distance")
         end
        end

        if databank.getStringValue("navigator_coordinates") then
         navigator_coordinates_hud = databank.getStringValue("navigator_coordinates")
        else
         navigator_coordinates_hud = "n/a"
        end

        if databank.getStringValue("navigator_from") then
         navigator_from_hud = databank.getStringValue("navigator_from")
        else
         navigator_from_hud = "no From"
        end

        if databank.getStringValue("navigator_from_coordinates") then
         navigator_from_coordinates_hud = databank.getStringValue("navigator_from_coordinates")
        else
         navigator_from_coordinates_hud = "n/a"
        end
       end

      --RADAR
       radar_warning_hud = ""
       function radar_contacts()
        if radar_1 then
         local ContactsID = table.unpack(radar_1.getEntries())
         if ContactsID ~= nil then
          local radar_data = radar_1.getData():gmatch('"constructId":"[0-9]*","distance":[%d%.]*')
          local counter = 0
          local min_distance = 0
          for v in radar_data do
           counter = counter + 1
           if counter < 21 then
            local id,distance = v:match('"constructId":"([0-9]*)","distance":([%d%.]*)')
            cDistance = round(distance/1000,2)
            cType = radar_1.getConstructType(id)
            if min_distance == 0 then
             min_distance = cDistance
            elseif cDistance < min_distance then
             min_distance = cDistance
            end
            if (cType == "dynamic") then
             radar_warning_hud = [[<span class="rdr_hud red">RDR CONTACT</span><br><span class="rdr_hud white">]]..min_distance..[[</span>&nbsp<span class="rdr_hud units">Km</span>]]
            else
             radar_warning_hud = ""
            end
           else
            break
           end
          end
         else
          radar_warning_hud = ""
         end
        else
         radar_warning_hud = ""
        end
       end
       radar_contacts()

      --DATABANK CONDITION for SPACE DATA
       function databank_condition()
        if databank then
         if (databank.getStringValue("databank_verification") ~= "Verified") then
          navigator_target_destination_hud = "Interface is Off Turn ON to Initialize"
          navigator_eta_hud = "n/a"
          navigator_speed_hud = 0
          navigator_distance_hud = 0
          navigator_coordinates_hud = "n/a"
          navigator_from_hud = "n/a"
          navigator_from_coordinates_hud = "n/a"
         else
          navigator_space_data()
         end
        else
         navigator_target_destination_hud = "Databank Not Installed"
         navigator_eta_hud = "n/a"
         navigator_speed_hud = 0
         navigator_distance_hud = 0
         navigator_coordinates_hud = "n/a"
         navigator_from_hud = "n/a"
         navigator_from_coordinates_hud = "n/a"
        end
       end
       databank_condition()

     end -- air_data()

    --SVG
     --SVG A FUEL
      function a_fuel_svg()
       return [[
        <svg width="30" height="75">
         <rect x="0" y="0" width="30" height="]]..a_fuel_percent_avg_hud..[[%" style=" fill: dodgerblue" transform="rotate(180, 15, 37)" />
        </svg>
       ]]
      end

     --SVG S FUEL
      function s_fuel_svg()
       return [[
        <svg width="30" height="75">
         <rect x="0" y="0" width="30" height="]]..s_fuel_percent_avg_hud..[[%" style=" fill: yellow" transform="rotate(180, 15, 37)" />
        </svg>]]
      end

     --SVG R FUEL
      function r_fuel_svg()
       return [[
        <svg width="30" height="75">
         <rect x="0" y="0" width="30" height="]]..r_fuel_percent_avg_hud..[[%" style=" fill: slateblue" transform="rotate(180, 15, 37)" />
        </svg>
       ]]
      end

     --SVG MTOW
      function MTOW_svg()
       return [[
        <svg width="30" height="40">
         <rect x="0" y="0" width="30" height="]]..MTOW_p..[[%" style=" fill:yellow" transform="rotate(180, 15, 20)" />
        </svg>
       ]]
      end

     --SVG THRUST
      function thr_svg()
       return [[
        <svg width="30" height="50">
         <rect x="0" y="0" width="30" height="]]..thr..[[%" style=" fill:#00FFFF" transform="rotate(180, 15, 25)" />
        </svg>
       ]]
      end

     --SVG ARTIFICIAL HORIZON
      function art_h_svg()
       if yaw_WP_hud >= 75 then
        yaw_WP_hud = 75
       elseif yaw_WP_hud <= -75 then
        yaw_WP_hud = -75
       elseif ((yaw_WP_hud > 45 and yaw_WP_hud < 75) or (yaw_WP_hud > -75 and yaw_WP_hud < -45)) then
        yaw_WP_hud = yaw_WP_hud - math.sin(roll_hud)
       end

       return [[
        <svg width="150" height="75">
         <g style="stroke:yellow;stroke-width:1;fill:none" transform="rotate(]]..-roll_hud..[[,75,35) translate(0 ]]..pitch_hud..[[)">
          <polyline points="65,-20 75,-10 85,-20" style=" stroke:#00FFFF"/> -- +45 deg down arrow
          <polyline points="65,-35 75,-25 85,-35" style=" stroke:#00FFFF"/> -- +60 deg down arrow
          <polyline points="65,-50 75,-40 85,-50" style=" stroke:#00FFFF"/> -- +75 deg down arrow
          <polyline points="65,-60 75,-70 85,-60" style=" stroke:#00FFFF"/> -- +75 deg up arrow
          <polyline points="65,-75 75,-85 85,-75" style=" stroke:#00FFFF"/> -- +60 deg up arrow
          <polyline points="65,-90 75,-100 85,-90" style=" stroke:#00FFFF"/> -- +45 deg up arrow
          <polyline points="65,90 75,80 85,90"/> -- -45 deg up arrow
          <polyline points="65,105 75,95 85,105"/> -- -60 deg up arrow
          <polyline points="65,120 75,110 85,120"/> -- -75 deg up arrow
          <polyline points="65,130 75,140 85,130"/> -- -75 deg down arrow
          <polyline points="65,145 75,155 85,145"/> -- -60 deg down arrow
          <polyline points="65,160 75,170 85,160"/> -- -60 deg down arrow

          <line x1="0" y1="35" x2="70" y2="35"/> -- left terrein line
          <line x1="80" y1="35" x2="150" y2="35"/> -- right terrein line
          <line x1="75" y1="5" x2="75" y2="-115" style=" stroke: #00FFFF"/> -- lower sky line
          <line x1="65" y1="5" x2="85" y2="5" style=" stroke: #00FFFF; stroke-width: 2"/> -- 30 deg up
          <line x1="65" y1="65" x2="85" y2="65" style=" stroke-width: 2"/> -- -30 deg down
          <line x1="75" y1="65" x2="75" y2="185" style=" stroke: red"/> -- too low pitch
         </g>
         <g style="stroke:white;stroke-width:1">
          <line x1="0" y1="35" x2="15" y2="35"/> -- 0 pitch left
          <line x1="135" y1="35" x2="150" y2="35"/> -- 0 pitch right
          <line x1="75" y1="0" x2="75" y2="5"/> -- 0 roll top
          <line x1="75" y1="65" x2="75" y2="75"/> -- 0 roll bottom
          <rect x="72.5" y="32.5" width="5" height="5" fill=" white"/> -- 0 box
         </g>
         <g style="stroke:white;stroke-width:1" transform="translate(]]..yaw_bird_hud.." "..pitch_bird_hud..[[)">
          <circle cx="75" cy="35" r="5" fill-opacity="0"/> -- bird
          <line x1="75" y1="20" x2="75" y2="30"/> -- bird tail
          <line x1="50" y1="35" x2="70" y2="35"/> -- bird left wing
          <line x1="80" y1="35" x2="100" y2="35"/> -- bird right wing
         </g>
         <g style="stroke:]]..wp_color..[[;stroke-width:1;fill:none" transform="translate(]]..yaw_WP_hud..[[ 0)">
          <polyline points="75,65 80,70 75,75 70,70 75,65"/> -- Yaw WP
         </g>
         <g style="stroke:]]..wp_color..[[;stroke-width:1">
          <line x1="75" y1="70" x2="]]..(75 + yaw_WP_hud)..[[" y2="70"/> -- Destination Vector
         </g>
        </svg>
       ]]
      end

     --SVG SPACE ORIENTATION
      function space_orientation_svg()
       return [[
        <svg  width="100%" height="100%" viewbox="0 0 150 70" style="background-color:black">
         <g style="stroke:white;stroke-width:1;fill:none" transform="translate(]]..yaw_space_hud.." "..pitch_space_hud..[[)">
          <circle cx="75" cy="35" r="10" style=" stroke-width: 2"/> -- vector 0
          <circle cx="-105" cy="35" r="5" fill="white"/> -- vector 180 0
          <circle cx="255" cy="35" r="5" fill="white"/> -- vector -180 0
          <circle cx="75" cy="-145" r="5" fill="white"/> -- vector 0 180
          <circle cx="75" cy="215" r="5" fill="white"/> -- vector 0 -180
          <circle cx="255" cy="215" r="5" fill="white"/> -- vector -180 -180
          <circle cx="-105" cy="-145" r="5" fill="white"/> -- vector 180 180
          <circle cx="255" cy="-145" r="5" fill="white"/> -- vector -180 180
          <circle cx="-105" cy="215" r="5" fill="white"/> -- vector 180 -180

          <polyline points="75,-65 85,-55 75,-45 65,-55 75,-65"/> -- ortogonal 0 90
          <polyline points="75,115 85,125 75,135 65,125 75,115"/> -- ortogonal 0 -90
          <polyline points="-105,-65 -95,-55 -105,-45 -115,-55 -105,-65"/> -- ortogonal 180 90
          <polyline points="255,-65 265,-55 255,-45 245,-55 255,-65"/> -- ortogonal -180 90
          <polyline points="255,115 265,125 255,135 245,125 255,115"/> -- ortogonal -180 -90
          <polyline points="-105,115 -95,125 -105,135 -115,125 -105,115"/> -- ortogonal 180 -90

          <rect x="-25" y="25" width="20" height="20"/> -- Vector 90 0
          <rect x="155" y="25" width="20" height="20"/> -- Vector -90 0
          <rect x="-25" y="205" width="20" height="20"/> -- Vector 90 -180
          <rect x="155" y="-155" width="20" height="20"/> -- Vector -90 180
          <rect x="-25" y="-155" width="20" height="20"/> -- Vector 90 180
          <rect x="155" y="205" width="20" height="20"/> -- Vector -90 -180
         </g>

         <g style="stroke:white;stroke-width:1">
          <line x1="75" y1="35" x2="]]..(75 + yaw_space_hud)..[[" y2="]]..(35 + pitch_space_hud)..[["/> -- Velocity Vector
         </g>

         <g style="stroke:#00FFFF;stroke-width:1">
          <line x1="75" y1="35" x2="]]..(75 + yaw_WP_hud)..[[" y2="]]..(35 + pitch_WP_hud)..[["/> -- Destination Vector
         </g>

         <g style="stroke:#00FFFF;stroke-width:2;fill:none" transform="translate(]]..yaw_WP_hud.." "..pitch_WP_hud..[[)">
          <circle cx="75" cy="35" r="12"/> -- Destination
         </g>

         <g style="stroke:yellow;stroke-width:2">
          <line x1="65" y1="25" x2="85" y2="45"/> -- Pointer
          <line x1="65" y1="45" x2="85" y2="25"/> -- Pointer
         </g>

         <g style="font-size:12px">
          <text fill="white" x="5" y="20">]]..yaw_space_hud..[[
           <tspan x="5" y="35" fill="yellow">Yaw</tspan>
           <tspan x="5" y="50" fill="#00FFFF">]]..yaw_WP_hud..[[</tspan>
          </text>
          <text fill="white" x="120" y="20">]]..pitch_space_hud..[[
           <tspan x="120" y="35" fill="yellow">Pitch</tspan>
           <tspan x="120" y="50"  fill="#00FFFF">]]..pitch_WP_hud..[[</tspan>
          </text>
          <text fill="red" x="50%" y="90%" dominant-baseline="middle" text-anchor="middle">]]..align_active_mode..[[</text>
          <text fill="#00FFFF"  x="50%" y="10%" dominant-baseline="middle" text-anchor="middle">]]..adjusting_mode..[[</text>
         </g>
        </svg>
       ]]
      end

     --SVG ORBIT
      orbit_t_to_apo_seconds = 0
      ship_PPOS_svg = vec3(core.getConstructWorldPos())
      function f_orbit_svg()
       if orbit_period_seconds > 0 then
         map_scale_setting = 2500
         if scale == nil then
          scale = map_scale_setting
         end
         scale  = scale
         local fix = 80
         local OrbCx  = (orbit_per_alt + orbit_apo_alt + 2*planet_radius)/2/scale + fix
         local OrbRx  = OrbCx - fix
         local PlCx   = (OrbRx - ( orbit_ecc * OrbRx)) + fix
         local Plr = planet_radius/scale
         local OrbRy  = math.sqrt(OrbRx^2 - (orbit_ecc * OrbRx)^2)
         local ApCx   = OrbCx + OrbRx
         local ShCx1  = PlCx
         local ShCx2  = PlCx + my_planet_alt/scale
         local altitude = my_planet_alt - planet_radius
         local PeTargetAlt_svg = Plr + (PeTargetAlt/scale)

         local b = my_planet_alt/scale
         local c = (OrbCx - PlCx)*2
         local a = (OrbRx * 2) - b
         if orbit_t_to_apo ~= nil then
          if (orbit_period_seconds > 0 and orbit_t_to_apo ~= "n/a" and (orbit_t_to_apo_seconds / orbit_period_seconds) >= 0.5) then
           LineR = math.deg(math.acos((b^2 + c^2 - a^2) / (2 * b * c)))
           if (LineR ~= LineR and (orbit_t_to_apo_seconds / orbit_period_seconds) > 0.75) then
            LineR = 0
           elseif (LineR ~= LineR and (orbit_t_to_apo_seconds / orbit_period_seconds) < 0.75) then
            LineR = 180
           end
          else
           LineR = 360 - (math.deg(math.acos((b^2 + c^2 - a^2) / (2 * b * c))))
           if (LineR ~= LineR and (orbit_t_to_apo_seconds / orbit_period_seconds) > 0.25) then
            LineR = 180
           elseif (LineR ~= LineR and (orbit_t_to_apo_seconds / orbit_period_seconds) < 0.25) then
            LineR = 0
           end
          end
         end

         if orbit_per_alt < (PeTargetAlt - 1000) then
          OrbCo = [[ red ]]
         else
          OrbCo = [[#00FFFF]]
         end
         if orbit_ecc == 0 then
          orbit_Opacity = 0
         else
          orbit_Opacity = 100
         end

         if orbit_ecc < 1 then
          ship_PPOS_svg = vec3(core.getConstructWorldPos())
         end

         local OrbRy_max = 70
         local OrbRy_min = 35
         local ApCx_max = 330
         local ApCx_min = 200
         local min_scale = 1000

         if OrbRy > OrbRy_max then
          scale_O = scale*2
         end
         if OrbRy < OrbRy_max then
          if OrbRy < OrbRy_min then
           scale_O = scale/2
          else
           scale_O = scale
          end
         end

         if ApCx > ApCx_max then
          scale_A = scale*2
         end
         if ApCx < ApCx_max then
          if ApCx < ApCx_min then
           scale_A = scale/2
          else
           scale_A = scale
          end
         end

         scale = math.max(scale_O, scale_A, min_scale)

        return [[
         <svg width="360" height="150">
          <circle id="TargetPEAlt" cx="]]..PlCx..[[" cy="75" r="]]..PeTargetAlt_svg..[[" stroke-width="1" stroke="white" fill="none" />
          <circle id="Planet" cx="]]..PlCx..[[" cy="75" r="]]..Plr..[[" fill="darkslategrey" />
          <ellipse id="Orbit" cx="]]..OrbCx..[[" cy="75" rx="]]..OrbRx..[[" ry="]]..OrbRy..[[" style="fill:none;stroke:]]..OrbCo..[[;stroke-width:1;opacity:]]..orbit_Opacity..[[%" />
          <circle id="Pe" cx="]]..fix..[[" cy="75" r="3" stroke="green" stroke-width="1" fill="green" />
          <circle id="Ap" cx="]]..ApCx..[[" cy="75" r="3" stroke="green" stroke-width="2" fill="none" />
          <g transform=" rotate(]]..LineR.." "..ShCx1..[[ 75)">
           <line id="ship" x1="]]..ShCx1..[[" y1="75" x2="]]..ShCx2..[[" y2="75" stroke="yellow" stroke-width="2" opacity="100%"/>
          </g>
          <text x="10" y="20" fill="green" font-size="15px">Altitude:
           <tspan x="10" y="40" fill="yellow">]]..math.floor(altitude/1000*10)/10 ..[[</tspan><tspan fill="#00FFFF"> Km</tspan>
          </text>
          <text x="10" y="130" fill="green" font-size="15px">Circ Orb Speed:
           <tspan x="10" y="150" fill="yellow">]]..math.floor(orbit_circular_speed)..[[</tspan><tspan fill="#00FFFF"> m/s</tspan>
          </text>
          <text x="250" y="20" fill="green" font-size="15px">Map Scale:
           <tspan x="250" y="40" fill="yellow">]]..math.floor(scale)..[[</tspan>
          </text>
          <text x="250" y="130" fill="green" font-size="15px">Dist To PE:
           <tspan x="250" y="150" fill="yellow">]]..math.floor(pe_dis)..[[</tspan><tspan fill="#00FFFF"> Km</tspan>
          </text>
         </svg>
        ]]
       else
        return interplanet_svg()
       end
      end

     --SVG INTERPLANET
      nav_planet_scale = Planet_Scale_SPC_Mode
      function interplanet_svg()

       local myPos = vec3(core.getConstructWorldPos())

       if databank then
        if (databank.getNbKeys() ~= 0 and databank.getStringValue("navigator_from_coordinates") ~= "n/a" and databank.getStringValue("navigator_from") ~= "PPOS") then
         planet_A_coord = vec3FromStr(databank.getStringValue("navigator_from_coordinates"))
         from_name_hud = databank.getStringValue("navigator_from")
         planet_A_opacity = 100
         from_planet_radius = databank.getIntValue("navigator_from_planet_radius")
         planet_A_radius = (20 / nav_planet_scale)* from_planet_radius
         x1_path = 50 + planet_A_radius
         ship_x1 = 50 + planet_A_radius
         ship_x2 = 40 + planet_A_radius

        elseif (databank.getNbKeys() ~= 0 and databank.getStringValue("navigator_from_coordinates") ~= "n/a" and databank.getStringValue("navigator_from") == "PPOS") then
         planet_A_coord = vec3FromStr(databank.getStringValue("navigator_from_coordinates"))
         from_name_hud = "PPOS"
         planet_A_opacity = 0
         planet_A_radius = 20
         x1_path = 50
         ship_x1 = 50
         ship_x2 = 40
        else
         planet_A_coord = ship_PPOS_svg
         from_name_hud = "PPOS"
         planet_A_opacity = 0
         planet_A_radius = 20
         x1_path = 50
         ship_x1 = 50
         ship_x2 = 40
        end

        if (databank.getNbKeys() ~= 0 and databank.getStringValue("navigator_coordinates") ~= "n/a") then
         planet_B_coord = vec3FromStr(databank.getStringValue("navigator_coordinates"))
         to_name_hud = databank.getStringValue("navigator_target_destination")
         to_planet_radius = databank.getIntValue("navigator_target_planet_radius")
         planet_B_radius = (20 / nav_planet_scale)* to_planet_radius
         x2_path = 310 - planet_B_radius
        else
         planet_B_coord = planet_pos
         to_name_hud = planet_name
         to_planet_radius = planet_radius
         planet_B_radius = (20 / nav_planet_scale)* to_planet_radius
         x2_path = 310 - planet_B_radius
        end
       else
        planet_A_coord = ship_PPOS_svg
        from_name_hud = "PPOS"
        planet_A_opacity = 0
        planet_B_coord = planet_pos
        to_name_hud = planet_name
        to_planet_radius = planet_radius
        planet_B_radius = (20 / nav_planet_scale)* to_planet_radius
        x2_path = 310 - planet_B_radius

        x1_path = 50
        planet_A_radius = 20
        ship_x1 = 50
        ship_x2 = 40
       end -- if databank

       distance_PPOS_B_hud = math.floor(((planet_B_coord - myPos):len())/1000/200*100)/100
       local distance_PPOS_A_hud = math.floor(((planet_A_coord - myPos):len())/1000/200*100)/100

       local ATA_h = (((planet_B_coord - myPos):len())/1000) / speed_hud -- Hours
       local ATA_m = (ATA_h - math.floor(ATA_h))*60
       local ATA_s = (ATA_m - math.floor(ATA_m))*60
       local ATA_hud = math.floor(ATA_h) ..":".. math.floor(ATA_m) ..":".. math.floor(ATA_s)
       if speed_hud == 0 then
        ATA_hud = "n/a"
       end

       local tot_distance = distance_PPOS_A_hud + distance_PPOS_B_hud

       x1_x2_path = x2_path - x1_path

       if from_name_hud == "PPOS" then
        ship_pos_svg = x1_x2_path - (distance_PPOS_B_hud / tot_distance)*x1_x2_path
        if (distance_PPOS_B_hud / tot_distance) > 0.5 then
         ship_pos_svg = ship_pos_svg + ((to_planet_radius/1000/200) / tot_distance)*x1_x2_path
        else
         ship_pos_svg = ship_pos_svg
        end
       elseif from_name_hud ~= "PPOS" then
        ship_pos_svg = (distance_PPOS_A_hud / tot_distance)*x1_x2_path
        if (distance_PPOS_A_hud / tot_distance) < 0.5 then
         ship_pos_svg = ship_pos_svg - ((from_planet_radius/1000/200) / tot_distance)*x1_x2_path
        else
         ship_pos_svg = ship_pos_svg
        end
       end

       return [[
        <svg width="360" height="150">
         <line id="Path" x1="]]..x1_path..[[" y1="55" x2="]]..x2_path..[[" y2="55" stroke="yellow" stroke-width="1"/>

         <circle id="Planet_A" cx="50" cy="55" r="]]..planet_A_radius..[[" style="fill:darkslategrey;stroke:#00FFFF;stroke-width:1;opacity:]]..planet_A_opacity..[[" />
         <circle id="Planet_B" cx="310" cy="55" r="]]..planet_B_radius..[[" style="fill:darkslategrey;stroke:#00FFFF;stroke-width:1;" />

         <g transform="translate(]]..ship_pos_svg..[[ 0)">
          <polygon points="]]..ship_x1..[[,55 ]]..ship_x2..[[,63 ]]..ship_x2..[[,47" style="fill:#00FFFF;stroke:green;stroke-width:1;fill-rule:evenodd" />
         </g>
         <text x="10" y="15" fill="green" font-size="14px">From:
          <tspan x="10" y="30" fill="#00FFFF">]]..from_name_hud..[[</tspan>
         </text>
         <text x="140" y="15" fill="green" font-size="14px">Dist:
          <tspan x="140" y="30" fill="yellow">]]..tot_distance..[[</tspan><tspan fill="#00FFFF"> Su</tspan>
         </text>
         <text x="250" y="15" fill="green" font-size="14px">To:
          <tspan x="250" y="30" fill="#00FFFF">]]..to_name_hud..[[</tspan>
         </text>
         <text x="10" y="90" fill="green" font-size="14px">Dist:
          <tspan x="10" y="105" fill="yellow">]]..distance_PPOS_A_hud..[[</tspan><tspan fill="#00FFFF"> Su</tspan>
         </text>
         <text x="140" y="90" fill="green" font-size="14px">ATA:
          <tspan x="140" y="105" fill="yellow">]]..ATA_hud..[[</tspan>
         </text>
         <text x="250" y="90" fill="green" font-size="14px">Dist:
          <tspan x="250" y="105" fill="yellow">]]..distance_PPOS_B_hud..[[</tspan><tspan fill="#00FFFF"> Su</tspan>
         </text>
         <text x="10" y="130" fill="green" font-size="14px">Circ Orb Speed:
          <tspan x="10" y="145" fill="yellow">]]..math.floor(orbit_circular_speed)..[[</tspan><tspan fill="#00FFFF"> m/s</tspan>
         </text>
         <text x="250" y="130" fill="green" font-size="14px">Dist To PE:
          <tspan x="250" y="145" fill="yellow">]]..math.floor(pe_dis)..[[</tspan><tspan fill="#00FFFF"> Km</tspan>
         </text>
        </svg>
       ]]
      end

    --HTML SCREENS
     --CSS
      function html_style()
       local css = [[
       <style>
       .helper_div {position:absolute;top:30vh;left:35vw;}
       .rh_m_div {position:absolute;bottom:2vh;right:14vw}
       .lh_m_div {position:absolute;bottom:2vh;left:26vw;}
       .top_lh_div {position:absolute;top:50vh;left:2vw;}
       .top_rh_div{position:absolute;top:50vh;right:14vw;}
       .tbl {border:1px solid yellow;text-align:center;vertical-align:middle;color:yellow;font-size: 12px;}
       .helper_tbl {border:1px solid yellow;text-align:left;color:yellow;font-family:arial;font-size:12px;}
       .top {vertical-align:top;}
       .txcx {text-align:center;}
       .ecam {vertical-align:top;border: 1px solid slategray;text-align:left;}
       .ecam_rec {color:slategray;}
       .green {color:green;}
       .lgt_green {color:#7FFF00;}
       .yellow {color:yellow;}
       .red {color:red;}
       .rdr_hud {text-align:center;vertical-align:top;font-size: 9px;}
       .tomato{color:#ff3333;}
       .white {color:white;}
       .svg_box {border:1px solid #00FFFF;}
       .cyan {color:#00FFFF;}
       .left {text-align:left;}
       .right {text-align:right;}
       .f_right {float:right;}
       .px10 {font-size:10px;}
       .px16 {font-size:16px;}
       .an_lgt {border:1px solid slategray;}
       .ldmg {color:LightYellow;}
       .mdmg {color:gold;}
       .hdmg {color:DarkOrange;}
       .dead {color:Red;}
       .r {color:white;}
       </style>]]
       return css
      end
     --RIGHT MONITOR
      function monitor_right()
       local right_monitor_html = html_style()
       right_monitor_html = right_monitor_html..[[
       <div class="rh_m_div"><div class="window tbl"><table class="tbl">
       <tr height="30vh" class="green"><th width="40vw">Speed</th><td width="1vw" rowspan="5"></td><th width="40vw">Pitch</th><td width="1vw" rowspan="2"></td><th width="40vw">Roll</th><td width="1vw" rowspan="5"></td><th class="green left" width="70vw" colspan="2"><span class="yellow">]]..a_fuel_tank_n..[[</span>&nbspA F T</th><th class="green left" width="70vw" colspan="2"><span class="yellow">]]..s_fuel_tank_n..[[</span>&nbspS F T</th><th class="green left" width="70vw" colspan="2"><span class="yellow">]]..r_fuel_tank_n..[[</span>&nbspR F T</th></tr>
       <tr height="30vh"><td>]]..speed_hud..[[</td><td>]]..pitch_hud..[[</td><td>]]..roll_direction..[[</td><td width="30vw">]]..a_fuel_percent_avg_hud..[[</td><td width="40vw">%</td><td width="30vw">]]..s_fuel_percent_avg_hud..[[</td><td width="40vw">%</td><td width="30vw">]]..r_fuel_percent_avg_hud..[[</td><td width="40vw">%</th></tr>
       <tr height="30vh"><td class="cyan">]]..thr..[[&nbsp%</td><td colspan="3">]]..radar_warning_hud..[[</td><td class="svg_box" rowspan="3">]]..a_fuel_svg()..[[</td><td>]]..math.floor(a_t_h)..[[</td><td class="svg_box" rowspan="3">]]..s_fuel_svg()..[[</td><td>]]..math.floor(s_t_h)..[[</td><td class="svg_box" rowspan="3">]]..r_fuel_svg()..[[</td><td>]]..math.floor(r_t_h)..[[</td></tr>
       <tr height="30vh"><td class="svg_box" rowspan="2">]]..thr_svg()..[[</td><td class="green left" colspan="3">&nbspAlt&nbsp&nbsp<span class="yellow right">]]..altitude..[[</span>&nbsp</td><td>]]..math.floor(a_t_m)..[[</td><td>]]..math.floor(s_t_m)..[[</td><td>]]..math.floor(r_t_m)..[[</td></tr>
       <tr height="30vh"><td class="green left" colspan="3">&nbspV/S&nbsp&nbsp<span class="yellow right">]]..vs_hud..[[</span>&nbsp</td><td>]]..math.floor(a_t_s)..[[</td><td>]]..math.floor(s_t_s)..[[</td><td>]]..math.floor(r_t_s)..[[</td></tr>
       </table></div></div>]]
       return right_monitor_html
      end
     --HELPER
       function monitor_helper()
        local helper_monitor_html = html_style()
        helper_monitor_html = helper_monitor_html..[[
        <div class="window helper_div"><table width="600vw" class="helper_tbl">
         <tr height="25vh"><td width="5vw" rowspan="20"></td><td colspan="2" class="cyan txcx">When you don't need this Helper anymore remove it from Lua Parameters</td></tr>
         <tr height="25vh"><td colspan="2" class="txcx cyan">Flight Modes</td></tr>
         <tr height="25vh"><td>ALT+1</td><td class="white"><span class="cyan">LOAD</span> Mode (Loading)</td></tr>
         <tr height="25vh"><td>ALT+2</td><td class="white"><span class="cyan">AI</span> Mode (Attitude Indicator)</td></tr>
         <tr height="25vh"><td>ALT+3</td><td class="white"><span class="cyan">SPC</span> Mode (Space operations)</td></tr>
         <tr height="25vh"><td>ALT+4</td><td class="white"><span class="cyan">ORB</span> Mode (Orbit operations)</td></tr>
         <tr height="25vh"><td>ALT+5</td><td class="white"><span class="cyan">DMG</span> Mode (Damages Report)</td></tr>
         <tr height="25vh"><td colspan="2" class="txcx cyan">Autoflight System <span class="white">(Can activate if in <span class="yellow">SPC</span> or <span class="yellow">ORB</span> Mode)</span></td></tr>
         <tr height="25vh"><td>ALT+6 (First press)</td><td class="white"><span class="cyan">Mode 1:</span> ProGrade Alignment</td></tr>
         <tr height="25vh"><td>ALT+6 (Second press)</td><td class="white"><span class="cyan">Mode 2:</span> 3 seconds to ARM Maintaining Orbit (Engage if an orbit is achieved)</td></tr>
         <tr height="25vh"><td>ALT+6 (Third press)</td><td class="white"><span class="cyan">Mode 3:</span> 3 seconds to Align to Destination</td></tr>
         <tr height="25vh"><td>ALT+6 (Fourth press)</td><td class="white">To Disengage</td></tr>
         <tr height="25vh"><td colspan="2" class="txcx cyan">Brake System</td></tr>
         <tr height="25vh"><td>ALT+7</td><td class="white">Parking Brake if in <span class="yellow">LOAD</span> or <span class="yellow">AI</span> Mode</td></tr>
         <tr height="25vh"><td>ALT+7</td><td class="white">Autobrake Brake if in <span class="yellow">SPC</span> Mode</td></tr>
         <tr height="25vh"><td colspan="2" class="txcx cyan">DU Widgets</td></tr>
         <tr height="25vh"><td>ALT+8</td><td class="white">Show/Hide Radar Widgets</td></tr>
         <tr height="25vh"><td>ALT+9</td><td class="white">Show/Hide Widgets</td></tr>
         <tr height="25vh"><td colspan="2" class="red txcx px16">To Close the Helper SET or REMOVE Prarking Brake <span class="yellow">ALT+7</span></td></tr>
         <tr height="25vh"><td colspan="2" class="white">For more info visit https://github.com/Aviator1280/Aviator1280-Dual-Universe-HUD</td></tr>
        </table></div>]]
        return helper_monitor_html
       end

     --OPTION 1 (Loading page)
      function monitor_left_loading()
       local load_monitor_html = html_style()
       load_monitor_html = load_monitor_html..[[
       <div class="lh_m_div"><div class="window tbl"><table class="tbl">
        <tr height="25vh"><td width="1vw" rowspan="6"></td><td class="green" colspan="3">Annunciator Lights</td><td width="1vw" rowspan="6"></td><td class="tbl">LOAD</td><th class="tbl green" colspan="4" width="180vw">LOAD&nbsp&nbspDOW:&nbsp&nbsp<span class="yellow">]]..dow_m..[[</span>&nbsp<span class="cyan">t</span></th></tr>
        <tr height="25vh"><td width="40vw" class="an_lgt" style="color:]]..ldg_st..[[">LDG</td><td width="40vw" class="an_lgt" style="color:]]..lights_st_hud..[["></td><td width="40vw" class="an_lgt" style="color:]]..r_active_hud..[[">ROCKET</td><td width="50vw" class="tbl cyan">AI</td><td class="left green">&nbspLOAD</td><td class="right">]]..cargo_m_t_hud..[[<span class="cyan">&nbspt&nbsp</span></td><td width="10vw" rowspan="4"></td><td width="30vw" class="px10 green">MTOW<br><span class="cyan">&nbsp]]..math.floor(MTOW/1000*10)/10 ..[[&nbspt</span></td></tr>
        <tr height="25vh"><td class="an_lgt">]]..a_fuelspy_hud..[[</td><td class="an_lgt">]]..s_fuelspy_hud..[[</td><td class="an_lgt">]]..r_fuelspy_hud..[[</td><td class="tbl cyan">SPC</td><td class="left green">&nbspZFW</td><td class="right">]]..zfw_m..[[<span class="cyan">&nbspt&nbsp</span></td><td>]]..MTOW_p..[[&nbsp%</td></tr>
        <tr height="25vh"><td class="tbl ecam" rowspan="3" colspan="3">]]..ECAM()..[[</td><td class="tbl cyan">ORB</td><td class="left green">&nbsp Fuel</td><td class="right">]]..fuel_mass..[[<span class="cyan">&nbspt&nbsp</span></td><td class="svg_box" rowspan="2">]]..MTOW_svg()..[[</td></tr>
        <tr height="25vh"><td class="tbl" style="color:]]..dmg_color..[[">DMG</td><td class="left green">&nbspGW</td><td class="right">]]..gw_m..[[<span class="cyan">&nbspt&nbsp</span></td></tr>
        <tr><td class="tbl" colspan="5"></td></tr>
       </table></div></div>]]
       return load_monitor_html
      end
     --OPTION 2 (AI page)
      function monitor_left_atmo()
       local ai_monitor_html = html_style()
       ai_monitor_html = ai_monitor_html..[[
       <div class="lh_m_div"><div class="window tbl"><table class="tbl">
        <tr height="25vh"><td width="1vw" rowspan="6"></td><td class="green" colspan="3">Annunciator Lights</td><td width="1vw" rowspan="6"></td><td class="tbl cyan">LOAD</td><th class="tbl green" colspan="2" width="180vw">AI&nbsp&nbsp<span class="yellow">]]..acc_hud..[[</span>&nbsp<span class="cyan">g</span></th></tr>
        <tr height="25vh"><td width="40vw" class="an_lgt" style="color:]]..ldg_st..[[">LDG</td><td width="40vw" class="an_lgt" style="color:]]..lights_st_hud..[["></td><td width="40vw" class="an_lgt" style="color:]]..r_active_hud..[[">ROCKET</td><td width="50vw" class="tbl">AI</td><td><span class="px10">WP at&nbsp</span><span class="white">]]..distance_to_wp..[[&nbsp</span><span class="cyan">Km</span></td><td class="red">]]..radioalt_hud..[[</td></tr>
        <tr height="25vh"><td class="an_lgt">]]..a_fuelspy_hud..[[</td><td class="an_lgt">]]..s_fuelspy_hud..[[</td><td class="an_lgt">]]..r_fuelspy_hud..[[</td><td class="tbl cyan">SPC</td><td colspan="2" rowspan="3">]]..art_h_svg()..[[</td></tr>
        <tr height="25vh"><td class="tbl ecam" rowspan="3" colspan="3">]]..ECAM()..[[</td><td class="tbl cyan">ORB</td></tr>
        <tr height="25vh"><td class="tbl" style="color:]]..dmg_color..[[">DMG</td></tr>
        <tr><td class="tbl" colspan="3"></td></tr>
       </table></div></div>]]
       return ai_monitor_html
      end
     --OPTION 3 (Space page)
      function monitor_left_space()
       final_speed_brk = 0
       local space_monitor_html = html_style()
       local space_monitor_html = space_monitor_html..[[
       <div class="top_lh_div"><div class="window tbl"><table width="360vw">
        <tr height="30vh" class="px16"><td width="1vw" rowspan="5"></td><td class="green left" colspan="3">From:&nbsp<span class="cyan">]]..navigator_from_hud..[[</span>&nbspTo:&nbsp<span class="cyan">]]..navigator_target_destination_hud..[[</span></td></tr>
        <tr height="30vh"><th class="green">Dist.</th><td>]]..navigator_distance_hud..[[<span class="cyan">&nbspSu</span></td><td colspan="2" rowspan="4" width="180vw" height="120vh">]]..space_orientation_svg()..[[</td></tr>
        <tr height="30vh"><th class="green">Speed:</th><td>]]..navigator_speed_hud..[[<span class="cyan">&nbspKm/h</span></td></tr>
        <tr height="30vh"><th class="green">Time:</th><td>]]..navigator_eta_hud..[[</td></tr>
        <tr height="30vh"><th class="green">Warp C.</th><td>]]..math.floor((core.getConstructMass()/1000)*navigator_distance_hud*0.00025)..[[</td></tr>
       </table></div></div>
       <div class="top_rh_div"><div class="window tbl"><table>
        <tr height="150vh"><td width="360vw">]]..interplanet_svg()..[[<td></tr>
        <tr><td>&nbspAuto Brake in:&nbsp<span class="white">]]..autobrake_in..[[</span>&nbsp<span class="cyan">Su</span> - <span class="white">]]..autobrake_stops_at..[[</span>&nbsp<span class="cyan">Su</span>&nbspFrom Dest.</td></tr>
       </table></div></div>
       <div class="lh_m_div"><div class="window tbl"><table class="tbl">
        <tr height="25vh"><td width="1vw" rowspan="6"></td><td class="green" colspan="3">Annunciator Lights</td><td width="1vw" rowspan="6"></td><td class="tbl cyan">LOAD</td><th class="tbl green" colspan="2" width="180vw">Space</th></tr>
        <tr height="25vh"><td width="40vw" class="an_lgt" style="color:]]..ldg_st..[[">LDG</td><td width="40vw" class="an_lgt" style="color:]]..lights_st_hud..[["></td><td width="40vw" class="an_lgt" style="color:]]..r_active_hud..[[">ROCKET</td><td width="50vw" class="tbl cyan">AI</td><td class="green">Braking</td><td>]]..rrThrust_hud..[[<span class="cyan">&nbspkN</span></td></tr>
        <tr height="25vh"><td class="an_lgt">]]..a_fuelspy_hud..[[</td><td class="an_lgt">]]..s_fuelspy_hud..[[</td><td class="an_lgt">]]..r_fuelspy_hud..[[</td><td class="tbl">SPC</td><td class="green">Stop in:</td><td>]]..brake_su..[[<span class="syan">&nbspSu</span></td></tr>
        <tr height="25vh"><td class="tbl ecam" rowspan="3" colspan="3">]]..ECAM()..[[</td><td class="tbl cyan">ORB</td><td></td><td>]]..brake_km..[[<span class="cyan">&nbspKm</span></td></tr>
        <tr height="25vh"><td td class="tbl" style="color:]]..dmg_color..[[">DMG</td><td></td><td>]]..brake_min..[[<span class="cyan">'&nbsp</span>]]..brake_sec..[[<span class="cyan">"</span></td></tr>
        <tr><td class="tbl" colspan="3"></td></tr>
       </table></div></div>]]
       return space_monitor_html
      end
     --OPTION 4 (Orbit page)
      function monitor_left_orbit()
       final_speed_brk = (orbit_circular_speed)/1000*60*60
       local orbit_monitor_html = html_style()
       orbit_monitor_html = orbit_monitor_html..[[
       <div class="top_lh_div"><div class="window tbl"><table class="left">
        <tr height="30vh" class="px16"><td width="1vw" rowspan="5"></td><th width="360vw" colspan="4" class="green">ORBIT&nbsp&nbsp<span class="cyan">]]..planet_name..[[&nbsp&nbsp</span><span class="yellow">]]..math.floor(my_planet_alt/1000/200*100)/100 ..[[</span><span class="cyan">&nbsp&nbspSu</span></th></tr>
        <tr height="30vh"><td class="green">ECC</td><td>]]..orbit_ecc..[[</td><td class="green">T</td><td>]]..orbit_period..[[</td></tr>
        <tr height="30vh"><td class="green">PE Alt</td><td>]]..orbit_per_alt..[[&nbsp<span class="cyan">m</span></td><td class="green">AP Alt</td><td>]]..orbit_apo_alt..[[&nbsp<span class="cyan">m</span></td></tr>
        <tr height="30vh"><td class="green">PE Speed</td><td>]]..orbit_per_speed..[[&nbsp<span class="cyan">m/s</span></td><td class="green">AP Speed</td><td>]]..orbit_apo_speed..[[&nbsp<span class="cyan">m/s</span></td></tr>
        <tr height="30vh"><td class="green">T to PE</td><td>]]..orbit_t_to_per..[[</td><td class="green">T to AP</td><td>]]..orbit_t_to_apo..[[</td></tr>
       </table></div></div>
       <div class="top_rh_div"><div class="window tbl"><table>
        <tr height="150vh"><td width="360vw">]]..f_orbit_svg()..[[<td></tr>
        <tr><td class="left">&nbspTarget PE Altitude&nbsp<span class="white">]]..PeTargetAlt..[[</span>&nbsp<span class="cyan">m</span></td></tr>
       </table></div></div>
       <div class="lh_m_div"><div class="window tbl"><table class="tbl">
        <tr height="25vh"><td width="1vw" rowspan="6"></td><td class="green" colspan="3">Annunciator Lights</td><td width="1vw" rowspan="6"></td><td class="tbl cyan">LOAD</td><th class="tbl green" colspan="2" width="180vw">Orbit&nbsp&nbsp<span class="yellow">]]..math.floor(speed_hud/3.6)..[[</span><span class="cyan">&nbspm/s</span></tr>
        <tr height="25vh"><td width="40vw" class="an_lgt" style="color:]]..ldg_st..[[">LDG</td><td width="40vw" class="an_lgt" style="color:]]..lights_st_hud..[["></td><td width="40vw" class="an_lgt" style="color:]]..r_active_hud..[[">ROCKET</td><td width="50vw" class="tbl cyan">AI</td><td class="green">Brake in:</td><td>]]..brake_km..[[&nbsp<span class="cyan">Km</span></td></tr>
        <tr height="25vh"><td class="an_lgt">]]..a_fuelspy_hud..[[</td><td class="an_lgt">]]..s_fuelspy_hud..[[</td><td class="an_lgt">]]..r_fuelspy_hud..[[</td><td class="tbl cyan">SPC</td><td colspan="2" rowspan="3"  width="180vw" height=" 75vh">]] .. space_orientation_svg() .. [[</td></tr>
        <tr height="25vh"><td class="tbl ecam" rowspan="3" colspan="3">]]..ECAM()..[[</td><td class="tbl">ORB</td></tr>
        <tr height="25vh"><td td class="tbl" style="color:]]..dmg_color..[[">DMG</td></tr>
        <tr><td class="tbl" colspan="3"></td></tr>
       </table></div></div>]]
       return orbit_monitor_html
      end
     --OPTION 5 (Damage page)
      function monitor_left_damage()
       damage_html = dmgrep:renderHTML()
       local dmg_table_html = dead_elem_list_hud..high_damage_list_hud..medium_damage_list_hud..light_damage_list_hud
       local dmg_monitor_html = html_style()
       dmg_monitor_html = dmg_monitor_html..[[
       <div class="top_lh_div"><div class="window tbl"><table>
        <tr height="150vh"><td width="360vw">TOP VIEW<hr>]]..top_view_html_hud..[[</td></tr>
       </table></div></div>
       <div class="top_rh_div"><div class="window tbl"><table>
        <tr height="150vh"><td width="360vw">SIDE VIEW<hr>]]..side_view_html_hud..[[</td></tr>
       </table></div></div>
       <div class="lh_m_div"><div class="window tbl"><table class="tbl">
        <tr height="25vh"><td width="1vw" rowspan="6"></td><td class="green" colspan="3">Annunciator Lights</td><td width="1vw" rowspan="6"></td><td class="tbl cyan">LOAD</td><td width="180vw" class="tbl tomato">Damages Report</td></tr>
        <tr height="25vh"><td width="40vw" class="an_lgt" style="color:]]..ldg_st..[[">LDG</td><td width="40vw" class="an_lgt" style="color:]]..lights_st_hud..[["></td><td width="40vw" class="an_lgt" style="color:]]..r_active_hud..[[">ROCKET</td><td width="50vw" class="tbl cyan">AI</td><td rowspan="4" height="75vh" class="top left">]]..dmg_table_html..[[</td></tr>
        <tr height="25vh"><td class="an_lgt">]]..a_fuelspy_hud..[[</td><td class="an_lgt">]]..s_fuelspy_hud..[[</td><td class="an_lgt">]]..r_fuelspy_hud..[[</td><td class="tbl cyan">SPC</td></tr>
        <tr height="25vh"><td class="tbl ecam" rowspan="3" colspan="3">]]..ECAM()..[[</td><td class="tbl cyan">ORB</td></tr>
        <tr height="25vh"><td td class="tbl">DMG</td></tr>
        <tr><td class="tbl" colspan="2"></td></tr>
       </table></div></div>]]
       return dmg_monitor_html
      end

    --HTML ASSEMBLER
     function html_assemble()

      air_data()

      left_panel = monitor_left_loading()
      right_panel = monitor_right()
      helper_panel = monitor_helper()

      if Helper == true then
       hud = helper_panel
      else
       hud = ""
      end
      hud = hud .. right_panel
      hud = hud .. left_panel

      system.setScreen(hud)

      system.showScreen(1)

     end -- function html_assemble()
     html_assemble()

    --TIMER
     unit.setTimer("loading_pg", 1/30)
  tick:
   args: [loading_pg]
   lua: |
    --FUEL WARNINGS CAUTIONS
     atmo_fuel_percent()
     if spacefueltank_size ~= 0 then
      space_fuel_percent()
     end
     if rocketfueltank_size ~= 0 then
     rocket_fuel_percent()
     end
     a_fuel_minimum_time()
     if spacefueltank_size ~= 0 then
      s_fuel_minimum_time()
     end
     if rocketfueltank_size ~= 0 then
     r_fuel_minimum_time()
     r_warning_light()
     end
     avg_fuel_percentage()

    --LANDING GEAR
     landing_gear()

    --LIGHTS
     f_lights_st()

    --CARGO
     f_loading_data()

    --GW, ZFW, DOW
     gw_m = math.floor(core.getConstructMass()/1000*10)/10
     zfw_m = gw_m - fuel_mass
     dow_m = gw_m - fuel_mass - cargo_m_t

    --MTOW Percent
     MTOW_p = math.floor(gw_m*1000/MTOW*100)

    --FUEL MASS
     total_fuel_mass()

    --CHECK FOR DAMAGES
     dmg_checker()

    --RADAR
     radar_contacts()

    --SCREEN ASSEMBLER
     left_panel = monitor_left_loading()
     right_panel = monitor_right()
     helper_panel = monitor_helper()

     if Helper == true then
      hud = helper_panel
     else
      hud = ""
     end
     hud = hud .. right_panel
     hud = hud .. left_panel
    system.setScreen(hud)
  tick:
   args: [atmo_pg]
   lua: |
    --FUEL WARNINGS CAUTIONS
     atmo_fuel_percent()
     if spacefueltank_size ~= 0 then
      space_fuel_percent()
     end
     if rocketfueltank_size ~= 0 then
     rocket_fuel_percent()
     end
     a_fuel_minimum_time()
     if spacefueltank_size ~= 0 then
      s_fuel_minimum_time()
     end
     if rocketfueltank_size ~= 0 then
     r_fuel_minimum_time()
     r_warning_light()
     end
     avg_fuel_percentage()
    --LANDING GEAR
     landing_gear()
    --LIGHTS
     f_lights_st()
    --CHECK FOR DAMAGES
     dmg_checker()
    --RADIO ALTIMITER
     f_radioalt_hud()
    --DISTANCE TO WP FOR AI
     distance_to_wp_ai()
    --SPACE ORIENTATION
     space_orientation()
    --ACCELERATION
     acc_hud = math.floor(vec3(core.getWorldAcceleration()):len()/9.8*10)/10
    --RADAR
     radar_contacts()
    --SCREEN ASSEMBLER
     left_panel = monitor_left_atmo()
     hud = right_panel
     hud = hud .. left_panel
     system.setScreen(hud)
  tick:
   args: [orbit_pg]
   lua: |
    --FUEL WARNINGS CAUTIONS
     atmo_fuel_percent()
     if spacefueltank_size ~= 0 then
      space_fuel_percent()
     end
     if rocketfueltank_size ~= 0 then
     rocket_fuel_percent()
     end
     a_fuel_minimum_time()
     if spacefueltank_size ~= 0 then
      s_fuel_minimum_time()
     end
     if rocketfueltank_size ~= 0 then
     r_fuel_minimum_time()
     r_warning_light()
     end
     avg_fuel_percentage()
    --LANDING GEAR
     landing_gear()
    --LIGHTS
     f_lights_st()
    --CHECK FOR DAMAGES
     dmg_checker()
    --RETRO ROCKET
     f_rrThrust_hud()
    --BRAKING DISTANCE
     braking_distance()
    --ORBITAL DATA
     orbital_data()
    --SPACE ORIENTATION
     space_orientation()
    --SPACE DATA
     databank_condition()
    --RADAR
     radar_contacts()
    --SCREEN ASSEMBLER
     left_panel = monitor_left_orbit()
     hud = right_panel
     hud = hud .. left_panel
     system.setScreen(hud)
  tick:
   args: [space_pg]
   lua: |
    --FUEL WARNINGS CAUTIONS
     atmo_fuel_percent()
     if spacefueltank_size ~= 0 then
      space_fuel_percent()
     end
     if rocketfueltank_size ~= 0 then
     rocket_fuel_percent()
     end
     a_fuel_minimum_time()
     if spacefueltank_size ~= 0 then
      s_fuel_minimum_time()
     end
     if rocketfueltank_size ~= 0 then
     r_fuel_minimum_time()
     r_warning_light()
     end
     avg_fuel_percentage()
    --LANDING GEAR
     landing_gear()
    --LIGHTS
     f_lights_st()
    --CHECK FOR DAMAGES
     dmg_checker()
    --RETRO ROCKET
     f_rrThrust_hud()
    --ORBITAL DATA
     orbital_data()
    --BRAKING DISTANCE
     braking_distance()
    --AUTOBRAKE SETTING
     if databank then
      if databank.getFloatValue("navigator_autobrake") ~= nil then
       autobrake_stops_at = databank.getFloatValue("navigator_autobrake")
      else
       autobrake_stops_at = 2.3
      end
       else
      autobrake_stops_at = 2.3
     end
    --SPACE ORIENTATION
     space_orientation()
    --SPACE DATA
     databank_condition()
    --RADAR
     radar_contacts()
    --SCREEN ASSEMBLER
     left_panel = monitor_left_space()
     hud = right_panel
     hud = hud .. left_panel
     system.setScreen(hud)
  tick:
   args: [damage_pg]
   lua: |
    --FUEL WARNINGS CAUTIONS
     atmo_fuel_percent()
     if spacefueltank_size ~= 0 then
      space_fuel_percent()
     end
     if rocketfueltank_size ~= 0 then
     rocket_fuel_percent()
     end
     a_fuel_minimum_time()
     if spacefueltank_size ~= 0 then
      s_fuel_minimum_time()
     end
     if rocketfueltank_size ~= 0 then
     r_fuel_minimum_time()
     r_warning_light()
     end
     avg_fuel_percentage()
    --LANDING GEAR
     landing_gear()
    --LIGHTS
     f_lights_st()
    --RADAR
     radar_contacts()
    --SCREEN ASSEMBLER
     left_panel = monitor_left_damage()
     hud = right_panel
     hud = hud .. left_panel
     system.setScreen(hud)
  tick:
   args: [autobrake]
   lua: |
    --AUTOBRAKE
     autobrake_function()
  tick:
   args: [maintaning_orbit]
   lua: |
    --MAINTAINING ORBIT
     maintaining_orbit()
  tick:
   args: [delay3sec]
   lua: |
    --3 SECONDS DELAY
     if (autopilot_ecam_mode == [[Autopilot ON - Mode 2]]) then
      orbiting_mode_delay()
     elseif (autopilot_ecam_mode == [[Autopilot ON - Mode 3]]) then
      destination_mode_delayed()
     end
  tick:
   args: [countdown]
   lua: |
    --3 SECONDS COUNTDOWN
     if (autopilot_ecam_mode == [[Autopilot ON - Mode 2]]) then
      time_to_align = time_to_align - 1
      adjusting_mode = [[Mainteining Orbit in: ]] .. time_to_align
     elseif (autopilot_ecam_mode == [[Autopilot ON - Mode 3]]) then
      time_to_align = time_to_align - 1
      adjusting_mode = [[Align to DEST in: ]] .. time_to_align
     end
  stop:
   lua: |
    _autoconf.hideCategoryPanels()
    if antigrav ~= nil then antigrav.hide() end
    if warpdrive ~= nil then warpdrive.hide() end
    if gyro ~= nil then gyro.hide() end
    core.hide()
    Nav.control.switchOffHeadlights()

    system.showScreen(0)
 system:
  flush:
   lua: |
    -- constants
    local pitchSpeedFactor = 0.8
    local yawSpeedFactor =  1
    local rollSpeedFactor = 1.5
    local brakeSpeedFactor = 3
    local brakeFlatFactor = 1 --export: Increase the brake force (between 0.01 and 1)
    local autoRoll = false
    local autoRollFactor = 2
    local turnAssist = true
    local turnAssistFactor = 2
    local torqueFactor = 2 --export
    -- validate params
    pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
    yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
    rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
    torqueFactor = math.max(torqueFactor, 0.01)
    brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
    brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
    autoRollFactor = math.max(autoRollFactor, 0.01)
    turnAssistFactor = math.max(turnAssistFactor, 0.01)
    -- final inputs
    local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
    local finalRollInput = rollInput + system.getControlDeviceYawInput()
    local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
    local finalBrakeInput = brakeInput
    -- Axis
    local worldVertical = vec3(core.getWorldVertical())
    local constructUp = vec3(core.getConstructWorldOrientationUp())
    local constructForward = vec3(core.getConstructWorldOrientationForward())
    local constructRight = vec3(core.getConstructWorldOrientationRight())
    local constructVelocity = vec3(core.getWorldVelocity())
    local constructVelocityDir = vec3(core.getWorldVelocity()):normalize()
    local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
    local currentRollDegAbs = math.abs(currentRollDeg)
    local currentRollDegSign = utils.sign(currentRollDeg)
    -- Rotation
    local constructAngularVelocity = vec3(core.getWorldAngularVelocity())
    local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
            + finalRollInput * rollSpeedFactor * constructForward
            + finalYawInput * yawSpeedFactor * constructUp
    -- In atmosphere?
    if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
     local autoRollRollThreshold = 1.0
     -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
     if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
      local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);
      if (rollPID == nil) then
       rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1)
      end
      rollPID:inject(targetRollDeg - currentRollDeg)
      local autoRollInput = rollPID:get()
      targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
     end
     local turnAssistRollThreshold = 20.0
     -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
     if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
      local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
      local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range
      -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
      local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
      local rollVerticalRatio = 0
      if rescaleRollDegAbs < 90 then
       rollVerticalRatio = rescaleRollDegAbs / 90
      elseif rescaleRollDegAbs < 180 then
       rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
      end
      rollVerticalRatio = rollVerticalRatio * rollVerticalRatio
      local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
      local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio
      targetAngularVelocity = targetAngularVelocity
           + turnAssistPitchInput * constructRight
           + turnAssistYawInput * constructUp
     end
    end
    -- Engine commands
    local keepCollinearity = 1
    local dontKeepCollinearity = 0
    local tolerancePercentToSkipOtherPriorities = 1
    -- Rotation
    local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
    local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())
    angularAcceleration = angularAcceleration - airAcceleration
    Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)
    -- Brakes
    local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
    Nav:setEngineForceCommand('brake', brakeAcceleration)
    -- AutoNavigation regroups all the axis command by 'TargetSpeed'
    local autoNavigationEngineTags = ''
    local autoNavigationAcceleration = vec3()
    local autoNavigationUseBrake = false
    -- Longitudinal Translation
    local longitudinalEngineTags = 'thrust analog longitudinal'
    local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
    if (longitudinalCommandType == axisCommandType.byThrottle) then
     local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
     Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
    elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
     local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
     autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
     autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
     if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or
      Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5)
     then
      autoNavigationUseBrake = true
     end
    end
    -- Lateral Translation
    local lateralStrafeEngineTags = 'thrust analog lateral'
    local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
    if (lateralCommandType == axisCommandType.byThrottle) then
     local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
     Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
    elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
     local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
     autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
     autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
    end
    -- Vertical Translation
    local verticalStrafeEngineTags = 'thrust analog vertical'
    local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
    if (verticalCommandType == axisCommandType.byThrottle) then
     local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
     Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
    elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
     local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
     autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
     autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
    end
    -- Auto Navigation (Cruise Control)
    if (autoNavigationAcceleration:len() > constants.epsilon) then
     if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
     then
      autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
     end
     Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
    end
    -- Rockets
    Nav:setBoosterCommand('rocket_engine')

    --PROGRADE ALIGNER
    if auto_aligner == true then
     auto_align()
    end
  update:
   lua: |
    Nav:update()
    --START HUD CODE
    local data_change = false
    --ALTITUDE
    if math.floor(core.getAltitude()) ~= altitude then
     data_change = true
     right_panel = monitor_right()
    end
    altitude = math.floor(core.getAltitude())
    --PITCH / ROLL
    if math.floor(unit.getPitch()*10)/10 ~= pitch_hud then
     f_pitch_roll()
     data_change = true
     right_panel = monitor_right()
    end
    if math.floor(unit.getRoll()*10)/10 ~= roll_hud then
     f_pitch_roll()
     data_change = true
     right_panel = monitor_right()
    end
    f_pitch_roll()
    --SPEED
    if math.floor((vec3(core.getVelocity()):len())*3.6) ~= speed_hud then
     data_change = true
     right_panel = monitor_right()
    end
    speed_hud = math.floor((vec3(core.getVelocity()):len())*3.6)
    --THROTTLE
    if math.floor(unit.getThrottle()) ~= thr then
     data_change = true
     right_panel = monitor_right()
    end
    thr = math.floor(unit.getThrottle())
    --V/S
    local worldVelocity = vec3(core.getWorldVelocity())
    local gravity = vec3(core.getWorldGravity())
    if math.floor(worldVelocity:dot(-gravity:normalize())) ~= vs_hud then
     data_change = true
     right_panel = monitor_right() 
    end
    local worldVelocity = vec3(core.getWorldVelocity())
    local gravity = vec3(core.getWorldGravity())
    vs_hud = math.floor(worldVelocity:dot(-gravity:normalize()))

    if  data_change == true then
     hud = right_panel
     hud = hud .. left_panel
     system.setScreen(hud)
    end
  actionStart:
   args: [option1]
   lua: |
    --LOADING page
     unit.stopTimer("atmo_pg")
     unit.stopTimer("space_pg")
     unit.stopTimer("orbit_pg")
     unit.stopTimer("damage_pg")

     loading_pg = true
     atmo_pg = false
     orbit_pg = false
     space_pg = false
     damage_pg = false

     left_panel = monitor_left_loading()

     hud = right_panel
     hud = hud .. left_panel
     system.setScreen(hud)

     unit.setTimer("loading_pg", 1/30)
  actionStart:
   args: [option2]
   lua: |
    --ATMO page
     unit.stopTimer("loading_pg")
     unit.stopTimer("space_pg")
     unit.stopTimer("orbit_pg")
     unit.stopTimer("damage_pg")

     loading_pg = false
     atmo_pg = true
     orbit_pg = false
     space_pg = false
     damage_pg = false

     left_panel = monitor_left_atmo()

     hud = right_panel
     hud = hud .. left_panel
     system.setScreen(hud)

     unit.setTimer("atmo_pg", 1/30)
  actionStart:
   args: [option3]
   lua: |
    --SPACE page
     unit.stopTimer("loading_pg")
     unit.stopTimer("atmo_pg")
     unit.stopTimer("orbit_pg")
     unit.stopTimer("damage_pg")

     loading_pg = false
     atmo_pg = false
     orbit_pg = false
     space_pg = true
     damage_pg = false

     left_panel = monitor_left_space()

     hud = right_panel
     hud = hud .. left_panel
     system.setScreen(hud)

     unit.setTimer("space_pg", 1/30)
  actionStart:
   args: [option4]
   lua: |
    --ORBIT page
     unit.stopTimer("loading_pg")
     unit.stopTimer("atmo_pg")
     unit.stopTimer("space_pg")
     unit.stopTimer("damage_pg")

     loading_pg = false
     atmo_pg = false
     orbit_pg = true
     space_pg = false
     damage_pg = false

     left_panel = monitor_left_orbit()

     hud = right_panel
     hud = hud .. left_panel
     system.setScreen(hud)

     unit.setTimer("orbit_pg", 1/30)
  actionStart:
   args: [option5]
   lua: |
    --DAMAGE page
     unit.stopTimer("loading_pg")
     unit.stopTimer("atmo_pg")
     unit.stopTimer("space_pg")
     unit.stopTimer("orbit_pg")

     loading_pg = false
     atmo_pg = false
     orbit_pg = false
     space_pg = false
     damage_pg = true

     left_panel = monitor_left_damage()

     hud = right_panel
     hud = hud .. left_panel
     system.setScreen(hud)

     unit.setTimer("damage_pg", 1/2)
  actionStart:
   args: [option6]
   lua: |
    --SHIP ALIGNER
     if (space_pg == true or orbit_pg == true) then
      if auto_aligner == false then
       auto_aligner = true
       prograde_mode = true
       autopilot_ecam_mode = [[Autopilot ON - Mode 1]]

      elseif (auto_aligner == true and prograde_mode == true and orbit_maintainer == false) then
       orbit_maintainer = true
       autopilot_ecam_mode = [[Autopilot ON - Mode 2]]
       unit.setTimer("delay3sec", 3)
       time_to_align = 4
       unit.setTimer("countdown", 1)
       function orbiting_mode_delay()
        unit.setTimer("maintaning_orbit", 1/30)
        unit.stopTimer("delay3sec")
        unit.stopTimer("countdown")
       end -- function orbiting_mode_delay()

      elseif (auto_aligner == true and prograde_mode == true and orbit_maintainer == true) then
       unit.stopTimer("maintaning_orbit")
       orbit_maintainer = false
       adjusting_mode = [[ ]]
       prograde_mode = false
       autopilot_ecam_mode = [[Autopilot ON - Mode 3]]
       unit.setTimer("delay3sec", 3)
       time_to_align = 4
       unit.setTimer("countdown", 1)
       function destination_mode_delayed()
        destination_mode = true
        unit.stopTimer("delay3sec")
        unit.stopTimer("countdown")
        adjusting_mode = [[ ]]
       end -- function destination_mode_delayed()

      elseif (auto_aligner == true and (destination_mode == true or prograde_mode == false)) then
       unit.stopTimer("delay3sec")
       unit.stopTimer("countdown")
       auto_aligner = false
       destination_mode = false
       align_active_mode = [[ ]]
       autopilot_ecam_mode = [[ ]]
       adjusting_mode = [[ ]]
      end

     elseif (atmo_pg == true) then
      unit.stopTimer("delay3sec")
      unit.stopTimer("countdown")
      unit.stopTimer("maintaning_orbit")
      auto_aligner = false
      prograde_mode = false
      destination_mode = false
      align_active_mode = [[ ]]
      adjusting_mode = [[ ]]
      autopilot_ecam_mode = [[ ]]
     end
  actionStart:
   args: [option7]
   lua: |
    --AUTOBRAKE
     if Helper == true then
      Helper = false
     end
     if (autobrake == true or autobrake_arm == true and brakeInput == 1)then
      unit.stopTimer("autobrake")
      autobrake_in = [[ Autobrake OFF ]]
      autobrake_ecam_mode = [[ ]]
      brakeInput = brakeInput - 1
      autobrake = false
      autobrake_arm = false
     elseif (autobrake == false and brakeInput == 0) then
      unit.setTimer("autobrake", 1/2)
      autobrake = true
      autobrake_arm = true
     end
  actionStart:
   args: [option8]
   lua: |
    --RADAR SHOW
     if du_radar_widgets == false then
      _autoconf.displayCategoryPanel(radar, radar_size, "Periscope", "periscope")
      if radar_size>0 then
        _autoconf.displayCategoryPanel(radar, radar_size, "Radar", "radar")
      end
      du_radar_widgets = true
    --RADAR HIDE
     elseif du_radar_widgets == true then
      _autoconf.hideCategoryPanels()
      du_radar_widgets = false
     end
  actionStart:
   args: [option9]
   lua: |
    --WIDGETS SHOW
     if du_widgets == false then
      unit.show()
      if spacefueltank_size > 0 then
       _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, "Space Fuel", "fuel_container")
      end
      core.show()
      if atmofueltank_size > 0 then
       _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, "Atmo Fuel", "fuel_container")
      end
      if gyro ~= nil then gyro.show() end
      if antigrav ~= nil then antigrav.show() end
      if warpdrive ~= nil then warpdrive.show() end
      du_widgets = true
    --WIDGETS HIDE
     elseif du_widgets == true then
      unit.hide()
      core.hide()
      if gyro ~= nil then gyro.hide() end
      if antigrav ~= nil then antigrav.hide() end
      if warpdrive ~= nil then warpdrive.hide() end
      _autoconf.hideCategoryPanels()
      du_widgets = false
      du_radar_widgets = false
     end
  actionStart:
   args: [gear]
   lua: |
    gearExtended = not gearExtended
    if gearExtended then
     Nav.control.extendLandingGears()
    else
     Nav.control.retractLandingGears()
    end

  actionStart:
   args: [light]
   lua: |
    if Nav.control.isAnyHeadlightSwitchedOn() == 1 then
     Nav.control.switchOffHeadlights()
    else
     Nav.control.switchOnHeadlights()
    end

  actionStart:
   args: [forward]
   lua: pitchInput = pitchInput - 1
  actionStop:
   args: [forward]
   lua: pitchInput = pitchInput + 1
  actionStart:
   args: [backward]
   lua: pitchInput = pitchInput + 1
  actionStop:
   args: [backward]
   lua: pitchInput = pitchInput - 1
  actionStart:
   args: [left]
   lua: rollInput = rollInput - 1
  actionStop:
   args: [left]
   lua: rollInput = rollInput + 1
  actionStart:
   args: [right]
   lua: rollInput = rollInput + 1
  actionStop:
   args: [right]
   lua: rollInput = rollInput - 1

  actionStart:
   args: [straferight]
   lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
  actionStop:
   args: [straferight]
   lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

  actionStart:
   args: [strafeleft]
   lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
  actionStop:
   args: [strafeleft]
   lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

  actionStart:
   args: [up]
   lua: |
    Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
    Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
  actionStop:
   args: [up]
   lua: |
    Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
    Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
  actionStart:
   args: [down]
   lua: |
    Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
    Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
  actionStop:
   args: [down]
   lua: |
    Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
    Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)

  actionStart:
   args: [groundaltitudeup]
   lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

  actionLoop:
   args: [groundaltitudeup]
   lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)


  actionStart:
   args: [groundaltitudedown]
   lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

  actionLoop:
   args: [groundaltitudedown]
   lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

  actionStart:
   args: [yawright]
   lua: yawInput = yawInput - 1
  actionStop:
   args: [yawright]
   lua: yawInput = yawInput + 1
  actionStart:
   args: [yawleft]
   lua: yawInput = yawInput + 1
  actionStop:
   args: [yawleft]
   lua: yawInput = yawInput - 1
  actionStart:
   args: [brake]
   lua: |
    brakeInput = brakeInput + 1
    local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
    if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
     local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
     if (math.abs(targetSpeed) > constants.epsilon) then
      Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
     end
    end
  actionStop:
   args: [brake]
   lua: brakeInput = brakeInput - 1

  actionLoop:
   args: [brake]
   lua: |
    local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
    if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
     local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
     if (math.abs(targetSpeed) > constants.epsilon) then
      Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
     end
    end
  actionStart:
   args: [booster]
   lua: Nav:toggleBoosters()
  actionStart:
   args: [stopengines]
   lua: Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
  actionStart:
   args: [speedup]
   lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
  actionLoop:
   args: [speedup]
   lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
  actionStart:
   args: [speeddown]
   lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
  actionLoop:
   args: [speeddown]
   lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)

  actionStart:
   args: [antigravity]
   lua: if antigrav ~= nil then antigrav.toggle() end
  actionStart:
   args: [warp]
   lua: if warpdrive ~= nil then warpdrive.activateWarp() end