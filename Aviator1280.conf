name: Aviator1280

slots:
 core:
  class: CoreUnit
 gyro:
  class: GyroUnit
 warpdrive:
  class: WarpDriveUnit
 atmofueltank:
  class: AtmoFuelContainer
  select: all
 spacefueltank:
  class: SpaceFuelContainer
  select: all
 rocketfueltank:
  class: RocketFuelContainer
  select: manual
 weapon:
  class: WeaponUnit
  select: manual
 radar:
  class: RadarPVPUnit
  select: manual
 container:
  class: ItemContainer
  select: manual
 databank:
  class: databank
 radio_alt:
  class: VerticalBooster
  select: manual
 radio_alt:
  class: Hovercraft
  select: manual
 radio_alt:
  class: TelemeterUnit
  select: manual
 antigrav:
  class: AntiGravityGeneratorUnit
 shield:
  class: ShieldGeneratorUnit
handlers:
 library:
  start:
   lua: |
    if databank then
     if databank.getStringValue("Serialize")~="" then
      SerializeFunction=databank.getStringValue("Serialize")
      load(SerializeFunction)()()
     end
    end
 unit:
  start:
   lua: |
    --[[

    Author: Aviator1280

    --]]

    --DU CODE
     pitchInput=0
     rollInput=0
     yawInput=0
     brakeInput=0
     rcfreeze=1 --export
     GND_Altitude=0 --export

     Nav=Navigator.new(system, core, unit)
     Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})
     Nav.axisCommandManager:setTargetGroundAltitude(GND_Altitude)

     --element widgets
     --For now we have to alternate between PVP and non-PVP widgets to have them on the same side.
     _autoconf.displayCategoryPanel(weapon, weapon_size, L_TEXT("ui_lua_widget_weapon", "Weapons"), "weapon", true)
     core.show()
     _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_periscope", "Periscope"), "periscope")
     placeRadar=true
     if atmofueltank_size>0 then
         _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"), "fuel_container")
         if placeRadar then
             _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
             placeRadar=false
         end
     end
     if spacefueltank_size>0 then
         _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"), "fuel_container")
         if placeRadar then
             _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
             placeRadar=false
         end
     end
     _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"), "fuel_container")
     if placeRadar then --We either have only rockets or no fuel tanks at all, uncommon for usual vessels
         _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
         placeRadar=false
     end
     if antigrav~=nil then antigrav.show() end
     if warpdrive~=nil then warpdrive.show() end
     if gyro~=nil then gyro.show() end
     if shield~=nil then shield.show() end

     throttleStep=0.25 --export: When pressing the SpeedUp/SpeedDown buttons, this step will be using to increment/decrement the throttle<br>Valid values: From 0.01 to 1
     throttleStep=utils.clamp(throttleStep, 0.01, 1)

     --freeze the player in he is remote controlling the construct
     if Nav.control.isRemoteControlled()==1 then system.freeze(rcfreeze) end

     --landing gear
     --make sure every gears are synchonized with the first
     gearExtended=(Nav.control.isAnyLandingGearExtended()==1) --make sure it's a lua boolean
     if gearExtended then
      Nav.control.extendLandingGears()
     else
      Nav.control.retractLandingGears()
     end

    --START HUD CODE
     local SoftwareVersion="v5.0.0"
     local NIver,NINSver,FMver,PVPSver="v4.0.0","v4.0.0","v4.0.0","v4.0.0"
     local VersionCheck="Update: "
     if databank then
      databank.setStringValue("Aviator1280 HUD ver", SoftwareVersion)
      local NavigatorInterface=databank.getStringValue("Navigator Interface ver")
      local NavigatorInterfaceNS=databank.getStringValue("Navigator Interface No Scr ver")
      local FuelModule=databank.getStringValue("Fuel Module ver")
      local PVPStation=databank.getStringValue("PVP Station ver")
      if (NavigatorInterface=="" or NavigatorInterface==NIver) then VersionCheck=VersionCheck else VersionCheck="Navigator Interface To "..NIver.."; " end
      if (NavigatorInterfaceNS=="" or NavigatorInterfaceNS==NINSver) then VersionCheck=VersionCheck else VersionCheck=VersionCheck.."Navigator Interface No Scr To "..NINSver.."; " end
      if (FuelModule=="" or FuelModule==FMver) then VersionCheck=VersionCheck else VersionCheck=VersionCheck.."Fuel Module To "..FMver.."; " end
      if (PVPStation=="" or PVPStation==PVPSver) then VersionCheck=VersionCheck else VersionCheck=VersionCheck.."PVP Station To "..PVPSver.."; " end
      if VersionCheck=="Update: " then VersionCheck="All Installed Module Ver. Check OK" end
     end

     system.print("- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -")
     system.print("AVIATOR1280 Flyght System ONLINE")
     system.print("Release "..SoftwareVersion)
     system.print(VersionCheck)
     system.print("")
     system.print("<< FOR HELP type: /help >>")
     system.print("Long List, scroll to check it all")
     system.print("")

     local ScrW=system.getScreenWidth()
     local ScrH=system.getScreenHeight()
     loading_pg=true
     autoRoll_activated=false
     ai_hud_page=false
     spc_hud_page=false
     orb_hud_page=false
     yaw_bird_corr=0
     Preferred_HUD_Color="aqua" --export
     alt_hold_color="none"
     hud_color_index=0
     hud_color={[1]=Preferred_HUD_Color,[2]="lightgreen",[3]="red",[4]="orange",[5]="yellow",[6]="white",[7]="none"}
     active_hud_color=hud_color[1]
     DbInitialised=""
     if databank then DbInitialised=databank.getStringValue("databank_verification") end
     UnitIsCockpit=false
     UnitIsSeat=false
     UnitType=unit.getElementClass()
     if UnitType=="CockpitFighterUnit" then UnitIsCockpit=true else UnitIsSeat=true end

    --LUA PARAMETERS
     Parking_Brake_Set=true --export: Parking Brake ON/OFF when entering the seat/cockpit
     Autobrake_Stop_Distance=2.3 --export: Distance at which the Ship Will stop (!WARNING! consider Planets/Moons radius)
     Widgets_ON_OFF=false --export: DU Widgets ON/OFF when entering the seat/cockpit
     if Widgets_ON_OFF==false then
      unit.hide()
      core.hide()
      if gyro~=nil then gyro.hide() end
      if antigrav~=nil then antigrav.hide() end
      if warpdrive~=nil then warpdrive.hide() end
      if shield~=nil then shield.hide() end
      _autoconf.hideCategoryPanels()
      du_widgets=false
      du_radar_widgets=false
     else
      du_widgets=true
      du_radar_widgets=true
     end
     Maximum_Take_Off_Weight=730000 --export: In Kg
     if DbInitialised=="Verified" then
      if databank.getFloatValue("navigator_pe_target_altitude")~=nil then
       PeTargetAlt=databank.getFloatValue("navigator_pe_target_altitude")
      else PeTargetAlt=20000 end
     else
      Periapsis_Target_Altitude= 20000 --export: In meters
      PeTargetAlt=Periapsis_Target_Altitude
     end
     Planet_Scale_SPC_Mode=80000 --export: Planets/Moons Scale

     DMG_REP_Scale=3 --export: Change Size Of Layout TOP And SIDE VIEW
     DMG_REP_TOP_VIEW_Up_Down=-20 --export: (Higer value for Up) (Lower for Down)
     DMG_REP_TOP_VIEW_LH_RH=30 --export: (Higher value for Right) (Lower for Left)
     DMG_REP_SIDE_VIEW_Up_Down=40 --export: (Higher value for Down) (Lower for Up)
     DMG_REP_SIDE_VIEW_LH_RH=100 --export: (Higer value for Right) (Lower for Left)

     if (databank and DbInitialised=="") then
      databank.setFloatValue("DMG Scale", DMG_REP_Scale)
      databank.setFloatValue("DMG TV U/D", DMG_REP_TOP_VIEW_Up_Down)
      databank.setFloatValue("DMG TV L/R", DMG_REP_TOP_VIEW_LH_RH)
      databank.setFloatValue("DMG SV U/D", DMG_REP_SIDE_VIEW_Up_Down)
      databank.setFloatValue("DMG SV L/R", DMG_REP_SIDE_VIEW_LH_RH)
     end

    --TOOLS
     --STRING CONVERTER TO VEC3
      function vec3FromStr(vStr)
       local v3={};
       for num in string.gmatch(vStr, "[-%d%.]+") do
        local vN=string.gsub(num, "%+", "")
        table.insert(v3, tonumber(vN))
       end
       return vec3(table.unpack(v3))
      end

     --ROUND
      function round(num, numDecimalPlaces)
       return tonumber(string.format("%." .. (numDecimalPlaces or 0) .. "f", num))
      end

     --AUTHOR JAYLE BREAK ( https://gitlab.com/JayleBreak/dualuniverse/-/tree/master/DUflightfiles/autoconf/custom )
      --ATLAS
       local DUatlas=require('atlas')

      --PLANETREF
       function planetref()
        local function isNumber(n)  return type(n)           == 'number' end
        local function isSNumber(n) return type(tonumber(n)) == 'number' end
        local function isTable(t)   return type(t)           == 'table'  end
        local function isString(s)  return type(s)           == 'string' end
        local function isVector(v)  return isTable(v) and isNumber(v.x and v.y and v.z) end

        local function isMapPosition(m) return isTable(m) and isNumber(m.latitude and m.longitude and m.altitude and m.bodyId and m.systemId) end

        -- Constants

        local deg2rad    = math.pi/180
        local rad2deg    = 180/math.pi
        local epsilon    = 1e-10
        local num        = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'
        local posPattern = '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' .. num ..  ',' .. num .. '}'

        -- Utilities

        local utils  = require('cpml.utils')
        local vec3   = require('cpml.vec3')
        local clamp  = utils.clamp

        local function float_eq(a,b)
         if a == 0 then return math.abs(b) < 1e-09 end
         if b == 0 then return math.abs(a) < 1e-09 end
         return math.abs(a - b) < math.max(math.abs(a),math.abs(b))*epsilon
        end

        local function formatNumber(n)
         local result = string.gsub(string.reverse(string.format('%.4f',n)), '^0*%.?','')
         return result == '' and '0' or string.reverse(result)
        end

        local function formatValue(obj)
         if isVector(obj) then return string.format('{x=%.3f,y=%.3f,z=%.3f}', obj.x, obj.y, obj.z) end

         if isTable(obj) and not getmetatable(obj) then
          local list = {}
          local nxt  = next(obj)

          if type(nxt) == 'nil' or nxt == 1 then
           for i,a in ipairs(obj) do list[i] = formatValue(a) end
          else
           for k,v in pairs(obj) do
            local value = formatValue(v)
            if type(k) == 'number' then table.insert(list, string.format('[%s]=%s', k, value)) else table.insert(list, string.format('%s=%s',   k, value)) end
           end
          end
          return string.format('{%s}', table.concat(list, ','))
         end

         if isString(obj) then return string.format("[[%s]]", obj) end
         return tostring(obj)
        end

        -- CLASSES

        local BodyParameters = {}
        BodyParameters.__index = BodyParameters
        BodyParameters.__tostring =
         function(obj, indent)
          local keys = {}
          for k in pairs(obj) do table.insert(keys, k) end
          table.sort(keys)
          local list = {}
          for _, k in ipairs(keys) do
           local value = formatValue(obj[k])
           if type(k) == 'number' then table.insert(list, string.format('[%s]=%s', k, value)) else table.insert(list, string.format('%s=%s', k, value)) end
          end
          if indent then return string.format('%s%s', indent, table.concat(list, ',\n' .. indent)) end
          return string.format('{%s}', table.concat(list, ','))
         end
        BodyParameters.__eq = function(lhs, rhs)
         return lhs.planetarySystemId == rhs.planetarySystemId and
          lhs.bodyId            == rhs.bodyId            and
          float_eq(lhs.radius, rhs.radius)               and
          float_eq(lhs.center.x, rhs.center.x)           and
          float_eq(lhs.center.y, rhs.center.y)           and
          float_eq(lhs.center.z, rhs.center.z)           and
          float_eq(lhs.GM, rhs.GM)
         end

        local function mkBodyParameters(systemId, bodyId, radius, worldCoordinates, GM)
         assert(isSNumber(systemId), 'Argument 1 (planetarySystemId) must be a number:' .. type(systemId))
         assert(isSNumber(bodyId), 'Argument 2 (bodyId) must be a number:' .. type(bodyId))
         assert(isSNumber(radius), 'Argument 3 (radius) must be a number:' .. type(radius))
         assert(isTable(worldCoordinates), 'Argument 4 (worldCoordinates) must be a array or vec3.' .. type(worldCoordinates))
         assert(isSNumber(GM), 'Argument 5 (GM) must be a number:' .. type(GM))
         return setmetatable({planetarySystemId = tonumber(systemId), bodyId = tonumber(bodyId), radius = tonumber(radius), center = vec3(worldCoordinates), GM = tonumber(GM) }, BodyParameters)
        end

        -- MapPosition: Geographical coordinates of a point on a planetary body.

        local MapPosition = {}
        MapPosition.__index = MapPosition
        MapPosition.__tostring = function(p)
         return string.format('::pos{%d,%d,%s,%s,%s}', p.systemId, p.bodyId, formatNumber(p.latitude*rad2deg), formatNumber(p.longitude*rad2deg), formatNumber(p.altitude))
        end
        MapPosition.__eq = function(lhs, rhs)
         return lhs.bodyId == rhs.bodyId and lhs.systemId == rhs.systemId and float_eq(lhs.latitude, rhs.latitude) and float_eq(lhs.altitude, rhs.altitude) and (float_eq(lhs.longitude, rhs.longitude) or float_eq(lhs.latitude, math.pi/2) or float_eq(lhs.latitude, -math.pi/2))
        end

        -- latitude and longitude are in degrees while altitude is in meters

        local function mkMapPosition(overload, bodyId, latitude, longitude, altitude)
         local systemId = overload -- Id or '::pos{...}' string

         if isString(overload) and not longitude and not altitude and not bodyId and not latitude then
          systemId, bodyId, latitude, longitude, altitude = string.match(overload, posPattern)
          assert(systemId, 'Argument 1 (position string) is malformed.')
         else
          assert(isSNumber(systemId), 'Argument 1 (systemId) must be a number:' .. type(systemId))
          assert(isSNumber(bodyId), 'Argument 2 (bodyId) must be a number:' .. type(bodyId))
          assert(isSNumber(latitude), 'Argument 3 (latitude) must be in degrees:' .. type(latitude))
          assert(isSNumber(longitude), 'Argument 4 (longitude) must be in degrees:' .. type(longitude))
          assert(isSNumber(altitude), 'Argument 5 (altitude) must be in meters:' .. type(altitude))
         end
         systemId  = tonumber(systemId)
         bodyId    = tonumber(bodyId)
         latitude  = tonumber(latitude)
         longitude = tonumber(longitude)
         altitude  = tonumber(altitude)

         if bodyId == 0 then
          return setmetatable({latitude = latitude, longitude = longitude, altitude = altitude, bodyId = bodyId, systemId = systemId}, MapPosition)
         end
         return setmetatable({latitude  = deg2rad*clamp(latitude, -90, 90), longitude = deg2rad*(longitude % 360), altitude = altitude, bodyId = bodyId, systemId = systemId}, MapPosition)
        end

        -- PlanetarySystem - map body IDs to BodyParameters

        local PlanetarySystem = {}
        PlanetarySystem.__index = PlanetarySystem

        PlanetarySystem.__tostring =
         function (obj, indent)
          local sep = indent and (indent .. '  ' )
          local bdylist = {}
          local keys = {}
          for k in pairs(obj) do table.insert(keys, k) end
          table.sort(keys)
          for _, bi in ipairs(keys) do
           bdy = obj[bi]
           local bdys = BodyParameters.__tostring(bdy, sep)
           if indent then table.insert(bdylist, string.format('[%s]={\n%s\n%s}', bi, bdys, indent))
           else table.insert(bdylist, string.format('  [%s]=%s', bi, bdys)) end
          end
          if indent then return string.format('\n%s%s%s', indent, table.concat(bdylist, ',\n' .. indent), indent) end
          return string.format('{\n%s\n}', table.concat(bdylist, ',\n'))
         end

        local function mkPlanetarySystem(systemReferenceTable)
         local atlas = {}
         local pid
         for _, v in pairs(systemReferenceTable) do
          local id = v.planetarySystemId

          if id == nil then
           id = 0
           v.planetarySystemId = id
          end

          if type(id) ~= 'number' then error('Invalid planetary system ID: ' .. tostring(id))
          elseif pid and id ~= pid then error('Mismatch planetary system IDs: ' .. id .. ' and ' .. pid) end
          local bid = v.bodyId

          if bid == nil then
           bid = v.id
           v.bodyId = bid
          end
          if type(bid) ~= 'number' then error('Invalid body ID: ' .. tostring(bid))
          elseif atlas[bid] then error('Duplicate body ID: ' .. tostring(bid)) end
          v.center = vec3(v.center)
          atlas[bid] = setmetatable(v, BodyParameters)
          pid = id
         end
         return setmetatable(atlas, PlanetarySystem)
        end

        -- PlanetaryReference - map planetary system ID to PlanetarySystem

        PlanetaryReference = {}

        local function mkPlanetaryReference(referenceTable)
         return setmetatable({ galaxyAtlas = referenceTable or {} }, PlanetaryReference)
        end

        PlanetaryReference.__index = 
         function(t,i)
          if type(i) == 'number' then
           local system = t.galaxyAtlas[i]
           return mkPlanetarySystem(system)
          end
          return rawget(PlanetaryReference, i)
         end
        PlanetaryReference.__pairs        =
         function(obj)
          return function(t, k)
          local nk, nv = next(t, k)
          return nk, nv and mkPlanetarySystem(nv) end, obj.galaxyAtlas, nil
         end
        PlanetaryReference.__tostring     =
         function (obj)
          local pslist = {}
          for _,ps in pairs(obj or {}) do
           local psi = ps:getPlanetarySystemId()
           local pss = PlanetarySystem.__tostring(ps, '    ')
           table.insert(pslist, string.format('  [%s]={%s\n  }', psi, pss))
          end
          return string.format('{\n%s\n}\n', table.concat(pslist,',\n'))
         end

        --[[ START OF PUBLIC INTERFACE ]]--

        PlanetaryReference.BodyParameters = mkBodyParameters

        PlanetaryReference.MapPosition = mkMapPosition

        PlanetaryReference.PlanetarySystem = mkPlanetarySystem

        function PlanetaryReference.createBodyParameters(planetarySystemId, bodyId, surfaceArea, aPosition, verticalAtPosition, altitudeAtPosition, gravityAtPosition)
         assert(isSNumber(planetarySystemId), 'Argument 1 (planetarySystemId) must be a number:' .. type(planetarySystemId))
         assert(isSNumber(bodyId), 'Argument 2 (bodyId) must be a number:' .. type(bodyId))
         assert(isSNumber(surfaceArea), 'Argument 3 (surfaceArea) must be a number:' .. type(surfaceArea))
         assert(isTable(aPosition), 'Argument 4 (aPosition) must be an array or vec3:' .. type(aPosition))
         assert(isTable(verticalAtPosition), 'Argument 5 (verticalAtPosition) must be an array or vec3:' .. type(verticalAtPosition))
         assert(isSNumber(altitudeAtPosition), 'Argument 6 (altitude) must be in meters:' .. type(altitudeAtPosition))
         assert(isSNumber(gravityAtPosition), 'Argument 7 (gravityAtPosition) must be number:' .. type(gravityAtPosition))
         local radius   = math.sqrt(surfaceArea/4/math.pi)
         local distance = radius + altitudeAtPosition
         local center   = vec3(aPosition) + distance*vec3(verticalAtPosition)
         local GM       = gravityAtPosition * distance * distance
         return mkBodyParameters(planetarySystemId, bodyId, radius, center, GM)
        end

        PlanetaryReference.isMapPosition  = isMapPosition

        function PlanetaryReference:getPlanetarySystem(overload)
         if self.galaxyAtlas then
          local planetarySystemId = overload

          if isMapPosition(overload) then planetarySystemId = overload.systemId end

          if type(planetarySystemId) == 'number' then
           local system = self.galaxyAtlas[planetarySystemId]
           if system then
            if getmetatable(system) ~= PlanetarySystem then system = mkPlanetarySystem(system) end
            return system
           end
          end
         end
         return nil
        end

        function PlanetarySystem:castIntersections(origin, direction, sizeCalculator, bodyIds)
         local sizeCalculator = sizeCalculator or 
         function (body) return 1.05*body.radius end
         local candidates = {}

         if bodyIds then for _,i in ipairs(bodyIds) do candidates[i] = self[i] end
         else
          bodyIds = {}
          for k,body in pairs(self) do
           table.insert(bodyIds, k)
           candidates[k] = body
          end
         end
         local function compare(b1,b2)
          local v1 = candidates[b1].center - origin
          local v2 = candidates[b2].center - origin
          return v1:len() < v2:len()
         end
         table.sort(bodyIds, compare)
         local dir = direction:normalize()

         for i, id in ipairs(bodyIds) do
          local body   = candidates[id]
          local c_oV3  = body.center - origin
          local radius = sizeCalculator(body)
          local dot    = c_oV3:dot(dir)
          local desc   = dot^2 - (c_oV3:len2() - radius^2)

          if desc >= 0 then
           local root     = math.sqrt(desc)
           local farSide  = dot + root
           local nearSide = dot - root
           if nearSide > 0 then return body, farSide, nearSide
           elseif farSide > 0 then return body, farSide, nil end
          end
         end
         return nil, nil, nil
        end

        function PlanetarySystem:closestBody(coordinates)
         assert(type(coordinates) == 'table', 'Invalid coordinates.')
         local minDistance2, body
         local coord = vec3(coordinates)

         for _,params in pairs(self) do
          local distance2 = (params.center - coord):len2()
          if not body or distance2 < minDistance2 then
           body = params
           minDistance2 = distance2
          end
         end
         return body
        end

        function PlanetarySystem:convertToBodyIdAndWorldCoordinates(overload)
         local mapPosition = overload
         if isString(overload) then mapPosition = mkMapPosition(overload) end

         if mapPosition.bodyId == 0 then return 0, vec3(mapPosition.latitude, mapPosition.longitude, mapPosition.altitude) end
         local params = self:getBodyParameters(mapPosition)

         if params then return mapPosition.bodyId, params:convertToWorldCoordinates(mapPosition) end
        end

        function PlanetarySystem:getBodyParameters(overload)
         local bodyId = overload

         if isMapPosition(overload) then bodyId = overload.bodyId end
         assert(isSNumber(bodyId), 'Argument 1 (bodyId) must be a number:' .. type(bodyId))

         return self[bodyId]
        end

        function PlanetarySystem:getPlanetarySystemId()
         local k, v = next(self)
         return v and v.planetarySystemId
        end

        function BodyParameters:convertToMapPosition(worldCoordinates)
         assert(isTable(worldCoordinates), 'Argument 1 (worldCoordinates) must be an array or vec3:' .. type(worldCoordinates))
         local worldVec = vec3(worldCoordinates) 

         if self.bodyId == 0 then return setmetatable({latitude  = worldVec.x, longitude = worldVec.y, altitude = worldVec.z, bodyId = 0, systemId = self.planetarySystemId}, MapPosition) end
         local coords    = worldVec - self.center
         local distance  = coords:len()
         local altitude  = distance - self.radius
         local latitude  = 0
         local longitude = 0

         if not float_eq(distance, 0) then
          local phi = math.atan(coords.y, coords.x)
          longitude = phi >= 0 and phi or (2*math.pi + phi)
          latitude = math.pi/2 - math.acos(coords.z/distance)
         end
         return setmetatable({latitude = latitude, longitude = longitude, altitude = altitude, bodyId = self.bodyId, systemId = self.planetarySystemId}, MapPosition)
        end

        function BodyParameters:convertToWorldCoordinates(overload)
         local mapPosition = isString(overload) and mkMapPosition(overload) or overload
         if mapPosition.bodyId == 0 then return vec3(mapPosition.latitude, mapPosition.longitude, mapPosition.altitude) end
         assert(isMapPosition(mapPosition), 'Argument 1 (mapPosition) is not an instance of "MapPosition".')
         assert(mapPosition.systemId == self.planetarySystemId, 'Argument 1 (mapPosition) has a different planetary system ID.')
         assert(mapPosition.bodyId == self.bodyId, 'Argument 1 (mapPosition) has a different planetary body ID.')
         local xproj = math.cos(mapPosition.latitude)
         return self.center + (self.radius + mapPosition.altitude) * vec3(xproj*math.cos(mapPosition.longitude), xproj*math.sin(mapPosition.longitude), math.sin(mapPosition.latitude))
        end

        function BodyParameters:getAltitude(worldCoordinates)
         return (vec3(worldCoordinates) - self.center):len() - self.radius
        end

        function BodyParameters:getDistance(worldCoordinates)
         return (vec3(worldCoordinates) - self.center):len()
        end

        function BodyParameters:getGravity(worldCoordinates)
         local radial = self.center - vec3(worldCoordinates)
         local len2 = radial:len2()
         return (self.GM/len2) * radial/math.sqrt(len2)
        end

        -- end of module

        return setmetatable(PlanetaryReference,
                            { __call = function(_,...)
                                            return mkPlanetaryReference(...)
                                       end })
       end

      --KEPLER
       function kepler()
        local vec3=require('cpml.vec3')
        local PlanetRef=planetref()

        local function isString(s) return type(s)=='string' end
        local function isTable(t)  return type(t)=='table'  end

        local function float_eq(a,b)
         if a==0 then return math.abs(b)<1e-09 end
         if b==0 then return math.abs(a)<1e-09 end
         return math.abs(a - b)<math.max(math.abs(a),math.abs(b))*epsilon
        end

        Kepler={}
        Kepler.__index=Kepler

        function Kepler:escapeAndOrbitalSpeed(altitude)
         assert(self.body)
         local distance=altitude + self.body.radius

         if not float_eq(distance, 0) then
          local orbit=math.sqrt(self.body.GM/distance)
          return math.sqrt(2)*orbit, orbit
         end
         return nil, nil
        end

        function Kepler:orbitalParameters(overload, velocity)
         assert(self.body)
         assert(isTable(overload) or isString(overload))
         assert(isTable(velocity))
         local pos=(isString(overload) or PlanetRef.isMapPosition(overload)) and
          self.body:convertToWorldCoordinates(overload) or
          vec3(overload)
         local v=vec3(velocity)
         local r=pos - self.body.center
         local v2=v:len2()
         local d=r:len()
         local mu=self.body.GM
         local e=((v2 - mu/d)*r - r:dot(v)*v)/mu
         local a=mu/(2*mu/d - v2)

         local ecc=e:len()
         local dir=e:normalize()
         local pd=a*(1-ecc)
         local ad=a*(1+ecc)
         local per=pd*dir + self.body.center
         local apo=ecc<=1 and -ad*dir + self.body.center or nil
         local trm=math.sqrt(a*mu*(1-ecc*ecc))
         local Period=apo and 2*math.pi*math.sqrt(a^3/mu)
         local trueAnomaly=math.acos((e:dot(r))/(ecc*d))
         if r:dot(v)<0 then
          trueAnomaly=-(trueAnomaly - 2*math.pi)
         end
         local EccentricAnomaly=math.acos((math.cos(trueAnomaly) + ecc)/(1 + ecc * math.cos(trueAnomaly)))
         local timeTau=EccentricAnomaly
         if timeTau<0 then
          timeTau=timeTau + 2*math.pi
         end
         local MeanAnomaly=timeTau - ecc * math.sin(timeTau)
         local TimeSincePeriapsis=0
         local TimeToPeriapsis=0
         local TimeToApoapsis=0
         if Period~=nil then
          TimeSincePeriapsis=MeanAnomaly/(2*math.pi/Period)
          TimeToPeriapsis=Period - TimeSincePeriapsis
          TimeToApoapsis=TimeToPeriapsis + Period/2
          if trueAnomaly - math.pi>0 then
           TimeToPeriapsis=TimeSincePeriapsis
           TimeToApoapsis=TimeToPeriapsis + Period/2
          end
          if TimeToApoapsis>Period then
          TimeToApoapsis=TimeToApoapsis - Period
          end
         end

         return { periapsis={ position=per,
           speed=trm/pd,
           circularOrbitSpeed=math.sqrt(mu/pd),
           altitude=pd - self.body.radius},
          apoapsis=apo and
           { position=apo,
           speed=trm/ad,
           circularOrbitSpeed=math.sqrt(mu/ad),
           altitude=ad - self.body.radius},
           currentVelocity=v,
           currentPosition=pos,
           eccentricity=ecc,
           period=apo and 2*math.pi*math.sqrt(a^3/mu),
           eccentricAnomaly=EccentricAnomaly,
           meanAnomaly=MeanAnomaly,
           timeToPeriapsis=TimeToPeriapsis,
           timeToApoapsis=TimeToApoapsis
            }
        end

        local function new(bodyParameters)
         local params=PlanetRef.BodyParameters(bodyParameters.planetarySystemId,
          bodyParameters.bodyId,
          bodyParameters.radius,
          bodyParameters.center,
          bodyParameters.GM)
         return setmetatable({body=params}, Kepler)
        end

        return setmetatable(Kepler, { __call=function(_,...) return new(...) end })
       end

     --AUTHOR CATHARIUS (https://github.com/Catharius/DU-MINIMALIST-HUD)
      --LUA PARAMETERS
       DMG_Report=true --export
      --DAMAGE REPORT MODULE
       if DMG_Report==true then
        DAMAGE_rotate_layout_top=-90
        DAMAGE_rotate_x_top=90
        DAMAGE_rotate_y_top=30
        DAMAGE_rotate_layout_side=0
        DAMAGE_rotate_x_side=0
        DAMAGE_rotate_y_side=0

       --General Functions
        function getElemCategory(elemtype)
         elem_category="UNKNOWN"
         if elemtype~=nil then
          local critical_part_list={"DYNAMIC CORE","RESURRECTION NODE","RADAR"}
          local avionics_part_list={"ENGINE","FUEL-TANK","ADJUSTOR","VERTICAL BOOSTER","RETRO-ROCKET BRAKE","WING","ATMOSPHERIC AIRBRAKE"}
          local weapon_part_list={"GUNNER MODULE","LASER","COMMAND SEAT CONTROLLER","COCKPIT","CANNON","MISSILE","RAILGUN"}

          --CRITICALS
           for _,reftype in ipairs(critical_part_list) do
            if string.match(elemtype, reftype) then
             elem_category="CRITICALS"
             break
            end
           end

          --AVIONICS
           if elem_category=="UNKNOWN" then
            for _,reftype in ipairs(avionics_part_list) do
             if string.match(elemtype, reftype) then
              elem_category="AVIONICS"
              break
             end
            end

          --WEAPONS
            if elem_category=="UNKNOWN" then
             for _,reftype in ipairs(weapon_part_list) do
              --Avoid mistaking laser emitter for a weapon...
              if elemtype=="LASER" then
               elem_category="WEAPON"
               break 
              elseif string.match(elemtype, reftype) then
               elem_category="WEAPON"
               break
              end
             end
            end
           end
          end
         return elem_category
        end

       --Element Class
        Element={}
        Element.__index=Element

        function Element.new(elem_id,elem_type,elem_category, elem_name, elem_pos_x, elem_pos_y, elem_pos_z)
         local self=setmetatable({}, Element)
         self.elem_id=elem_id
         self.elem_maxhp=core.getElementMaxHitPointsById(elem_id)
         self.elem_type=elem_type
         self.elem_category=elem_category
         self.elem_name=elem_name
         self.elem_pos_x=elem_pos_x
         self.elem_pos_y=elem_pos_y
         self.elem_pos_z=elem_pos_z
         return self
        end

       --DamageModule Class
        DamageModule={}
        DamageModule.__index=DamageModule

        function DamageModule.new()
         if DbInitialised=="Verified" then
          if databank.getFloatValue("DMG Scale")~="" then
           DAMAGE_size_ratio=databank.getFloatValue("DMG Scale")
          else
           DAMAGE_size_ratio=DMG_REP_Scale
          end
         else
          DAMAGE_size_ratio=DMG_REP_Scale
         end

         local self=setmetatable({}, DamageModule)
         self.elem_list={}
         self.dmg_module_size_ratio=0

         --Getting the core offset
          --XS CORE
           local core_offset=-5
           self.dmg_module_size_ratio=10
           local core_hp=core.getElementHitPointsById(core.getId())
          --L CORE
           if core_hp>10000 then
            core_offset=-128
            self.dmg_module_size_ratio=1
          --M CORE
           elseif core_hp>1000 then
            core_offset=-64
            self.dmg_module_size_ratio=2
          --S CORE
           elseif core_hp>150 then
            core_offset=-32
            self.dmg_module_size_ratio=5
           end

           self.core_offset=core_offset

          --Adjustments
           self.dmg_module_size_ratio=self.dmg_module_size_ratio+DAMAGE_size_ratio

           self.max_x= -999999999
           self.min_x= 999999999
           self.max_y= -999999999
           self.min_y=999999999
           self.max_z= -999999999
           self.min_z=999999999

         --Storing Ship Element
          for i,idelem in ipairs(core.getElementIdList()) do
           local elem_type=core.getElementTypeById(idelem):upper()
           local elem_categ=getElemCategory(elem_type)
           local elem_name=core.getElementNameById(idelem)
           local x,y,z=table.unpack(core.getElementPositionById(idelem))
           x=(x+core_offset)*self.dmg_module_size_ratio
           y=(y+core_offset)*self.dmg_module_size_ratio
           z=(z+core_offset)*self.dmg_module_size_ratio
           if self.min_x>x then
            self.min_x=x
           end
           if self.min_y>y then
            self.min_y=y
           end
           if self.min_z>z then
            self.min_z=z
           end
           if self.max_x<x then
            self.max_x=x
           end
           if self.max_y<y then
            self.max_y=y
           end
           if self.max_z<z then
            self.max_z=z
           end
           self:add(Element.new(idelem,elem_type, elem_categ, elem_name, x, y, z))
          end

         --Computing ship size
          self.ship_width=0
          if self.min_x<0 then
           self.ship_width=self.ship_width + (self.min_x)*-1
          else
           self.ship_width=self.ship_width + self.min_x
          end
          if self.max_x<0 then
           self.ship_width=self.ship_width + (self.max_x)*-1
          else
           self.ship_width=self.ship_width + self.max_x
          end
          self.ship_height=0
          if self.min_y<0 then
           self.ship_height=self.ship_height + (self.min_y)*-1
          else
           self.ship_height=self.ship_height + self.min_y
          end
          if self.max_y<0 then
           self.ship_height=self.ship_height + (self.max_y)*-1
          else
           self.ship_height=self.ship_height + self.max_y
          end
          self.ship_z=0
          if self.min_z<0 then
           self.ship_z=self.ship_z + (self.min_z)*-1
          else
           self.ship_z=self.ship_z + self.min_z
          end
          if self.max_z<0 then
           self.ship_z=self.ship_z + (self.max_z)*-1
          else
           self.ship_z=self.ship_z + self.max_z
          end
         return self
        end

        function DamageModule.add(self,element)
         table.insert(self.elem_list, element)
        end

        function DamageModule.renderHTML(self)
         if DbInitialised=="Verified" then
          if databank.getFloatValue("DMG TV U/D")~="" then
           DAMAGE_translate_x_top=databank.getFloatValue("DMG TV U/D")
          else
           DAMAGE_translate_x_top=DMG_REP_TOP_VIEW_Up_Down
          end
          if databank.getFloatValue("DMG TV L/R")~="" then
           DAMAGE_translate_y_top=databank.getFloatValue("DMG TV L/R")
          else
           DAMAGE_translate_y_top=DMG_REP_TOP_VIEW_LH_RH
          end
          if databank.getFloatValue("DMG SV U/D")~="" then
           DAMAGE_translate_y_side=databank.getFloatValue("DMG SV U/D")
          else
           DAMAGE_translate_y_side=DMG_REP_SIDE_VIEW_Up_Down
          end
          if databank.getFloatValue("DMG SV L/R")~="" then
           DAMAGE_translate_x_side=databank.getFloatValue("DMG SV L/R")
          else
           DAMAGE_translate_x_side=DMG_REP_SIDE_VIEW_LH_RH
          end
         else
          DAMAGE_translate_x_top=DMG_REP_TOP_VIEW_Up_Down
          DAMAGE_translate_y_top=DMG_REP_TOP_VIEW_LH_RH
          DAMAGE_translate_y_side=DMG_REP_SIDE_VIEW_Up_Down
          DAMAGE_translate_x_side=DMG_REP_SIDE_VIEW_LH_RH
         end

         top_view_html_hud=""
         side_view_html_hud=""
         dead_elem_list_hud=""
         high_damage_list_hud=""
         medium_damage_list_hud=""
         light_damage_list_hud=""
         local label_x=self.max_x-self.min_x
         local maxtoptv=-99999999999
         local maxtopsv=-99999999999

          for _,elem in ipairs(self.elem_list) do
           local elem_hp=core.getElementHitPointsById(elem.elem_id)
           local elemmax_hp=core.getElementMaxHitPointsById(elem.elem_id)
           local elem_hp_percentage=(elem_hp*100)/elemmax_hp
           local elem_restore=core.getRemainingRestorations(elem.elem_id)
           local color=""
           local opacity=0.2
           elem_hp_percentage=round(elem_hp_percentage)
           if elem_hp_percentage>=100 then
            color="#9BFFAC"
           elseif elem_hp_percentage>=75 then
            opacity=0.3
            color="#FFDD8E"
            light_damage_list_hud=light_damage_list_hud..[[<span class="ldmg">&nbsp]]..elem.elem_name..[[</span>&nbsp<span class="r">]]..elem_hp_percentage..[[%</span><span class="f_right">(]]..elem_restore..[[)</span><br>]]
           elseif elem_hp_percentage>=50 then
            color="#FF9E66"
            opacity=0.4
            medium_damage_list_hud=medium_damage_list_hud..[[<span class="mdmg">&nbsp]]..elem.elem_name..[[</span>&nbsp<span class="r">]]..elem_hp_percentage..[[%</span><span class="f_right">(]]..elem_restore..[[)</span><br>]]
           elseif elem_hp_percentage>0 then
            color="#FF2819"
            opacity=0.5
            high_damage_list_hud=high_damage_list_hud..[[<span class="hdmg">&nbsp]]..elem.elem_name..[[</span>&nbsp<span class="r">]]..elem_hp_percentage..[[%</span><span class="f_right">(]]..elem_restore..[[)</span><br>]]
           elseif elem_hp_percentage==0 then
            color="#7F120C"
            opacity=1
            dead_elem_list_hud=dead_elem_list_hud..[[<span class="dead">&nbsp]]..elem.elem_name..[[</span>&nbsp<span class="r">0%</span><span class="f_right">(]]..elem_restore..[[)</span><br>]]
           end
           local left=0
           local top=0
          --We are using quadrants to place points correctly
           --1 2
           --3 4
          --Top view x,y
           if (elem.elem_pos_x>=self.min_x and elem.elem_pos_x<=0) and (elem.elem_pos_y>=0 and elem.elem_pos_y<=self.max_y) then
            --1
            left=(self.min_x*-1) + elem.elem_pos_x
            top=self.max_y - elem.elem_pos_y
           elseif (elem.elem_pos_x>0 and elem.elem_pos_x<=self.max_x) and (elem.elem_pos_y>=0 and elem.elem_pos_y<=self.max_y) then
            --2
            left=(self.min_x*-1) + elem.elem_pos_x
            top=self.max_y - elem.elem_pos_y
           elseif (elem.elem_pos_x>=self.min_x and elem.elem_pos_x<=0) and (elem.elem_pos_y>=self.min_y and elem.elem_pos_y<0) then
            --3
            left=(self.min_x*-1) + elem.elem_pos_x
            top=self.max_y + (elem.elem_pos_y*-1)
           elseif (elem.elem_pos_x>0 and elem.elem_pos_x<=self.max_x) and (elem.elem_pos_y>=self.min_y and elem.elem_pos_y<0) then
            --4
            left=(self.min_x*-1) + elem.elem_pos_x
            top=self.max_y + (elem.elem_pos_y*-1)
           end
           if maxtoptv<top then
            maxtoptv=top
           end
           top_view_html_hud=top_view_html_hud..[[<g transform=" rotate(]].. DAMAGE_rotate_layout_top ..[[,]].. DAMAGE_rotate_x_top ..[[,]].. DAMAGE_rotate_y_top ..[[) translate(]].. DAMAGE_translate_x_top ..[[,]].. DAMAGE_translate_y_top ..[[)"><circle fill-opacity="]]..opacity..[[" cx="]]..left..[[" cy="]]..top..[[" r="5" fill="]]..color..[[" /></g>]]
          --Side view y,z
           if (elem.elem_pos_y>=self.min_y and elem.elem_pos_y<=0) and (elem.elem_pos_z>=0 and elem.elem_pos_z<=self.max_z) then 
            --1
            left=(self.min_y*-1) + elem.elem_pos_y
            top=self.max_z - elem.elem_pos_z
           elseif (elem.elem_pos_y>0 and elem.elem_pos_y<=self.max_y) and (elem.elem_pos_z>=0 and elem.elem_pos_z<=self.max_z) then 
            --2
            left=(self.min_y*-1) + elem.elem_pos_y
            top=self.max_z - elem.elem_pos_z
           elseif (elem.elem_pos_y>=self.min_y and elem.elem_pos_y<=0) and (elem.elem_pos_z>=self.min_z and elem.elem_pos_z<0) then 
            --3
            left=(self.min_y*-1) + elem.elem_pos_y
            top=self.max_z + (elem.elem_pos_z*-1)
           elseif (elem.elem_pos_y>0 and elem.elem_pos_y<=self.max_y) and (elem.elem_pos_z>=self.min_z and elem.elem_pos_z<0) then 
            --4
            left=(self.min_y*-1) + elem.elem_pos_y
            top=self.max_z + (elem.elem_pos_z*-1)
           end
           if maxtopsv<top then
            maxtopsv=top
           end
           side_view_html_hud=side_view_html_hud..[[<g transform=" rotate(]].. DAMAGE_rotate_layout_side ..[[,]].. DAMAGE_rotate_x_side ..[[,]].. DAMAGE_rotate_y_side ..[[) translate(]].. DAMAGE_translate_x_side ..[[,]].. DAMAGE_translate_y_side ..[[)"><circle fill-opacity="]]..opacity..[[" cx="]]..left..[[" cy="]]..top..[[" r="5" fill="]]..color..[[" /></g>]]
          end

          --Top view code x,y
           top_view_html_hud=[[<svg width="360" height="150">]]..top_view_html_hud
           top_view_html_hud=top_view_html_hud ..[[</svg>]]
          --side view y,z
           side_view_html_hud=[[<svg width="360" height="150">]]..side_view_html_hud
           side_view_html_hud=side_view_html_hud ..[[</svg>]]

         return {dead_elem_list_hud,
          high_damage_list_hud,
          medium_damage_list_hud,
          light_damage_list_hud,
          top_view_html_hud,
          side_view_html_hud}
        end

        dmgrep=DamageModule.new()
       end

    --AIR DATA
     function air_data()
      --ORBITAL DATA
       function orbital_data()
        local myPos=vec3(core.getConstructWorldPos())
        local myVelocity=vec3(core.getWorldVelocity())
        local SafeZone=vec3({13771471,7435803,-128971})
        local SafeRadius=18000000

        local PlanetaryReference=planetref()
        local Kepler=kepler()
        local galaxyReference=PlanetaryReference(DUatlas)
        local helios=galaxyReference[0]
        local alioth=helios[2] 
        local closestbody=helios:closestBody(myPos)
        local orbitInfo=Kepler(closestbody)
        local orbit=orbitInfo:orbitalParameters(myPos, myVelocity)
        local periapsis=orbit.periapsis.position

        planet_name=closestbody.name[1]
        planet_id=closestbody.bodyId
        planet_pos=closestbody.center
        planet_radius=closestbody.radius
        if DUatlas[0][planet_id].atmosphereRadius then planet_Atmo_alt=math.floor(DUatlas[0][planet_id].atmosphereRadius)
        else planet_Atmo_alt=0 end
        if DUatlas[0][planet_id].atmosphereThickness then planet_Atmo_tick=math.floor(DUatlas[0][planet_id].atmosphereThickness)
        else planet_Atmo_tick=0 end
        orbit_ecc=math.floor(orbit.eccentricity*10000)/10000
        orbit_per_pos=periapsis
        if orbit.period==nil then orbit.period=0 end
        orbit_period_seconds=math.floor(orbit.period)
        local T_time_h=math.floor(orbit_period_seconds/3600)
        local T_time_m=math.floor(((orbit_period_seconds/3600) - T_time_h)*60)
        local T_time_s=math.floor(((((orbit_period_seconds/3600) - T_time_h)*60)- T_time_m)*60)
        orbit_period=T_time_h ..":".. T_time_m ..":".. T_time_s
        orbit_apo_pos=apoapsis
        if orbit.apoapsis==nil then orbit_apo_alt=0
        else orbit_apo_alt=math.floor(orbit.apoapsis.altitude) end
        if orbit.apoapsis==nil then orbit_apo_speed=0
        else orbit_apo_speed=math.floor(orbit.apoapsis.speed) end
        if (orbit_t_to_apo==nil or speed_hud==0) then orbit_t_to_apo="n/a"
        else
         orbit_t_to_apo_seconds=math.floor(orbit.timeToApoapsis)
         local A_time_h=math.floor(orbit_t_to_apo_seconds/3600)
         local A_time_m=math.floor(((orbit_t_to_apo_seconds/3600) - A_time_h)*60)
         local A_time_s=math.floor(((((orbit_t_to_apo_seconds/3600) - A_time_h)*60) - A_time_m)*60)
         orbit_t_to_apo=A_time_h ..":".. A_time_m ..":".. A_time_s
        end
        if (orbit_t_to_per==nil or speed_hud==0) then orbit_t_to_per="n/a"
        else
         orbit_t_to_per_seconds=math.floor(orbit.timeToPeriapsis)
         local P_time_h=math.floor(orbit_t_to_per_seconds/3600)
         local P_time_m=math.floor(((orbit_t_to_per_seconds/3600) - P_time_h)*60)
         local P_time_s=math.floor(((((orbit_t_to_per_seconds/3600) - P_time_h)*60) - P_time_m)*60)
         orbit_t_to_per=P_time_h ..":".. P_time_m ..":".. P_time_s
        end
        if orbit.periapsis==nil then orbit_per_alt=0
        else orbit_per_alt=math.floor(orbit.periapsis.altitude) end
        if orbit.periapsis==nil then orbit_per_speed=0 end
        if orbit.periapsis.speed>0 then orbit_per_speed=math.floor(orbit.periapsis.speed)
        else
         orbit_per_speed=0
         orbit_t_to_apo=0
         orbit_t_to_per=0
        end

        orbit_circular_speed=math.floor(orbit.periapsis.circularOrbitSpeed)
        pe_dis=((orbit_per_pos - myPos):len())/1000
        my_planet_alt=(planet_pos - myPos):len()
        local SafeZoneDist=(SafeZone - myPos):len()
        SafeZoneBorder=(SafeRadius - SafeZoneDist)

        if DbInitialised=="Verified" then
         if databank.getFloatValue("navigator_pe_target_altitude")~=0 then
          PeTargetAlt=math.floor(databank.getFloatValue("navigator_pe_target_altitude"))
         else PeTargetAlt=PeTargetAlt end
        else PeTargetAlt=PeTargetAlt end
       end
       orbital_data()

      --BRAKE SYSTEM
       if DbInitialised=="Verified" then
        if databank.getFloatValue("navigator_autobrake")~=nil then
         autobrake_stops_at=databank.getFloatValue("navigator_autobrake")
        else autobrake_stops_at=Autobrake_Stop_Distance end
       else autobrake_stops_at=Autobrake_Stop_Distance end
       autobrake=false
       autobrake_arm=false
       parking_brk_on=false
       autobrake_ecam_mode=[[ ]]
       autobrake_in=[[ Autobrake OFF ]]

       function parking_brk()
        if (parking_brk_on==true) then
         Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
         brakeInput=brakeInput + 1
         autoRoll_activated=true
         autobrake_ecam_mode=[[<span style=" color: tomato">Parking ON</span>]]
        elseif (parking_brk_on==false) then
         brakeInput=brakeInput - 1
         autoRoll_activated=false
         autobrake_ecam_mode=[[ ]]
        end
       end

       function autobrake_function()
        if (space_pg==true) then
         local cruise_speed=databank.getFloatValue("navigator_speed")
         if (cruise_speed=="n/a" or cruise_speed==0 or cruise_speed=="") then cruise_speed=29999 end
         if (air_density()> 0 and cruise_speed>1000) then cruise_speed=1000 end
         autobrake_ecam_mode=[[<span style="color:yellow">Autobrake</span>&nbsp<span style="color:#00FFFF">ARM</span><br>Cruise Speed: <span style="color:#00FFFF">]]..math.floor(cruise_speed)..[[</span>]]
         if (distance_PPOS_B_hud~=nil and space_pg==true) then
          if DbInitialised=="Verified" then
           if databank.getFloatValue("navigator_autobrake")~=nil then
            autobrake_stops_at=databank.getFloatValue("navigator_autobrake")
           else autobrake_stops_at=Autobrake_Stop_Distance end
          else autobrake_stops_at=Autobrake_Stop_Distance end
          autobrake_in=math.floor((distance_PPOS_B_hud - brake_su - autobrake_stops_at)*100)/100
          if distance_PPOS_B_hud>(brake_su + autobrake_stops_at) then cruise_speed_f(cruise_speed) end
          if distance_PPOS_B_hud<=(brake_su + autobrake_stops_at) then
           Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
           brakeInput=brakeInput + 1
           autobrake=true
           autobrake_arm=false
           autobrake_ecam_mode=[[<span style=" color: #7FFF00">Autobrake ON</span>]]
           unit.stopTimer("autobrake")
          end
         end
        elseif (orbit_pg==true) then
         autobrake_ecam_mode=[[<span class="tomato">SPC to <span class="cyan">ENG</span> Autobrake]]
        end
       end

       function autobrake_disengage()
        autobrake_in=[[ Autobrake OFF ]]
        autobrake_ecam_mode=[[ ]]
        if (autobrake==true) then brakeInput=brakeInput - 1 end
        autobrake=false
        autobrake_arm=false
        unit.stopTimer("autobrake")
       end

      --AIR DENSITY
       function air_density()
        local density=math.floor((unit.getAtmosphereDensity())*100)
        return density
       end

      --ALTITUDE
       altitude=math.floor(core.getAltitude())

      --ALTITUDE HOLD
       altitude_hold=false
       autopilot_ecam_mode=[[ ]]
       TargetAltitude=[[ ]]

       function altitude_hold_function()
        autopilot_ecam_mode=[[ALT HOLD]]
       end

      --AUTOPILOT
       auto_wp=false

       function autopilot_wp()
        autopilot_ecam_mode=[[Autopilot ON<br>ALT HOLD]]
       end

      --SPEED/CRUISE SPEED
       speed_hud=math.floor((vec3(core.getVelocity()):len())*3.6)

       function cruise_speed_f(speed)
        local speed=speed/3.6
        if (throttlePID==nil) then throttlePID=pid.new(0.5, 0, 1) end
        local constructVelocity=vec3(core.getWorldVelocity())
        local constructForward=vec3(core.getConstructWorldOrientationForward())
        throttlePID:inject(speed - constructVelocity:dot(constructForward))
        local pidGet=throttlePID:get()
        calculatedThrottle=utils.clamp(pidGet,-1,1)
        if calculatedThrottle<pidGet then
         ThrottleLimited=true
         Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, utils.clamp(calculatedThrottle,0.01,1))
        else
         ThrottleLimited=false
         Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, pidGet)
        end
       end

      --PARKING BRK
       if Parking_Brake_Set==true then
        if speed_hud<10 then
         parking_brk_on=true
         parking_brk()
        end
       end

      --PITCH/ROLL/YAW/BIRD/COMPASS
       function f_pitch_roll()

        function unit.getPitch()
         local world=0
         if antigrav then
          if antigrav.getState()==1 then world=(vec3(core.getWorldVertical())):normalize()
          else world=(vec3(core.getWorldGravity())):normalize() end
         else world=(vec3(core.getWorldGravity())):normalize() end
         local construct=vec3(core.getConstructWorldOrientationForward())
         local prod=math.asin(world:dot(construct)) * -constants.rad2deg
         return prod
        end
        pitch_hud=math.floor((unit.getPitch())*10)/10

        function unit.getRoll()
         local worldVertical=0
         if antigrav then
          if antigrav.getState()==1 then worldVertical=vec3(core.getWorldVertical())
          else worldVertical=vec3(core.getWorldGravity()) end
         else worldVertical=vec3(core.getWorldGravity()) end
         local constructForward=vec3(core.getConstructWorldOrientationForward())
         local constructRight=vec3(core.getConstructWorldOrientationRight())
         local currentRollDeg=getRoll(worldVertical, constructForward, constructRight)
         local currentRollDegAbs=math.abs(currentRollDeg)
         local currentRollDegSign=utils.sign(currentRollDeg)
        return currentRollDeg
        end
        roll_hud=math.floor(unit.getRoll()*10)/10

        roll_direction=0
        if roll_hud<0 then roll_direction=[[<span style="font-size:15px;color:#00FFFF"><</span>&nbsp]]..math.abs(roll_hud)
        elseif roll_hud>0 then roll_direction=math.abs(roll_hud) ..[[&nbsp<span style=" font-size: 15px; color:#00FFFF">></span>]]
        end

        if speed_hud<20 then pitch_bird_hud,yaw_bird_hud,fpa_hud=0,0,0 else
         function getBirdPitch()
          local up=vec3(core.getWorldVertical())
          local velocity_vector=vec3(core.getWorldVelocity()):normalize()
          local prod=math.asin(velocity_vector:dot(up)) * constants.rad2deg
          local prod=prod + pitch_hud
          if roll_hud>90 or roll_hud<-90 then return -prod else return prod end
         end
         pitch_bird_hud=math.floor(getBirdPitch()*10)/10
         fpa_hud=math.floor((pitch_hud - pitch_bird_hud)*10)/10

         function getBirdYaw()
          local right=vec3(core.getConstructWorldOrientationRight())
          local velocity_vector=vec3(core.getWorldVelocity()):normalize()  
          local prod=math.asin(velocity_vector:dot(right)) * constants.rad2deg
          return prod
         end
         yaw_bird_hud=math.floor(getBirdYaw()*10)/10

         if (roll_hud>15 and roll_hud<-15) then yaw_bird_corr=(pitch_bird_hud/math.tan(roll_hud))
         else yaw_bird_corr=0 end
         yaw_bird_hud=(yaw_bird_hud + yaw_bird_corr)
        end

        function compass()
         local up=-vec3(core.getWorldVertical())
         local forward=vec3(core.getConstructWorldOrientationForward())
         forward=forward - forward:project_on(up)
         local north=vec3(0, 0, 1)
         north=north - north:project_on(up)
         local east=north:cross(up)
         local angle=north:angle_between(forward) * constants.rad2deg
         if forward:dot(east)<0 then angle=math.floor((360-angle)*10)/10 end
         return angle
        end
        compass_hud=compass()
       end
       f_pitch_roll()

      --SPACE ORIENTATION
       autopilot_ecam_mode=[[ ]]
       align_active_mode=[[ ]]
       adjusting_mode=[[ ]]

       function space_orientation()
        if speed_hud==0 then
         pitch_space_hud=0
         yaw_space_hud=0
        else
         function unit.getSpacePitch()
          local up=vec3(core.getConstructWorldOrientationUp())
          local velocity_vector=vec3(core.getWorldVelocity()):normalize()
          local cross=vec3(up:cross(velocity_vector))
          local forward=vec3(core.getConstructWorldOrientationForward()):project_on_plane(cross):normalize()
          local prod=math.acos(velocity_vector:dot(forward)) * constants.rad2deg
          local side=math.asin(velocity_vector:dot(up)) * constants.rad2deg
          if side<0 then prod=prod else prod=-prod end
          return prod
         end
         pitch_space_hud=math.floor(unit.getSpacePitch()*10)/10

         function unit.getSpaceYaw()
          local right=vec3(core.getConstructWorldOrientationRight())
          local velocity_vector=vec3(core.getWorldVelocity()):normalize()
          local cross=vec3(right:cross(velocity_vector))
          local forward=vec3(core.getConstructWorldOrientationForward()):project_on_plane(cross):normalize()
          local prod=math.acos(velocity_vector:dot(forward)) * constants.rad2deg
          local side=math.asin(velocity_vector:dot(right)) * constants.rad2deg
          if side>0 then prod=prod else prod=-prod end
         return prod
         end
         yaw_space_hud=math.floor(unit.getSpaceYaw()*10)/10
        end

        if DbInitialised=="Verified" then
         if (databank.getNbKeys()~=0 and databank.getStringValue("navigator_coordinates")~="n/a") then
          planet_B_coord=vec3FromStr(databank.getStringValue("navigator_coordinates"))
         else planet_B_coord=planet_pos end
        else planet_B_coord=planet_pos end

        function unit.getWPPitch()
         local up=vec3(core.getConstructWorldOrientationUp())
         local myPos=vec3(core.getConstructWorldPos())
         local wp_vector=(planet_B_coord - myPos):normalize()
         local cross=vec3(up:cross(wp_vector))
         local forward=vec3(core.getConstructWorldOrientationForward()):project_on_plane(cross):normalize()
         local prod=math.acos(wp_vector:dot(forward)) * constants.rad2deg
         local side=math.asin(wp_vector:dot(up)) * constants.rad2deg
         if side<0 then prod=prod else prod=-prod end
        return prod
        end
        pitch_WP_hud=math.floor(unit.getWPPitch()*10)/10

        function unit.getWPYaw()
         local right=vec3(core.getConstructWorldOrientationRight())
         local myPos=vec3(core.getConstructWorldPos())
         local wp_vector=(planet_B_coord - myPos):normalize()
         local cross=vec3(right:cross(wp_vector))
         local forward=vec3(core.getConstructWorldOrientationForward()):project_on_plane(cross):normalize()
         local prod=math.acos(wp_vector:dot(forward)) * constants.rad2deg
         local side=math.asin(wp_vector:dot(right)) * constants.rad2deg
         if side>0 then prod=prod else prod=-prod end
        return prod
        end
        yaw_WP_hud=math.floor(unit.getWPYaw()*10)/10
       end
       space_orientation()

      --SHIP ALIGNER
       auto_aligner=false
       prograde_mode=false
       orbit_maintainer=false
       destination_mode=false

       function auto_align()
        if prograde_mode==true then
         target_pitch_to_align=pitch_space_hud
         target_yaw_to_align=yaw_space_hud
         align_active_mode=[[Aligning PROGRADE]]
        end

        if destination_mode==true then
         target_pitch_to_align=pitch_WP_hud
         target_yaw_to_align=yaw_WP_hud
         align_active_mode=[[Aligning DESTINATION]]
        end

        local up=vec3(core.getConstructWorldOrientationUp())
        local right=vec3(core.getConstructWorldOrientationRight())
        local constructAngularVelocity=vec3(core.getWorldAngularVelocity())
        local pitchAngle=target_pitch_to_align
        local yawAngle=target_yaw_to_align

        local pitchAngleAbs=math.abs(pitchAngle)
        local yawAngleAbs=math.abs(yawAngle)

        local autoPitchThreshold=0 --export: For Automatic Aligner
        local autoPitchFactor=0.8 --export: For Automatic Aligner
        local autoYawThreshhold=0 --export: For Automatic Aligner
        local autoYawFactor=0.3 --export: For Automatic Aligner
        local torqueFactor=2 --export: For Automatic Aligner

        if pitchAngleAbs>autoPitchThreshold or yawAngleAbs>autoYawThreshhold then
         local targetPitchDeg=utils.clamp(0,pitchAngleAbs-30, pitchAngleAbs+30);
         local targetYawDeg= utils.clamp(0,yawAngleAbs-30, yawAngleAbs+30);
         if (pitchPID==nil) then pitchPID=pid.new(autoPitchFactor * 0.01, 0, autoPitchFactor * 0.1) end
         if (yawPid==nil) then yawPID=pid.new(autoYawFactor * 0.01, 0, autoYawFactor * 0.1) end
         pitchPID:inject(targetPitchDeg - pitchAngle)
         yawPID:inject(targetYawDeg - yawAngle)
         local autoPitchInput=pitchPID:get()
         local autoYawInput=yawPID:get()
         targetAngularVelocity=autoPitchInput * autoPitchFactor * right + autoYawInput * autoYawFactor * up
         local angularAcceleration=torqueFactor * (targetAngularVelocity - constructAngularVelocity)
         local airAcceleration=vec3(core.getWorldAirFrictionAngularAcceleration())
         angularAcceleration=angularAcceleration - airAcceleration
         Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)
        else
         targetAngularVelocity=0
         Nav:setEngineTorqueCommand("torque", vec3.zero, targetAngularVelocity)
        end
       end

      --MAINTAINING ORBIT
       function maintaining_orbit()
        if (orbit_pg==true and
         auto_aligner==true and
         orbit_ecc<0.9 and
         orbit_apo_alt~=nil and
         orbit_per_alt~=nil and
         orbit_t_to_per_seconds~=nil and
         orbit_t_to_apo_seconds~=nil and
         math.abs(target_pitch_to_align)<2 and
         math.abs(target_yaw_to_align)<2 and
         orbit_per_alt>6000) then

         if (orbit_per_alt<PeTargetAlt and
          orbit_t_to_per_seconds<orbit_t_to_apo_seconds and
          orbit_t_to_per_seconds>1/4*orbit_period_seconds and
          orbit_ecc<0.8) then

          brakeInput=0
          autobrake=false
          Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 100)
          adjusting_mode=[[Increasing PE]]
         elseif (orbit_per_alt>PeTargetAlt + 5000 and
           orbit_t_to_per_seconds<orbit_t_to_apo_seconds and
           orbit_t_to_per_seconds>1/4*orbit_period_seconds and
           orbit_ecc<0.6) then

           Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
           brakeInput=1
           autobrake=true
           adjusting_mode=[[Decreasing PE]]
         elseif (orbit_per_alt<PeTargetAlt - 2000 and
           orbit_t_to_per_seconds<orbit_t_to_apo_seconds and
           orbit_t_to_per_seconds<1/4*orbit_period_seconds and
           orbit_ecc<0.6) then

           brakeInput=0
           autobrake=false
           Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 100)
           adjusting_mode=[[Increasing PE]]
         elseif (orbit_t_to_per_seconds<2) then
          if orbit_apo_alt>PeTargetAlt + 5000 then
           Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
           brakeInput=1
           autobrake=true
           adjusting_mode=[[Decreasing AP]]
          else
           Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
           brakeInput=0
           autobrake=false
           adjusting_mode=[[</span><span style="color:#7FFF00">Maintaining ORBIT]]
          end
         elseif (orbit_apo_alt>PeTargetAlt + 5000 and
          orbit_t_to_apo_seconds<orbit_t_to_per_seconds and
          orbit_per_alt>PeTargetAlt + 5000 and
          orbit_ecc<0.8 and
          orbit_apo_alt>orbit_per_alt + 1000 ) then

          Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
          brakeInput=1
          autobrake=true
          adjusting_mode=[[Decreasing AP]]
         elseif (orbit_apo_alt<PeTargetAlt and
          orbit_t_to_apo_seconds<orbit_t_to_per_seconds and
          orbit_t_to_per_seconds>1/4*orbit_period_seconds and
          (orbit_per_alt<PeTargetAlt or orbit_ecc<0.8)) then

          brakeInput=0
          autobrake=false
          Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 100)
          adjusting_mode=[[Increasing AP]]
         elseif (orbit_t_to_apo_seconds<2) then
          if orbit_per_alt>PeTargetAlt + 5000 then
           Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
           brakeInput=1
           autobrake=true
           adjusting_mode=[[Decreasing PE]]
          else
           Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
           adjusting_mode=[[</span><span style="color:#7FFF00">Maintaining ORBIT]]
          end
         elseif (orbit_per_alt<6000) then
          Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
          adjusting_mode=[[Unafe Orbit BRK ENG]]
          unit.setTimer("autobrake", 1/2)
          brakeInput=1
          autobrake=true
          autobrake_ecam_mode=[[<span style=" color: #7FFF00">Autobrake ON</span>]]
         else
          Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
          brakeInput=0
          autobrake=false
          adjusting_mode=[[</span><span style="color:#7FFF00">Maintaining ORBIT]]
         end
        else
         if ((space_pg==true or
          loading_pg==true or
          atmo_pg==true) and
          adjusting_mode~=[[</span><span style="color:#7FFF00">Maintaining ORBIT]]) then

          adjusting_mode=[[</span><span style="color:tomato">ORB Mode to ARM]]
         else adjusting_mode=[[Orbiting ARM]] end
        end
       end

      --RADIO ALTIMITER
       function f_radioalt_hud()
        radioalt_hud=[[R.A. n/a]]
        local ra=""
        if radio_alt_1 then
         if radio_alt_1.getDistance then ra=math.floor(radio_alt_1.getDistance())
         elseif radio_alt_1.distance then ra=math.floor(radio_alt_1.distance()) end
         if ra~=-1 then radioalt_hud=[[R.A. ]]..ra..[[ m]] else radioalt_hud="" end
        end
        radio_alt_value=ra
        return radioalt_hud
       end
       f_radioalt_hud()

      --DISTANCE TO WP FOR AI
       wp_color_init="none"
       function distance_to_wp_ai()
        if DbInitialised=="Verified" then
         if (databank.getNbKeys()~=0 and databank.getStringValue("navigator_coordinates")~="n/a") then
          local WP_coordinates=vec3FromStr(databank.getStringValue("navigator_coordinates"))
          local myPos=vec3(core.getConstructWorldPos())
          distance_to_wp=string.format("%.1f",((WP_coordinates - myPos):len())/1000)
          wp_color=active_hud_color
         else distance_to_wp,wp_color="n/a","none" end
        else distance_to_wp,wp_color="n/a","none" end
        if wp_color~=wp_color_init then wp_color_init=wp_color end
        return distance_to_wp
       end
       distance_to_wp_ai()

      --THROTTLE
       function thrust_setting()
        local mode=unit.getControlMasterModeId()
        if mode==0 then
         thr=math.floor(unit.getThrottle())
         thr_h_svg=thr
         thr_hud=thr.." %"
         thr_text=""
        elseif mode==1 then
         thr=math.floor(unit.getThrottle())
         thr_hud=math.floor(thr/100)
         thr_text="Km/h"
         thr_h_svg=0
        end
       end
       thrust_setting()

      --VERTICAL SPEED
       function vertical_speed()
        local worldVelocity=vec3(core.getWorldVelocity())
        local gravity=vec3(core.getWorldGravity())
        local vs=math.floor(worldVelocity:dot(-gravity:normalize()))
        return vs
       end
       vs_hud=vertical_speed()

      --VTOL
       vtol_system=false
       L_SHIFT=false

      --FUEL MASS
       fuel_mass=0
       function total_fuel_mass()
        local a_fuel_mass=0
        if atmofueltank_size~=0 then
         for i=1, atmofueltank_size do
          a_fuel_mass=a_fuel_mass + atmofueltank[i].getItemsMass()
          t_a_fuel_mass=math.floor(a_fuel_mass/1000*10)/10
         end
        else t_a_fuel_mass=0 end

        local s_fuel_mass=0
        if spacefueltank_size~=0 then
         for i=1, spacefueltank_size do
          s_fuel_mass=s_fuel_mass + spacefueltank[i].getItemsMass()
          t_s_fuel_mass=math.floor(s_fuel_mass/1000*10)/10
         end
        else t_s_fuel_mass=0 end

        local r_fuel_mass=0
        if rocketfueltank_size~=0 then
         for i=1, rocketfueltank_size do
          r_fuel_mass=r_fuel_mass + rocketfueltank[i].getItemsMass()
          t_r_fuel_mass=math.floor(r_fuel_mass/1000*10)/10
         end
        else t_r_fuel_mass=0 end

        fuel_mass=t_a_fuel_mass + t_s_fuel_mass + t_r_fuel_mass

       return fuel_mass
       end

      --LOADING DATA
       function f_loading_data()

        if DbInitialised=="Verified" then
         if databank.getFloatValue("navigator_MTOW")~=nil then
          MTOW=databank.getFloatValue("navigator_MTOW")
         else MTOW=Maximum_Take_Off_Weight end
        else MTOW=Maximum_Take_Off_Weight end

        cargo_m=0
        if container_size~=0 then
         for i=1, container_size do
          cargo_m=cargo_m + container[i].getItemsMass()
          cargo_m_t=math.floor((cargo_m/1000)*10)/10
          cargo_m_t_hud=cargo_m_t
         end
        else
         cargo_m_t=0
         cargo_m_t_hud="n/a"
        end
       return cargo_m_t, cargo_m_t_hud
       end
       f_loading_data()

      --GW/ZFW/DOW
       gw_m=math.floor(core.getConstructMass()/1000*10)/10
       zfw_m=0
       dow_m=0

      --MTOW PERCENTAGE
       MTOW_p=math.floor(gw_m*1000/MTOW*100)

      --NUMBER OF TANKS
       if atmofueltank_size~=0 then
        a_fuel_tank_n=atmofueltank_size
       else a_fuel_tank_n="0" end
       if spacefueltank_size~=0 then
        s_fuel_tank_n=spacefueltank_size
       else s_fuel_tank_n="0" end
       if rocketfueltank_size~=0 then
        r_fuel_tank_n=rocketfueltank_size
       else r_fuel_tank_n="0" end

      --AVG FUEL PERCENTAGE
       s_fuel_percent_avg_hud=0
       a_fuel_percent_avg_hud=0
       r_fuel_percent_avg_hud=0

       function avg_fuel_percentage()
        local a_fuel_percent=0
        if atmofueltank_size~=0 then
         for i=1, atmofueltank_size do
          if json.decode(atmofueltank[i].getData()).percentage then
           a_fuel_percent=a_fuel_percent + json.decode(atmofueltank[i].getData()).percentage
          end
         end
         a_fuel_percent_avg_hud=math.ceil(a_fuel_percent/atmofueltank_size)
        else a_fuel_percent_avg_hud=[[n/a]] end

        if spacefueltank_size~=0 then
         local s_fuel_percent=0
         for i=1, spacefueltank_size do
          if json.decode(spacefueltank[i].getData()).percentage then
           s_fuel_percent=s_fuel_percent + json.decode(spacefueltank[i].getData()).percentage
          end
         end
         s_fuel_percent_avg_hud=math.ceil(s_fuel_percent/spacefueltank_size)
        else s_fuel_percent_avg_hud=[[n/a]] end

        if rocketfueltank_size~=0 then
         local r_fuel_percent=0
         for i=1, rocketfueltank_size do
          if json.decode(rocketfueltank[i].getData()).percentage then
           r_fuel_percent=r_fuel_percent + json.decode(rocketfueltank[i].getData()).percentage
          end
         end
         r_fuel_percent_avg_hud=math.ceil(r_fuel_percent/rocketfueltank_size)
        else r_fuel_percent_avg_hud=[[n/a]] end
       end
       avg_fuel_percentage()

      --ATMO FUEL WARNING
       a_fuelspy_hud=[[<span style=" color:#141fad">A Fuel</span>]]
       a_fuelwarning_hud=[[ ]]

       if atmofueltank_size>0 then
        function atmo_fuel_percent()
         local fuelpercent=0
         a_fuelwarning_hud=[[ ]]
         a_fuelspy_hud=[[<span style=" color:#141fad">A Fuel</span>]]
         for i=1, atmofueltank_size do
          if json.decode(atmofueltank[i].getData()).percentage then
           fuelpercent=json.decode(atmofueltank[i].getData()).percentage
           if fuelpercent<20 and fuelpercent>0 then
            a_fuelspy_hud=[[<span style=" color:orange">A Fuel</span>]] 
            a_fuelwarning_hud=a_fuelwarning_hud ..[[<span style=" color: orange">A Fuel Tank ]]..i..[[ LO LVL</span><br>]]
           elseif fuelpercent==0 then
            a_fuelspy_hud=[[<span style=" color:red">A Fuel</span>]]
            a_fuelwarning_hud=a_fuelwarning_hud.. [[<span style=" color: red">A Fuel Tank ]]..i..[[ EMPTY</span><br>]]
           end
          end
         end
         return a_fuelspy_hud, a_fuelwarning_hud
        end
       end

      --SPACE FUEL WARNING
       s_fuelspy_hud=[[<span style=" color:#141fad">S Fuel</span>]]
       s_fuelwarning_hud=[[ ]]

       if spacefueltank_size>0 then
        function space_fuel_percent()
         local fuelpercent=0
         s_fuelwarning_hud=[[ ]]
         s_fuelspy_hud=[[<span style=" color:#141fad">S Fuel</span>]]
         for i=1, spacefueltank_size do
          if json.decode(spacefueltank[i].getData()).percentage then
           fuelpercent=json.decode(spacefueltank[i].getData()).percentage
           if fuelpercent<20 and fuelpercent>0 then
            s_fuelspy_hud=[[<span style=" color:orange">S Fuel</span>]] 
            s_fuelwarning_hud=s_fuelwarning_hud ..[[<span style=" color: orange">S Fuel Tank ]]..i..[[ LO LVL</span><br>]]
           elseif fuelpercent==0 then
            s_fuelspy_hud=[[<span style=" color:red">S Fuel</span>]]
            s_fuelwarning_hud=s_fuelwarning_hud.. [[<span style=" color: red">S Fuel Tank ]]..i..[[ EMPTY</span><br>]]
           end
          end
         end
         return s_fuelspy_hud, s_fuelwarning_hud
        end
       end

      --ROCKET FUEL WARNING
       r_fuelspy_hud=[[<span style=" color:#141fad">R Fuel</span>]]
       r_fuelwarning_hud=[[ ]]
       r_active_hud=[[#141fad]]

       if rocketfueltank_size>0 then
        function rocket_fuel_percent()
         local fuelpercent=0
         r_fuelwarning_hud=[[ ]]
         r_fuelspy_hud=[[<span style=" color:#141fad">R Fuel</span>]]
         for i=1, rocketfueltank_size do
          if json.decode(rocketfueltank[i].getData()).percentage then
           fuelpercent=json.decode(rocketfueltank[i].getData()).percentage
           if fuelpercent<20 and fuelpercent>0 then
            r_fuelspy_hud=[[<span style=" color:orange">R Fuel</span>]] 
            r_fuelwarning_hud=r_fuelwarning_hud ..[[<span style=" color: orange">R Fuel Tank ]]..i..[[ LO LVL</span><br>]]
           elseif fuelpercent==0 then
            r_fuelspy_hud=[[<span style=" color:red">R Fuel</span>]]
            r_fuelwarning_hud=r_fuelwarning_hud.. [[<span style=" color: red">R Fuel Tank ]]..i..[[ EMPTY</span><br>]]
           end
          end
         end
         return r_fuelspy_hud, r_fuelwarning_hud
        end
      --ROCKET WARNING LIGHT
        function r_warning_light()
         for i=1, rocketfueltank_size do
          r_active_hud=json.decode(rocketfueltank[i].getData()).timeLeft
          if r_active_hud=="n/a" then r_active_hud=[[#141fad]]
          else r_active_hud=[[red]] end
         end
        end
        r_warning_light()
       end

      --AGG
       antigrav_armed=false
       atigrav_widget=false
       antigrav_base_alt=1000
       if DbInitialised=="Verified" and antigrav then
        navi_agg_op=""
        unit.setTimer("antigravity_op", 1)
        if databank.getStringValue("agg eng/stby")~="ENG" then antigrav.deactivate() end
        if (databank.getIntValue("agg_t_alt")~=nil and databank.getIntValue("agg_t_alt")>=1000) then
         antigrav_target_alt=databank.getIntValue("agg_t_alt")
        else
         antigrav_target_alt=1000
         databank.setIntValue("agg_t_alt", 1000)
        end
       else antigrav_target_alt=1000 end
       agg_ecam_mode=[[ ]]
       function agg_status()
        if antigrav~=nil then
         antigravity_state=antigrav.getState()
         if antigravity_state==1 then
          antigrav_armed=true
          atigrav_widget=true
          antigrav.show()
          agg_ecam_mode=[[AGG ON]]
          if DbInitialised=="Verified" then
           databank.setStringValue("agg off/stby", "ACTIVE")
           databank.setStringValue("nav agg", "ENG")
           unit.setTimer("antigravity", 1)
          end
         end
        end
       end
       agg_status()

      --ECAM
       function ECAM()

        function autobrake_ecam()
         if (autobrake_ecam_mode==[[<span style="color:yellow">Autobrake</span>&nbsp<span style="color:#00FFFF">ARM</span><br>Cruise Speed: <span style="color:#00FFFF">]] or
          autobrake_ecam_mode==[[<span style=" color: #7FFF00">Autobrake ON</span>]] or
          autobrake_ecam_mode==[[<span style=" color: tomato">Parking ON</span>]] or
          autobrake_ecam_mode==[[<span class="tomato">SPC to <span class="cyan">ENG</span> Autobrake]]) then
          br_4=[[<br>]]
         else br_4=[[ ]] end
         local autobrake_ecam=autobrake_ecam_mode..br_4
         return autobrake_ecam
        end
        autobrake_ecam()

        function agg_ecam()
         if (agg_ecam_mode==[[AGG ON]] or
          agg_ecam_mode==[[<span class="cyan">AGG ARM</span>]]) then
          br_0=[[<br>]]
         else br_0=[[ ]] end

         if (agg_ecam_mode==[[AGG ON]] or
          agg_ecam_mode==[[<span class="cyan">AGG ARM</span>]]) then
          agg_ecam_mode=agg_ecam_mode..[[<br>Target: <span class="cyan">]]..antigrav_target_alt..[[&nbsp m</span><br>]]
         end

         local agg_ecam=autobrake_ecam()..[[<span style="color:#7FFF00">]]..agg_ecam_mode..[[</span>]]..br_0
         return agg_ecam
        end
        agg_ecam()

        function autopilot_ecam()
         if (autopilot_ecam_mode==[[<span class="tomato">Adjust Attitude</span>]] or
          autopilot_ecam_mode==[[ALT HOLD]] or
          autopilot_ecam_mode==[[Autopilot ON<br>ALT HOLD]] or
          autopilot_ecam_mode==[[Autopilot ON - Mode 1]] or
          autopilot_ecam_mode==[[Autopilot ON - Mode 2]] or
          autopilot_ecam_mode==[[Autopilot ON - Mode 3]]) then
          br_1=[[<br>]]
         else br_1=[[ ]] end

         if (autopilot_ecam_mode==[[<span class="tomato">Adjust Attitude</span>]]) then
          autopilot_ecam_mode=autopilot_ecam_mode..[[<br><span class="cyan">Max Bank 45<br>Max Pitch +25 -15</span><br>]]
         end

         if (autopilot_ecam_mode==[[ALT HOLD]]) or
         autopilot_ecam_mode==[[Autopilot ON<br>ALT HOLD]] then
          autopilot_ecam_mode=autopilot_ecam_mode..[[<br><span class="cyan">]]..math.floor(TargetAltitude)..[[&nbsp m</span><br>]]
         end

         if (align_active_mode==[[Aligning PROGRADE]] or
          align_active_mode==[[Aligning DESTINATION]]) then
          br_2=[[<br>]]
         else
          br_2=[[ ]]
         end

         if (adjusting_mode==[[</span><span style="color:#7FFF00">Maintaining ORBIT]] or
           adjusting_mode==[[Mainteining Orbit in: 3]] or
           adjusting_mode==[[Mainteining Orbit in: 2]] or
           adjusting_mode==[[Mainteining Orbit in: 1]] or
           adjusting_mode==[[Align to DEST in: 3]] or
           adjusting_mode==[[Align to DEST in: 2]] or
           adjusting_mode==[[Align to DEST in: 1]] or
           adjusting_mode==[[Increasing PE]] or
           adjusting_mode==[[Increasing AP]] or
           adjusting_mode==[[Decreasing PE]] or
           adjusting_mode==[[Decreasing AP]] or
           adjusting_mode==[[Orbiting ARM]] or
           adjusting_mode==[[</span><span style="color:tomato">Unafe Orbit BRK ENG]] or
           adjusting_mode==[[</span><span style="color:tomato">ORB Mode to ARM]]) then
          br_3=[[<br>]]
         else
          br_3=[[ ]]
         end

         local autopilot_ecam=agg_ecam()..[[<span style="color:#7FFF00">]]..autopilot_ecam_mode..[[</span><span style=" color: #00FFFF">]]
         local autopilot_ecam=autopilot_ecam..br_1..align_active_mode
         local autopilot_ecam=autopilot_ecam..br_2..adjusting_mode..[[</span>]]..br_3
         return autopilot_ecam
        end
        autopilot_ecam()

        function gyroscope_ecam()
         local gyroscope_ecam=autopilot_ecam()
         if gyroscope_state_ecam==[[<span style="color:#ff00ff">Gyro ON</span><br>]] or
          gyroscope_state_ecam==[[<span style="color:#ff00ff">VTOL</span><br>]] then
          gyroscope_ecam=gyroscope_ecam..gyroscope_state_ecam
         end
         return gyroscope_ecam
        end
        gyroscope_ecam()

        function fuel_ecam()
         local fuel_ecam=gyroscope_ecam()..a_fuelwarning_hud
         fuel_ecam=fuel_ecam..s_fuelwarning_hud
         fuel_ecam=fuel_ecam..r_fuelwarning_hud
         return fuel_ecam
        end
        fuel_ecam()

        function ship_config()
         local ship_config_ecam=fuel_ecam()
         if radio_alt_1 then ship_config_ecam=ship_config_ecam
         else ship_config_ecam=ship_config_ecam..[[<span class="ecam_rec">R.A. Not Installed</span><br>]] end
         if container_1 then ship_config_ecam=ship_config_ecam
         else ship_config_ecam=ship_config_ecam..[[<span class="ecam_rec">Containers Not Linked</span><br>]] end
         if databank then
          if DbInitialised~="Verified" then ship_config_ecam=ship_config_ecam..[[<span class="ecam_rec">Inizialize Databank</span><br>]]
          else ship_config_ecam=ship_config_ecam end
         else ship_config_ecam=ship_config_ecam..[[<span class="ecam_rec">Databank Not Installed</span>]] end
         return ship_config_ecam
        end
        ship_config()

        return ship_config()
       end
       ECAM()

      --ATMO FUEL MIN TIME
       a_t_h=0
       a_t_m=0
       a_t_s=0

       if atmofueltank_size~=0 then
        function a_fuel_minimum_time()
         local key=1
         local i=1
         local minutes_min=json.decode(atmofueltank[i].getData()).timeLeft
         while minutes_min=="n/a" do i=i + 1
          if i>atmofueltank_size then
           i=1
           minutes_min=0
          else
           minutes_min=json.decode(atmofueltank[i].getData()).timeLeft
          end
         end
         for k, v in ipairs(atmofueltank) do
          local timeleft=json.decode(atmofueltank[k].getData()).timeLeft
          if timeleft~="n/a" and timeleft>0 then
           if timeleft<minutes_min then
            key=k
            minutes_min=timeleft
           end
          end
         end
         a_t_h=minutes_min/3600
         a_t_m=(a_t_h-(math.floor(a_t_h)))*60
         a_t_s=(a_t_m-(math.floor(a_t_m)))*60
        end
       end

      --SPACE FUEL MIN TIME AND PERCENTAGE
       s_t_h=0
       s_t_m=0
       s_t_s=0

       if spacefueltank_size~=0 then
        function s_fuel_minimum_time()
         local key=1
         local i=1
         local minutes_min=json.decode(spacefueltank[i].getData()).timeLeft
         while minutes_min=="n/a" do i=i + 1
          if i>spacefueltank_size then
           i=1
           minutes_min=0
          else
           minutes_min=json.decode(spacefueltank[i].getData()).timeLeft
          end
         end
         for k, v in ipairs(spacefueltank) do
          local timeleft=json.decode(spacefueltank[k].getData()).timeLeft
          if timeleft~="n/a" and timeleft>0 then
           if timeleft<minutes_min then
            key=k
            minutes_min=timeleft
           end
          end
         end
         s_t_h=minutes_min/3600
         s_t_m=(s_t_h-(math.floor(s_t_h)))*60
         s_t_s=(s_t_m-(math.floor(s_t_m)))*60
        end
       end

      --ROCKET FUEL MIN TIME
       r_t_h=0
       r_t_m=0
       r_t_s=0

       if rocketfueltank_size~=0 then
        function r_fuel_minimum_time()
         local key=1
         local i=1
         local minutes_min=json.decode(rocketfueltank[i].getData()).timeLeft   
         while minutes_min=="n/a" do i=i + 1
          if i>rocketfueltank_size then
           i=1
           minutes_min=0
          else
           minutes_min=json.decode(rocketfueltank[i].getData()).timeLeft
          end
         end
         for k, v in ipairs(rocketfueltank) do
          local timeleft=json.decode(rocketfueltank[k].getData()).timeLeft
          if timeleft~="n/a" and timeleft>0 then
           if timeleft<minutes_min then
            key=k
            minutes_min=timeleft
           end
          end
         end
         r_t_h=minutes_min/3600
         r_t_m=(r_t_h-(math.floor(r_t_h)))*60
         r_t_s=(r_t_m-(math.floor(r_t_m)))*60
        end
       end

      --LANDING GEAR
       GearInhibit=false
       function landing_gear()
        if radio_alt_1 then
         if radioalt_hud~="" then Nav.control.extendLandingGears() else Nav.control.retractLandingGears() end
        end
        ldg_st=unit.isAnyLandingGearExtended()
        if ldg_st==0 then ldg_st=[[red]]
        else ldg_st=[[green]] end
       end
       landing_gear()

      --LIGHTS
       function f_lights_st()
        lights_st=unit.isAnyHeadlightSwitchedOn()
        if unit.isAnyLandingGearExtended()==0 then Nav.control.switchOffHeadlights()
        else Nav.control.switchOnHeadlights() end
       end
       f_lights_st()

      --CHECK FOR DAMAGES
       dmg_color="#00FFFF"
       function dmg_checker()
        local ElementsID=core.getElementIdList()
        local eleMaxHp=core.getElementMaxHitPointsById
        local eleHp=core.getElementHitPointsById
        for k in pairs(ElementsID) do
         local hp=0
         local mhp=0
         mhp=eleMaxHp(ElementsID[k])
         hp=eleHp(ElementsID[k])
         if ((mhp - hp)>2) then dmg_color="red" break
         else dmg_color="#00FFFF" end
        end
       end
       dmg_checker()

      --RETRO ROCKET
       function f_rrThrust_hud()
        rrThrust_hud=0
        if json.decode(unit.getData()).maxBrake then
         local unit_data=json.decode(unit.getData())
         rrThrust_hud=(math.floor(unit_data.maxBrake/1000)) --kN
        end
       end
       f_rrThrust_hud()

      --BRAKING DISTANCE
       final_speed_brk=0
       function braking_distance(final_speed_brk)

        local c=30000*1000/3600
        local c2=c*c
        local initialSp=(math.floor((vec3(core.getVelocity()):len())*3.6))*0.277777777778 --INSERT Km/h

        local finalSp=(final_speed_brk)*0.277777777778 --INSERT Km/h
        local restMass=(math.floor(core.getConstructMass()/1000*10)/10)*1000 --INSERT t
        local rrThrust=0
        if json.decode(unit.getData()).maxBrake then
         local unit_data=json.decode(unit.getData())
         rrThrust=(math.floor(unit_data.maxBrake/1000))*1000 --INSERT kN
        end

        local totA=-rrThrust * 1/restMass
        local distance=0
        local time=0

        if (initialSp>finalSp) then
         local k1=c*math.asin(initialSp/c)
         local k2=c2 *math.cos(k1/c)/totA
         local t=(c * math.asin(finalSp/c) - k1)/totA
         local d=k2 - c2 * math.cos((totA*t + k1)/c)/totA
         distance=distance + d
         time=time + t
        end

        brake_min=math.floor(time/60)
        brake_sec=math.floor(((time/60)-brake_min)*60)

        brake_su=math.floor(distance/200000*100)/100
        brake_km=math.floor(distance/1000)
       end
       braking_distance(final_speed_brk)

      --SPACE DATA
       function navigator_space_data()
        if databank.getStringValue("navigator_target_destination") then
         navigator_target_destination_hud=databank.getStringValue("navigator_target_destination")
        else navigator_target_destination_hud="no Dest." end

        if (databank.getIntValue("navigator_eta_h") or databank.getIntValue("navigator_eta_m") or databank.getIntValue("navigator_eta_s")) then
         local time_h=databank.getIntValue("navigator_eta_h")
         local time_m=databank.getIntValue("navigator_eta_m")
         local time_s=databank.getIntValue("navigator_eta_s")
         navigator_eta_hud=time_h ..":".. time_m ..":".. time_s
        else navigator_eta_hud="0:0:0" end

        if databank.getFloatValue("navigator_speed") then
         navigator_speed_hud=math.floor(databank.getFloatValue("navigator_speed"))
        else navigator_speed_hud=0 end

        if databank.getFloatValue("navigator_distance") then
         if databank.getFloatValue("navigator_distance")==0 then
          navigator_distance_hud=0
         else navigator_distance_hud=databank.getFloatValue("navigator_distance") end
        end

        if databank.getStringValue("navigator_coordinates") then
         navigator_coordinates_hud=databank.getStringValue("navigator_coordinates")
        else navigator_coordinates_hud="n/a" end

        if databank.getStringValue("navigator_from") then
         navigator_from_hud=databank.getStringValue("navigator_from")
        else navigator_from_hud="no From" end

        if databank.getStringValue("navigator_from_coordinates") then
         navigator_from_coordinates_hud=databank.getStringValue("navigator_from_coordinates")
        else navigator_from_coordinates_hud="n/a" end
       end

      --RADAR
       radar_warning_hud=""
       function radar_contacts()
        if radar_1 then
         local ContactsID=table.unpack(radar_1.getConstructIds())
         if ContactsID~=nil then
          local radar_data=radar_1.getData():gmatch('"constructId":"[0-9]*","distance":[%d%.]*')
          local counter=0
          local min_distance=0
          for v in radar_data do
           counter=counter + 1
           if counter<21 then
            local id,distance=v:match('"constructId":"([0-9]*)","distance":([%d%.]*)')
            local cDistance=round(distance/1000,2)
            local cType=radar_1.getConstructType(id)
            if min_distance==0 then min_distance=cDistance
            elseif cDistance<min_distance then min_distance=cDistance
            end
            if (cType=="dynamic") then radar_warning_hud=[[<span class="rdr_hud red">RDR CONTACT</span><br><span class="rdr_hud white">]]..min_distance..[[</span>&nbsp<span class="rdr_hud units">Km</span>]]
            else radar_warning_hud="" end
           else break end
          end
         else radar_warning_hud="" end
        else radar_warning_hud="" end
       end
       radar_contacts()

      --SHIELD
       function shield_function()
        if shield then
         local shield_sts=shield.getState()
         if shield_sts==1 then shield_st_color="#7FFF00" else shield_st_color="#ff3333" end
         local max_shield=shield.getMaxShieldHitpoints()
         local hp_shield=shield.getShieldHitpoints()
         shield_percent=(hp_shield/max_shield*100).."%"
        else
         shield_st_color="#ff3333"
         shield_percent="Not Installed"
        end
       end
       shield_function()

      --DATABANK CONDITION for SPACE DATA
       function databank_condition()
        if databank then
         if DbInitialised~="Verified" then
          navigator_target_destination_hud="Interface is Off Turn ON to Initialize"
          navigator_eta_hud="n/a"
          navigator_speed_hud=0
          navigator_distance_hud=0
          navigator_coordinates_hud="n/a"
          navigator_from_hud="n/a"
          navigator_from_coordinates_hud="n/a"
         else navigator_space_data() end
        else
         navigator_target_destination_hud="Databank Not Installed"
         navigator_eta_hud="n/a"
         navigator_speed_hud=0
         navigator_distance_hud=0
         navigator_coordinates_hud="n/a"
         navigator_from_hud="n/a"
         navigator_from_coordinates_hud="n/a"
        end
       end
       databank_condition()

      --HELMET HUD COLORS
       function helmet_hud_color()
        if hud_color_index==7 then hud_color_index=0 end
        hud_color_index=hud_color_index + 1
        active_hud_color=hud_color[hud_color_index]
       end

      --PVP STATION
       function PVPStation()
       --SETUP
        _autoconf.displayCategoryPanel(weapon, weapon_size, L_TEXT("ui_lua_widget_weapon", "Weapons"), "weapon", true)
        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_periscope", "Periscope"), "periscope")
        if UnitIsCockpit then databank.setStringValue("PVPCockpit", "ON")
        elseif (UnitIsSeat and UnitType~="RemoteControlUnit") then databank.setStringValue("PVPGunner", "ON") end

        RDRMaxRange=radar_1.getRange()
        local RDRRagnge=radar_1.getIdentifyRanges()
        local XSRange,SRange,MRange,LRange=RDRRagnge[1],RDRRagnge[2],RDRRagnge[3],RDRRagnge[4]
        local Targets_To_Show=10 --export
        local NbOfTargets=Targets_To_Show
        WeaponList={}
        weaponlinked=false
        local IDList={}

       --FRIEND LIST
        function FleetListFunction()
         FleetList={}
         local DBFleetList={}
         DBFleetList=databank.getStringValue("Fleet")
         DBFleetList=json.decode(DBFleetList)
         if (DBFleetList==nil or DBFleetList=="") then DBFleetList={} end
         for i=1, #DBFleetList do 
          local id=tonumber(DBFleetList[i].id)
          local n=DBFleetList[i].n
          local dist=radar_1.getConstructDistance(id)
          FleetList[i]={n=n,id=id,dist=dist}
         end
        end
        if databank then FleetListFunction() end

       --TARGET LIST
        function TargetListFunction()
         local dataID=radar_1.getConstructIds()
         local radar_data=radar_1.getData():gmatch('"constructId":"[0-9]*","distance":[%d%.]*')
         DynamicTargetList={}
         TargetTotal=#dataID
         AbandonedList={}
         ThreatList={}
         IDList={}
         NbOfTargets=Targets_To_Show
         local RDRcounter,counterMAX,ABDcounter,THRcounter,Abandoned=0,NbOfTargets,0,0,0

         for v in radar_data do
          if RDRcounter<=counterMAX then
           local id,distance=v:match('"constructId":"([0-9]*)","distance":([%d%.]*)')
           local cType=radar_1.getConstructType(id)
           Abandoned=radar_1.isConstructAbandoned(id)
           if (cType=="dynamic" and Abandoned==0) then
            local isFleet=false
            for x=1, #FleetList do
             if tonumber(id)==FleetList[x].id then isFleet=true break end
            end
            if not isFleet then
             RDRcounter=RDRcounter+1
             DynamicTargetList[RDRcounter]={id=tonumber(id),dist=distance}
            end
           end
          end
         end

         for i, v in pairs(dataID) do
          Abandoned=radar_1.isConstructAbandoned(v)
          if Abandoned==1 then
           ABDcounter=ABDcounter+1
           local n=radar_1.getConstructName(v)
           local dist=radar_1.getConstructDistance(v)
           AbandonedList[ABDcounter]={n=n,dist=dist}
           IDList[#IDList+1]=v
          end
         end

         for i, v in pairs(dataID) do
          local Threat=radar_1.getThreatFrom(v)
          if Threat~="none" then
           THRcounter=THRcounter+1
           local n=radar_1.getConstructName(v)
           local dist=radar_1.getConstructDistance(v)
           ThreatList[THRcounter]={n=n,dist=dist}
           IDList[#IDList+1]=v
          end
         end

        end
        if radar_1.isOperational()==1 then TargetListFunction() end

       --NB OF TARGETS TO SHOW
        PrevMin=0
        function Target()
         TargetList={}
         if NbOfTargets>#DynamicTargetList then NbOfTargets=#DynamicTargetList end
         for x=1, NbOfTargets do
          local id,idINS,min_distance,name,TLvl,Size,InRange=0,0,0,"","","",false
          for index in pairs(DynamicTargetList) do
           id=DynamicTargetList[index].id
           local distance=radar_1.getConstructDistance(id)
           if min_distance==0 then
            InRange=false
            idINS=id
            min_distance=distance
            name=radar_1.getConstructName(id)
            TLvl=radar_1.getThreatFrom(id)
            Size=radar_1.getConstructCoreSize(id)
            if Size=="XS" then if distance<=XSRange then InRange=true end
            elseif Size=="S" then if distance<=SRange then InRange=true end
            elseif Size=="M" then if distance<=MRange then InRange=true end
            elseif Size=="L" then if distance<=LRange then InRange=true end
            end
            if min_distance<PrevMin then min_distance=PrevMin end
           elseif ((distance<min_distance and distance>PrevMin) or (PrevMin==min_distance and distance>PrevMin)) then
            InRange=false
            idINS=id
            min_distance=distance
            name=radar_1.getConstructName(id)
            TLvl=radar_1.getThreatFrom(id)
            Size=radar_1.getConstructCoreSize(id)
            if Size=="XS" then if distance<=XSRange then InRange=true end
            elseif Size=="S" then if distance<=SRange then InRange=true end
            elseif Size=="M" then if distance<=MRange then InRange=true end
            elseif Size=="L" then if distance<=LRange then InRange=true end
            end
           end    
          end
          IDList[#IDList+1]=idINS
          TargetList[x]={n=name,dist=tonumber(min_distance),TLvl=TLvl,InRange=InRange}
          if x==NbOfTargets then PrevMin=0 else PrevMin=min_distance end
         end
        end
        if radar_1.isOperational()==1 then Target() end

       --TARGET INFO
        function TargetInfoFunction()
         TargetInfo={}
         local IDList=radar_1.getIdentifiedConstructIds()
         if IDList==nil then IDList={} end
         for i=1, #IDList do
          local id=IDList[i]
          local name=radar_1.getConstructName(id)
          local target=radar_1.getTargetId()
          local lock=false
          local speed=0
          local Aspeed=0
          if target==id then
           speed=radar_1.getConstructSpeed(id)
           Aspeed=radar_1.getConstructRadialSpeed(id)
           lock=true
          end
          local TLel=radar_1.getThreatFrom(id)
          local size=radar_1.getConstructCoreSize(id)
          local dist=radar_1.getConstructDistance(id)
          local weapons=radar_1.getConstructInfos(id).weapons
          if (weapons*0)~=0 then weapons=1.0 end
          local radars=radar_1.getConstructInfos(id).radars
          local spaceEngines=radar_1.getConstructInfos(id).spaceEngines
          TargetInfo[i]={n=name,lock=lock,TLvl=TLvl,size=size,dist=dist,weapons=weapons,radars=radars,spaceEngines=spaceEngines,speed=speed,Aspeed=Aspeed}
         end
        end

       --WEAPONS DATA
        if (weapon_size~=nil and weapon_size>0) then
         weaponlinked=true
         function wepdat()
          WeaponList={}
          for i=1, weapon_size do
           local data=weapon[i].getData()
           data=json.decode(data)
           local name=data.name
           local fireBlocked=data.properties.fireBlocked
           local fireReady=data.properties.fireReady
           local hitProb=data.properties.hitProbability
           local optDist=data.staticProperties.optimalDistance
           local optCone=data.staticProperties.optimalAimingCone
           WeaponList[i]={name=name,fireBlocked=fireBlocked,fireReady=fireReady,hitProb=hitProb,optDist=optDist,optCone=optCone}
          end
         end
        end

       --RADAR WIDGET
        function getRadarData(getData)
         local out = ""
         for S in getData:gmatch('({"constructId":".-%b{}.-})') do
          local data=S:match('"constructId":"([%d%.]*)"')
          for i=1, #IDList do
           local id=IDList[i]
           if data==tostring(id) then if #out>0 then out=out .. ',' end out=out .. S break end
          end
         end
         out='{"constructsList":['..out ..'],'.. getData:match('"elementId":".+')
         return out
        end
        radarData=getRadarData(radar_1.getData())
        radarPanel=system.createWidgetPanel("Closer Targets")
        radarWidgetValue=system.createWidget(radarPanel, "radar")
        radarDataValue=system.createData(radarData) 
        system.addDataToWidget(radarDataValue, radarWidgetValue)

       --SENDING DATA
        function SendingData()
         local UpdateData={
          RDRMaxRange=RDRMaxRange,
          TargetList=TargetList,
          TargetTotal=TargetTotal,
          FleetList=FleetList,
          TargetInfo=TargetInfo,
          ThreatList=ThreatList,
          AbandonedList=AbandonedList,
          WeaponList=WeaponList
         }
         if serialize then
          UpdateData=serialize(UpdateData)
          databank.setStringValue("PVPStationData", UpdateData)
         else system.print("System Failed") end
        end

       --UPDATE
        unit.setTimer("PVPupdate", 1)
        unit.setTimer("PVPsender", 1/10)
       end

      --DOCKING
       DockingMode,ConstructDocked,DockedConstructs,DockedMass,PaxOnBoard,PaxOnBoardMass="","","","","",""
       local MyId=core.getConstructId()
       function Docking()
        local a=core.getDockingMode()
        if a==0 then DockingMode="Manual" elseif a==1 then DockingMode="Auto" elseif a==2 then DockingMode="Semi-Auto" end
        local b=core.getParent()
        local c=core.getClosestParent()
        if a==0 then if b~=0 then ConstructDocked="ALT+Y To Undock" elseif c~=0 then ConstructDocked="ALT+T To Dock" else ConstructDocked="" end
        else if b~=0 then ConstructDocked="Docked" elseif c~=0 then ConstructDocked="" end end
        local d=core.getDockedConstructs()
        if #d>0 then
         local counter=0
         local mass=0
         for i, v in pairs(d) do counter=counter+1 mass=mass+core.getDockedConstructMass(v) end DockedConstructs=counter DockedMass=string.format("%.1f", mass/1000)
        else DockedConstructs=0.0 DockedMass=0.0 end
        local e=core.getPlayersOnBoard()
        if #e>0 then
         local counter=0
         local mass=0
         for i, v in pairs(e) do counter=counter+1 mass=mass+core.getBoardedPlayerMass(v) end PaxOnBoard=counter PaxOnBoardMass=string.format("%.1f", mass/1000)
        else PaxOnBoard=0.0 PaxOnBoardMass=0.0 end
       end
       Docking()

     end --AIR DATA

    --SVG
     --SVG A FUEL
      function a_fuel_svg()
       return [[<svg width="30" height="75"><rect x="0" y="0" width="30" height="]]..a_fuel_percent_avg_hud..[[%" style=" fill: dodgerblue" transform="rotate(180, 15, 37)" /></svg>]]
      end

     --SVG S FUEL
      function s_fuel_svg()
       return [[<svg width="30" height="75"><rect x="0" y="0" width="30" height="]]..s_fuel_percent_avg_hud..[[%" style=" fill: yellow" transform="rotate(180, 15, 37)" /></svg>]]
      end

     --SVG R FUEL
      function r_fuel_svg()
       return [[<svg width="30" height="75"><rect x="0" y="0" width="30" height="]]..r_fuel_percent_avg_hud..[[%" style=" fill: slateblue" transform="rotate(180, 15, 37)" /></svg>]]
      end

     --SVG MTOW
      function MTOW_svg()
       return [[<svg width="30" height="40"><rect x="0" y="0" width="30" height="]]..MTOW_p..[[%" style=" fill:yellow" transform="rotate(180, 15, 20)" /></svg>]]
      end

     --SVG THRUST
      function thr_svg()
       return [[<svg width="30" height="50">
        <rect x="0" y="0" width="30" height="]]..thr_h_svg..[[%" style="fill:#00FFFF" transform="rotate(180, 15, 25)" />
        <text text-anchor="middle" x="15" y="25" style="fill:#00FFFF">]]..thr_text..[[</text>
        </svg>]]
      end

     --SVG ARTIFICIAL HORIZON
      function art_h_svg()
       if vs_hud>300 then vs_svg=240
       elseif vs_hud<-300 then vs_svg=360
       else vs_svg=300+(vs_hud/-5) end
       local density=air_density()
       local wp_compass=math.floor(compass_hud + yaw_WP_hud)
       local compass=(-compass_hud)*10+250
       if wp_compass>360 then wp_compass=wp_compass - 360
       elseif wp_compass<0 then wp_compass=wp_compass + 360 end
       local HUDDistance=""
       if ToWp==nil then ToWp="WP" end
       if wp_color==active_hud_color then
        if databank then ToWp=databank.getStringValue("navigator_target_destination") else ToWp="WP" end
        if (distance_to_wp=="n/a" or speed_hud<50) then time_to_wp_hud="n/a" else
         local ATA_h=tonumber(distance_to_wp) / speed_hud
         local ATA_m=(ATA_h - math.floor(ATA_h))*60
         local ATA_s=(ATA_m - math.floor(ATA_m))*60
         time_to_wp_hud=math.floor(ATA_h) ..":".. math.floor(ATA_m) ..":".. math.floor(ATA_s)
        end
        local gnd_alt=math.floor(unit.getSurfaceEngineAltitudeStabilization())
        if tonumber(distance_to_wp)~=nil then
         local Distance=tonumber(distance_to_wp)
         if Distance>200 then Distance=math.floor((Distance/200)*100)/100 .." Su"
         else Distance=Distance .." Km" end
         HUDDistance=Distance
        else HUDDistance=distance_to_wp end
       else time_to_wp_hud=0 end
       if alt_hold_color=="lightgreen" then alt_hold_color=active_hud_color end

       local HUD_HELM={}
       HUD_HELM[#HUD_HELM+1]=[[<div class="hud_ai"><table><tr><td><svg width="500" height="25">
        <g transform="translate(]].. yaw_WP_hud*10 ..[[ 0)"><rect x="247.5" y="15" width="5" height="10" fill="]].. wp_color ..[["/></g>
        <polyline class="linesHELM" points="250,15 245,0 255,0 250,15" /><g class="textHELM" transform="translate(]].. compass ..[[ 0)">
        <text x="-200" y="23" text-anchor="middle">340<tspan x="-100">350</tspan><tspan x="0">N</tspan>]]
       local x,y=0,0
       for i=1, 8 do x=x+100 HUD_HELM[#HUD_HELM+1]=[[<tspan x="]].. x ..[[">]].. string.format("%.0f", x/10) ..[[</tspan>]] end
       HUD_HELM[#HUD_HELM+1]=[[<tspan x="900">E</tspan>]]
       x=900
       for i=1, 8 do x=x+100 HUD_HELM[#HUD_HELM+1]=[[<tspan x="]].. x ..[[">]].. string.format("%.0f", x/10) ..[[</tspan>]] end
       HUD_HELM[#HUD_HELM+1]=[[<tspan x="1800">S</tspan>]]
       x=1800
       for i=1, 8 do x=x+100 HUD_HELM[#HUD_HELM+1]=[[<tspan x="]].. x ..[[">]].. string.format("%.0f", x/10) ..[[</tspan>]] end
       HUD_HELM[#HUD_HELM+1]=[[<tspan x="2700">W</tspan>]]
       x=2700
       for i=1, 8 do x=x+100 HUD_HELM[#HUD_HELM+1]=[[<tspan x="]].. x ..[[">]].. string.format("%.0f", x/10) ..[[</tspan>]] end
       HUD_HELM[#HUD_HELM+1]=[[<tspan x="3600">N</tspan><tspan x="3700">10</tspan><tspan x="3800">20</tspan></text></g></svg></tr></td>
        <tr><td><svg width="500" height="600"><g class="linesHELM" transform="rotate(]].. -roll_hud ..[[,250,300) translate(0 ]].. pitch_hud*10 ..[[)">
        <g class="pitchHELM"><text x="110" y="210" text-anchor="start">10]]
       x,y=10,210
       for i=1, 8 do x=x+10 y=y-100 HUD_HELM[#HUD_HELM+1]=[[<tspan x="110" y="]].. y ..[[">]].. x ..[[</tspan><tspan x="375" y="]].. y ..[[">]].. x ..[[</tspan>]] end
       HUD_HELM[#HUD_HELM+1]=[[<tspan x="375" y="210">10</tspan></text></g>]]
       local p1,p2,p3,p4=-700,-690,300,280
       for i=1, 9 do p1=p1+100 p2=p2+100 p3=p3+100 p4=p4+100
        HUD_HELM[#HUD_HELM+1]=[[<polyline points="229,]].. p1 ..[[ 130,]].. p1 ..[[ 130,]].. p2 ..[["/><polyline points="271,]].. p1 ..[[ 370,]].. p1 ..[[ 370,]].. p2 ..[["/>
        <polyline points="229,]].. p3 ..[[ 130,]].. p3 ..[[ 130,]].. p4 ..[[" stroke-dasharray="10"/><polyline points="271,]].. p3 ..[[ 370,]].. p3 ..[[ 370,]].. p4 ..[[" stroke-dasharray="10"/>]]
       end
       HUD_HELM[#HUD_HELM+1]=[[<polyline points="229,300 100,300 100,310"/><polyline points="271,300 400,300 400,310"/>
        <g class="pitchHELM"><text x="110" y="400" text-anchor="start">10<tspan x="375" y="400">10</tspan>]]
       x,y=10,400
       for i=1, 8 do x=x+10 y=y+100 HUD_HELM[#HUD_HELM+1]=[[<tspan x="110" y="]].. y ..[[">]].. x ..[[</tspan><tspan x="375" y="]].. y ..[[">]].. x ..[[</tspan>]] end
       HUD_HELM[#HUD_HELM+1]=[[</text></g>
        <line id="Nose" class="lines05HELM" x1="250" y1="]].. (300-(pitch_hud*10)) ..[[" x2="]].. (250+yaw_bird_hud*10) ..[[" y2="]].. (300+(-fpa_hud*10)) ..[["/>
        <g class="linesHELM" transform="translate(]].. yaw_bird_hud*10 .." ".. (-fpa_hud*10) ..[[) rotate(]].. roll_hud ..[[,250,300)">
        <circle cx="250" cy="300" r="5" fill-opacity="0"/>
        <line x1="250" y1="295" x2="250" y2="285"/><line x1="245" y1="300" x2="230" y2="300"/><line x1="255" y1="300" x2="270" y2="300"/></g></g>
        <g class="circleHELM"><circle cx="250" cy="300" r="3"/></g>
        <g class="linesHELM"><rect x="0" y="50" width="90" height="25"/>
        <g class="textHELM"><text text-anchor="middle" x="45" y="68">]].. speed_hud ..[[</text><text text-anchor="left" x="100" y="68">Km/h</text></g></g>
        <g class="textHELM"><text text-anchor="end" x="40" y="150">Atmo
        <tspan text-anchor="start" x="40">]].. density ..[[&nbsp%</tspan>
        <tspan text-anchor="end" x="40" y="180">Atl</tspan>
        <tspan text-anchor="start" x="40">]].. planet_Atmo_tick ..[[ m</tspan></text></g>
        <g class="textHELM"><text text-anchor="end" x="39" y="210">&alpha;
        <tspan text-anchor="start" x="40">]].. (math.floor((pitch_bird_hud)*10)/10) ..[[</tspan></text></g>
        <g class="textHELM"><text text-anchor="end" x="39" y="240">FPA
        <tspan text-anchor="start" x="40">]].. fpa_hud ..[[</tspan></text></g>
        <g class="linesHELM"><rect x="410" y="50" width="90" height="25"/>
        <g class="textHELM"><text text-anchor="left" x="385" y="68">m</text>
        <text text-anchor="middle" x="455" y="68">]].. altitude ..[[</text></g></g>
        <g class="alt_hold"><text text-anchor="middle" x="455" y="100">ALT HOLD</text></g>
        <g class="linesHELM"><g class="textHELM">
        <text text-anchor="start" x="420" y="180">]].. radioalt_hud ..[[</text>
        <text text-anchor="start" x="420" y="220">V/S
        <tspan text-anchor="end" x="500">]].. vs_hud ..[[</tspan></text></g>]]
       y,x=220,425
       for i=1, 7 do y=y+20 if i==4 then x=410 else x=425 end HUD_HELM[#HUD_HELM+1]=[[<line x1="440" y1="]].. y ..[[" x2="]].. x ..[[" y2="]].. y ..[["/>]] end
       HUD_HELM[#HUD_HELM+1]=[[<polyline points="500,300 445,]].. vs_svg ..[[ 425,]].. vs_svg ..[["/></g>
        <g class="wptext"><rect class="wpHELM" x="3" y="364" width="50" height="20"/>
        <text text-anchor="middle" x="30" y="380">]].. wp_compass ..[[
        <tspan text-anchor="start" x="3" y="400">]].. ToWp ..[[
        <tspan x="3" y="420">]].. HUDDistance ..[[</tspan>
        <tspan text-anchor="middle" x="455" y="420">]].. time_to_wp_hud ..[[</tspan>
        </text></g></svg></td></tr></table></div>]]
       local HTML=table.concat(HUD_HELM)
       return HTML
      end

     --SVG SPACE ORIENTATION
      function spc_hud()
       if g_hud==nil then g_hud=math.floor(((core.g())/10)*10)/10 end
       local HUD_HELM={}
       HUD_HELM[#HUD_HELM+1]=[[<div class="hud_spc"><table><tr><td><svg width="]].. ScrW ..[[" height="25"><g class="textHELM">
        <text x="]].. ScrW/2 ..[[" y="23" text-anchor="middle">]].. active_hud_mode ..[[</text></g></svg></tr></td>
        <tr><td><svg width="]].. ScrW ..[[" height="]].. ScrH ..[["><g transform="translate(]].. (ScrW/2)-250 ..[[ 0)">
        <g class="linesHELM" transform="translate(]].. yaw_space_hud*10 .." ".. pitch_space_hud*10 ..[[)">]]
       if speed_hud>=60 then HUD_HELM[#HUD_HELM+1]=[[<circle id="VelVector" cx="250" cy="300" r="25"/><line x1="225" y1="300" x2="275" y2="300"/><line x1="250" y1="275" x2="250" y2="325"/>]] end
       local cx,cy=2050,3900 
       for i=1, 8 do
        if i<=3 then cy=cy-1800
        elseif (i==4 and i==5) then cx=250 cy=cy-3600
        elseif i>=6 then cx=-1500 cy=cy-1800 end
        HUD_HELM[#HUD_HELM+1]=[[<circle cx="]].. cx ..[[" cy="]].. cy ..[[" r="25"/>]]
        if i==3 then cy=5700 elseif i==5 then cy=3900 end
       end
       if speed_hud>=60 then HUD_HELM[#HUD_HELM+1]=[[
        <rect x="-668" y="282" width="36" height="36"/><text class="textHELM" text-anchor="middle" x="-650" y="305">-90</text>
        <rect x="1132" y="282" width="36" height="36"/><text class="textHELM" text-anchor="middle" x="1150" y="305">+90</text>
        <rect x="-668" y="2082" width="36" height="36"/><text class="textHELM" text-anchor="middle" x="-650" y="2105">-90</text>
        <rect x="1132" y="-1518" width="36" height="36"/><text class="textHELM" text-anchor="middle" x="1150" y="-1495">+90</text>
        <rect x="-668" y="-1518" width="36" height="36"/><text class="textHELM" text-anchor="middle" x="-650" y="-1495">-90</text>
        <rect x="1132" y="2082" width="36" height="36"/><text class="textHELM" text-anchor="middle" x="1150" y="2105">+90</text>
        <polyline points="250,-625 275,-600 250,-575 225,-600 250,-625"/>
        <polyline points="250,1175 275,1200 250,1225 225,1200 250,1175"/>
        <polyline points="-1550,-625 -1525,-600 -1550,-575 -1575,-600 -1550,-625"/>
        <polyline points="2050,-625 2075,-600 2050,-575 2025,-600 2050,-625"/>
        <polyline points="2050,1175 2075,1200 2050,1225 2025,1200 2050,1175"/>
        <polyline points="-1550,1175 -1525,1200 -1550,1225 -1575,1200 -1550,1175"/>]]
       end
       HUD_HELM[#HUD_HELM+1]=[[</g>
        <g id="HorizonLines" class="linesHELM" transform="rotate(]].. -roll_hud ..[[,250,300) translate(0 ]].. pitch_hud*10 ..[[)"><polyline points="229,300 100,300 100,310"/><polyline points="271,300 400,300 400,310"/></g>
        <g class="circleHELM"><circle cx="250" cy="300" r="3"/></g>]]
       if speed_hud>=60 then HUD_HELM[#HUD_HELM+1]=[[<g id="VelVectorLine" class="linesHELM"><line x1="250" y1="300" x2="]].. (250 + yaw_space_hud*10) ..[[" y2="]].. (300 + pitch_space_hud*10) ..[["/></g>]] end
       HUD_HELM[#HUD_HELM+1]=[[<g class="linesHELM"><rect x="0" y="50" width="90" height="25"/><rect x="0" y="75" width="90" height="25"/>
        <g class="textHELM"><text text-anchor="middle" x="45" y="68">]].. speed_hud ..[[</text><text text-anchor="left" x="100" y="68">Km/h</text><text text-anchor="middle" x="45" y="93">]].. speedMS ..[[</text><text text-anchor="left" x="100" y="93">m/s</text></g></g>
        <g class="g_text"><text text-anchor="start" x="40" y="180">]].. planet_name ..[[<tspan text-anchor="start" x="40" y="210">G ]].. g_hud ..[[</tspan></text></g>
        <g class="linesHELM"><rect x="410" y="50" width="90" height="25"/><g class="textHELM"><text text-anchor="left" x="385" y="68">m</text><text text-anchor="middle" x="455" y="68">]].. altitude ..[[</text></g></g>
        <g class="wpHELM"><g transform="translate(]].. yaw_WP_hud*10 .." ".. pitch_WP_hud*10 ..[[)"><rect x="225" y="275" width="50" height="50"/></g></g>
        <g class="wpHELM"><line x1="250" y1="300" x2="]].. (250 + yaw_WP_hud*10) ..[[" y2="]].. (300 + pitch_WP_hud*10) ..[[" stroke-dasharray="5"/></g>
        </g></svg></td></tr></table></div>]]
       local HTML=table.concat(HUD_HELM)
       return HTML
      end

      function space_orientation_svg()
       local SVG={}
       SVG[#SVG+1]=[[
        <svg  width="100%" height="100%" viewbox="0 0 150 70" style="background-color:black">
        <g id="Dest" class="wpHELM"><circle cx="75" cy="35" r="12"/></g>
        <g id="DestVectorLine" style="stroke:]].. wp_color ..[[;stroke-width:1"><line x1="75" y1="35" x2="]].. (75 - yaw_WP_hud) ..[[" y2="]].. (35 - pitch_WP_hud) ..[["/></g>
        <g id="Nose" style="stroke:yellow;stroke-width:2" transform="translate(]].. -yaw_WP_hud .." ".. -pitch_WP_hud ..[[)"><line x1="65" y1="25" x2="85" y2="45"/><line x1="65" y1="45" x2="85" y2="25"/>]]
        if speed_hud>=60 then SVG[#SVG+1]=[[
        <g id="VelVector" style="stroke:white;stroke-width:1;fill:none" transform="translate(]].. yaw_space_hud .." ".. pitch_space_hud ..[[)"><circle cx="75" cy="35" r="10" style=" stroke-width: 2"/></g>
        <g id="VelVectorLine" style="stroke:white;stroke-width:1"><line x1="75" y1="35" x2="]].. (75 + yaw_space_hud) ..[[" y2="]].. (35 + pitch_space_hud) ..[["/></g>]]
        end
        SVG[#SVG+1]=[[</g><g style="font-size:12px">
        <text x="5" y="20" fill="white" text-anchor="start">]].. yaw_space_hud ..[[
        <tspan x="5" y="35" fill="yellow" text-anchor="start">Yaw</tspan>
        <tspan x="5" y="50" fill="]].. wp_color ..[[" text-anchor="start">]].. yaw_WP_hud ..[[</tspan></text>
        <text x="145" y="20" fill="white" text-anchor="end">]].. -pitch_space_hud ..[[
        <tspan x="145" y="35" fill="yellow" text-anchor="end">Pitch</tspan>
        <tspan x="145" y="50" fill="]].. wp_color ..[[" text-anchor="end">]].. -pitch_WP_hud ..[[</tspan>
        </text></g></svg>]]
       local HTML=table.concat(SVG)
       return HTML
      end

     --SVG ORBIT
      orbit_t_to_apo_seconds=0
      ship_PPOS_svg=vec3(core.getConstructWorldPos())
      function f_orbit_svg()
       if orbit_period_seconds>0 then map_scale_setting=2500
        if scale==nil then scale=map_scale_setting end
        scale=scale
        local fix=80
        local OrbCx=(orbit_per_alt + orbit_apo_alt + 2*planet_radius)/2/scale + fix
        local OrbRx=OrbCx - fix
        local PlCx=(OrbRx - ( orbit_ecc * OrbRx)) + fix
        local Plr=planet_radius/scale
        local OrbRy=math.sqrt(OrbRx^2 - (orbit_ecc * OrbRx)^2)
        local ApCx=OrbCx + OrbRx
        local ShCx1=PlCx
        local ShCx2=PlCx + my_planet_alt/scale
        local altitude=my_planet_alt - planet_radius
        local PeTargetAlt_svg=Plr + (PeTargetAlt/scale)
        local AtmoAlt_svg=planet_Atmo_alt/scale

        local b=my_planet_alt/scale
        local c=(OrbCx - PlCx)*2
        local a=(OrbRx * 2) - b
        if orbit_t_to_apo~=nil then
         if (orbit_period_seconds>0 and orbit_t_to_apo~="n/a" and (orbit_t_to_apo_seconds / orbit_period_seconds)>=0.5) then
          LineR=math.deg(math.acos((b^2 + c^2 - a^2) / (2 * b * c)))
          if (LineR~=LineR and (orbit_t_to_apo_seconds / orbit_period_seconds)>0.75) then
           LineR=0
          elseif (LineR~=LineR and (orbit_t_to_apo_seconds / orbit_period_seconds)<0.75) then
           LineR=180
          end
         else
          LineR=360 - (math.deg(math.acos((b^2 + c^2 - a^2) / (2 * b * c))))
          if (LineR~=LineR and (orbit_t_to_apo_seconds / orbit_period_seconds)>0.25) then
           LineR=180
          elseif (LineR~=LineR and (orbit_t_to_apo_seconds / orbit_period_seconds)<0.25) then
           LineR=0
          end
         end
        end

        if orbit_per_alt<(PeTargetAlt - 1000) then OrbCo=[[ red ]]
        else OrbCo=[[#00FFFF]] end
        if orbit_ecc==0 then orbit_Opacity=0
        else orbit_Opacity=100 end

        if orbit_ecc<1 then ship_PPOS_svg=vec3(core.getConstructWorldPos()) end

        local OrbRy_max=70
        local OrbRy_min=35
        local ApCx_max=330
        local ApCx_min=200
        local min_scale=1000

        if OrbRy>OrbRy_max then scale_O=scale*2 end
        if OrbRy<OrbRy_max then
         if OrbRy<OrbRy_min then scale_O=scale/2
         else scale_O=scale end
        end

        if ApCx>ApCx_max then scale_A=scale*2 end
        if ApCx<ApCx_max then
         if ApCx<ApCx_min then scale_A=scale/2
         else scale_A=scale end
        end

        scale=math.max(scale_O, scale_A, min_scale)

        return [[
         <svg width="360" height="150">
          <circle id="AtmoAlt" cx="]]..PlCx..[[" cy="75" r="]]..AtmoAlt_svg..[[" stroke-width="2" stroke="red" opacity="100%" fill="darkcyan" fill-opacity="10%" />
          <circle id="TargetPEAlt" cx="]]..PlCx..[[" cy="75" r="]]..PeTargetAlt_svg..[[" stroke-width="1" stroke="white" fill="none" />
          <circle id="Planet" cx="]]..PlCx..[[" cy="75" r="]]..Plr..[[" fill="darkslategrey" />
          <ellipse id="Orbit" cx="]]..OrbCx..[[" cy="75" rx="]]..OrbRx..[[" ry="]]..OrbRy..[[" style="fill:none;stroke:]]..OrbCo..[[;stroke-width:1;opacity:]]..orbit_Opacity..[[%" />
          <circle id="Pe" cx="]]..fix..[[" cy="75" r="3" stroke="green" stroke-width="1" fill="green" />
          <circle id="Ap" cx="]]..ApCx..[[" cy="75" r="3" stroke="green" stroke-width="2" fill="none" />
          <g transform=" rotate(]]..LineR.." "..ShCx1..[[ 75)">
           <line id="ship" x1="]]..ShCx1..[[" y1="75" x2="]]..ShCx2..[[" y2="75" stroke="yellow" stroke-width="2" opacity="100%"/>
          </g>
          <text x="10" y="20" fill="green" font-size="15px">Altitude:
           <tspan x="10" y="40" fill="yellow">]]..math.floor(altitude/1000*10)/10 ..[[</tspan><tspan fill="#00FFFF"> Km</tspan>
          </text>
          <text x="10" y="130" fill="green" font-size="15px">Circ Orb Speed:
           <tspan x="10" y="150" fill="yellow">]]..math.floor(orbit_circular_speed)..[[</tspan><tspan fill="#00FFFF"> m/s</tspan>
          </text>
          <text x="250" y="20" fill="green" font-size="15px">Map Scale:
           <tspan x="250" y="40" fill="yellow">]]..math.floor(scale)..[[</tspan>
          </text>
          <text x="250" y="130" fill="green" font-size="15px">Dist To PE:
           <tspan x="250" y="150" fill="yellow">]]..math.floor(pe_dis)..[[</tspan><tspan fill="#00FFFF"> Km</tspan>
          </text>
         </svg>
        ]]
       else
        return interplanet_svg()
       end
      end

     --SVG INTERPLANET
      nav_planet_scale=Planet_Scale_SPC_Mode
      function interplanet_svg()

       local myPos=vec3(core.getConstructWorldPos())

       if DbInitialised=="Verified" then
        if (databank.getNbKeys()~=0 and databank.getStringValue("navigator_from_coordinates")~="n/a" and databank.getStringValue("navigator_from")~="PPOS") then
         planet_A_coord=vec3FromStr(databank.getStringValue("navigator_from_coordinates"))
         from_name_hud=databank.getStringValue("navigator_from")
         planet_A_opacity=100
         from_planet_radius=databank.getIntValue("navigator_from_planet_radius")
         planet_A_radius=(20 / nav_planet_scale)* from_planet_radius
         x1_path=50 + planet_A_radius
         ship_x1=50 + planet_A_radius
         ship_x2=40 + planet_A_radius
        elseif (databank.getNbKeys()~=0 and databank.getStringValue("navigator_from_coordinates")~="n/a" and databank.getStringValue("navigator_from")=="PPOS") then
         planet_A_coord=vec3FromStr(databank.getStringValue("navigator_from_coordinates"))
         from_name_hud="PPOS"
         planet_A_opacity=0
         planet_A_radius=20
         x1_path=50
         ship_x1=50
         ship_x2=40
        else
         planet_A_coord=ship_PPOS_svg
         from_name_hud="PPOS"
         planet_A_opacity=0
         planet_A_radius=20
         x1_path=50
         ship_x1=50
         ship_x2=40
        end

        if (databank.getNbKeys()~=0 and databank.getStringValue("navigator_coordinates")~="n/a") then
         planet_B_coord=vec3FromStr(databank.getStringValue("navigator_coordinates"))
         to_name_hud=databank.getStringValue("navigator_target_destination")
         to_planet_radius=databank.getFloatValue("navigator_target_planet_radius")
         planet_B_radius=(20 / nav_planet_scale)* to_planet_radius
         x2_path=310 - planet_B_radius
        else
         planet_B_coord=planet_pos
         to_name_hud=planet_name
         to_planet_radius=planet_radius
         planet_B_radius=(20 / nav_planet_scale)* to_planet_radius
         x2_path=310 - planet_B_radius
        end
       else
        planet_A_coord=ship_PPOS_svg
        from_name_hud="PPOS"
        planet_A_opacity=0
        planet_B_coord=planet_pos
        to_name_hud=planet_name
        to_planet_radius=planet_radius
        planet_B_radius=(20 / nav_planet_scale)* to_planet_radius
        x2_path=310 - planet_B_radius

        x1_path=50
        planet_A_radius=20
        ship_x1=50
        ship_x2=40
       end

       distance_PPOS_B_hud=math.floor(((planet_B_coord - myPos):len())/1000/200*100)/100
       local distance_PPOS_A_hud=math.floor(((planet_A_coord - myPos):len())/1000/200*100)/100

       local ATA_h=(((planet_B_coord - myPos):len())/1000) / speed_hud --Hours
       local ATA_m=(ATA_h - math.floor(ATA_h))*60
       local ATA_s=(ATA_m - math.floor(ATA_m))*60
       local ATA_hud=math.floor(ATA_h) ..":".. math.floor(ATA_m) ..":".. math.floor(ATA_s)
       if speed_hud==0 then ATA_hud="n/a" end

       local tot_distance=distance_PPOS_A_hud + distance_PPOS_B_hud

       x1_x2_path=x2_path - x1_path

       if from_name_hud=="PPOS" then
        ship_pos_svg=x1_x2_path - (distance_PPOS_B_hud / tot_distance)*x1_x2_path
        if (distance_PPOS_B_hud / tot_distance)>0.5 then
         ship_pos_svg=ship_pos_svg + ((to_planet_radius/1000/200) / tot_distance)*x1_x2_path
        else ship_pos_svg=ship_pos_svg end
       elseif from_name_hud~="PPOS" then
        ship_pos_svg=(distance_PPOS_A_hud / tot_distance)*x1_x2_path
        if (distance_PPOS_A_hud / tot_distance)<0.5 then
         ship_pos_svg=ship_pos_svg - ((from_planet_radius/1000/200) / tot_distance)*x1_x2_path
        else ship_pos_svg=ship_pos_svg end
       end

       return [[
        <svg width="360" height="150">
         <line id="Path" x1="]]..x1_path..[[" y1="55" x2="]]..x2_path..[[" y2="55" stroke="yellow" stroke-width="1"/>

         <circle id="Planet_A" cx="50" cy="55" r="]]..planet_A_radius..[[" style="fill:darkslategrey;stroke:#00FFFF;stroke-width:1;opacity:]]..planet_A_opacity..[[" />
         <circle id="Planet_B" cx="310" cy="55" r="]]..planet_B_radius..[[" style="fill:darkslategrey;stroke:#00FFFF;stroke-width:1;" />

         <g transform="translate(]]..ship_pos_svg..[[ 0)">
          <polygon points="]]..ship_x1..[[,55 ]]..ship_x2..[[,63 ]]..ship_x2..[[,47" style="fill:#00FFFF;stroke:green;stroke-width:1;fill-rule:evenodd" />
         </g>
         <text x="10" y="15" fill="green" font-size="14px">From:
          <tspan x="10" y="30" fill="#00FFFF">]]..from_name_hud..[[</tspan>
         </text>
         <text x="140" y="15" fill="green" font-size="14px">Dist:
          <tspan x="140" y="30" fill="yellow">]]..tot_distance..[[</tspan><tspan fill="#00FFFF"> Su</tspan>
         </text>
         <text x="250" y="15" fill="green" font-size="14px">To:
          <tspan x="250" y="30" fill="#00FFFF">]]..to_name_hud..[[</tspan>
         </text>
         <text x="10" y="90" fill="green" font-size="14px">Dist:
          <tspan x="10" y="105" fill="yellow">]]..distance_PPOS_A_hud..[[</tspan><tspan fill="#00FFFF"> Su</tspan>
         </text>
         <text x="140" y="90" fill="green" font-size="14px">Fly Time:
          <tspan x="140" y="105" fill="yellow">]]..ATA_hud..[[</tspan>
         </text>
         <text x="250" y="90" fill="green" font-size="14px">Dist:
          <tspan x="250" y="105" fill="yellow">]]..distance_PPOS_B_hud..[[</tspan><tspan fill="#00FFFF"> Su</tspan>
         </text>
         <text x="10" y="130" fill="green" font-size="14px">Circ Orb Speed:
          <tspan x="10" y="145" fill="yellow">]]..math.floor(orbit_circular_speed)..[[</tspan><tspan fill="#00FFFF"> m/s</tspan>
         </text>
         <text x="250" y="130" fill="green" font-size="14px">Dist To PE:
          <tspan x="250" y="145" fill="yellow">]]..math.floor(pe_dis)..[[</tspan><tspan fill="#00FFFF"> Km</tspan>
         </text>
        </svg>
       ]]
      end

    --HTML SCREENS
     --CSS
      function html_style()
       local hud_pos_x=(ScrW/2)-251
       local hud_pos_y=(ScrH/2)-322
       local g_color=active_hud_color
       if shield_st_color==nil then shield_st_color="#ff3333" end
       if wp_color==nil then wp_color="none" end
       local css={}
       css[#css+1]=[[<style>
       .hud_spc {position:absolute;top:]].. hud_pos_y ..[[px;left:0px;}
       .hud_ai {position:absolute;top:]].. hud_pos_y ..[[px;left:]].. hud_pos_x ..[[px;}
       .linesHELM {stroke:]].. active_hud_color ..[[;stroke-width:1;fill:none;}
       .lines05HELM {stroke:]].. active_hud_color ..[[;stroke-width:0.5;fill:none;}
       .circleHELM {stroke:]].. active_hud_color ..[[;stroke-width:1;fill:]].. active_hud_color ..[[;}
       .pitchHELM {font-family:arial;font-size:12px;stroke-width:0;fill:]].. active_hud_color ..[[;}
       .textHELM {font-family:arial;font-size:15px;stroke-width:0;fill:]].. active_hud_color ..[[;}
       .wptext {font-family:arial;font-size:15px;stroke-width:0;fill:]].. wp_color ..[[;}
       .wpHELM {stroke:]].. wp_color ..[[;stroke-width:2;fill:none;}
       .alt_hold {font-family:arial;font-size:15px;stroke-width:0;fill:]].. alt_hold_color ..[[;}
       .g_effect {stroke:]].. g_color ..[[;stroke-width:2;fill:none;}
       .g_text {font-family:arial;font-size:15px;stroke-width:0;fill:]].. g_color ..[[;}
       .rh_m_div {position:absolute;bottom:2vh;right:14vw}
       .lh_m_div {position:fixed;bottom:2vh;right:]].. (ScrW/2)-90 ..[[px;}
       .top_lh_div {position:absolute;top:50vh;left:2vw;}
       .top_rh_div{position:absolute;top:50vh;right:14vw;}
       .tbl {border:1px solid yellow;text-align:center;vertical-align:middle;color:yellow;font-size: 12px;}
       .top {vertical-align:top;}
       .txcx {text-align:center;}
       .ecam {vertical-align:top;border: 1px solid slategray;text-align:left;}
       .ecam_rec {color:slategray;}
       .green {color:green;}
       .lgt_green {color:#7FFF00;}
       .yellow {color:yellow;}
       .red {color:red;}
       .rdr_hud {text-align:center;vertical-align:top;font-size: 9px;}
       .tomato{color:#ff3333;}
       .white {color:white;}
       .svg_box {border:1px solid #00FFFF;}
       .cyan {color:#00FFFF;}
       .left {text-align:left;}
       .right {text-align:right;}
       .f_right {float:right;}
       .px10 {font-size:10px;}
       .px16 {font-size:16px;}
       .shield_st {color:]]..shield_st_color..[[;}
       .an_lgt {border:1px solid slategray;}
       .ldmg {color:LightYellow;}
       .mdmg {color:gold;}
       .hdmg {color:DarkOrange;}
       .dead {color:Red;}
       .r {color:white;}
       </style>]]
       local HTML=table.concat(css)
       return HTML
      end

     --<DIV>
      local right_monitor_html=[[<div class="rh_m_div"><div class="window tbl"><table class="tbl">]]
      local left_monitor_html=[[<div class="lh_m_div"><div class="window tbl"><table class="tbl">]]
      local top_left_html=[[<div class="top_lh_div window tbl"><table class="left" width="360vw">]]
      local top_right_html=[[<div class="top_rh_div window tbl"><table>]]

     --RIGHT MONITOR
      function monitor_right()
       local RH_HTML={}
       RH_HTML[#RH_HTML+1]=html_style()..right_monitor_html..[[
       <tr height="30vh" class="green"><th width="40vw">Speed</th><td width="1vw" rowspan="5"></td><th width="40vw">Pitch</th><td width="1vw" rowspan="2"></td><th width="40vw">Roll</th><td width="1vw" rowspan="5"></td><th class="green left" width="70vw" colspan="2"><span class="yellow">]]..a_fuel_tank_n..[[</span>&nbspA F T</th><th class="green left" width="70vw" colspan="2"><span class="yellow">]]..s_fuel_tank_n..[[</span>&nbspS F T</th><th class="green left" width="70vw" colspan="2"><span class="yellow">]]..r_fuel_tank_n..[[</span>&nbspR F T</th></tr>
       <tr height="30vh"><td>]]..speed_hud..[[</td><td>]]..pitch_hud..[[</td><td>]]..roll_direction..[[</td><td width="30vw">]]..a_fuel_percent_avg_hud..[[</td><td width="40vw">%</td><td width="30vw">]]..s_fuel_percent_avg_hud..[[</td><td width="40vw">%</td><td width="30vw">]]..r_fuel_percent_avg_hud..[[</td><td width="40vw">%</th></tr>
       <tr height="30vh"><td class="cyan">]]..thr_hud..[[</td><td colspan="3">]]..radar_warning_hud..[[</td><td class="svg_box" rowspan="3">]]..a_fuel_svg()..[[</td><td>]]..math.floor(a_t_h)..[[</td><td class="svg_box" rowspan="3">]]..s_fuel_svg()..[[</td><td>]]..math.floor(s_t_h)..[[</td><td class="svg_box" rowspan="3">]]..r_fuel_svg()..[[</td><td>]]..math.floor(r_t_h)..[[</td></tr>
       <tr height="30vh"><td class="svg_box" rowspan="2">]]..thr_svg()..[[</td><td class="green left" colspan="3">&nbspAlt&nbsp&nbsp<span class="yellow right">]]..altitude..[[</span>&nbsp</td><td>]]..math.floor(a_t_m)..[[</td><td>]]..math.floor(s_t_m)..[[</td><td>]]..math.floor(r_t_m)..[[</td></tr>
       <tr height="30vh"><td class="green left" colspan="3">&nbspV/S&nbsp&nbsp<span class="yellow right">]]..vs_hud..[[</span>&nbsp</td><td>]]..math.floor(a_t_s)..[[</td><td>]]..math.floor(s_t_s)..[[</td><td>]]..math.floor(r_t_s)..[[</td></tr>
       </table></div></div>]]
       local HTML=table.concat(RH_HTML)
       return HTML
      end

     --OPTION 1 (Loading page)
      function monitor_left_loading()
       active_hud_mode="LOAD Mode"
       local gnd_alt=math.floor(unit.getSurfaceEngineAltitudeStabilization())
       local HUD_LOAD={}
       HUD_LOAD[#HUD_LOAD+1]=html_style()..left_monitor_html..[[
        <tr height="25vh"><td width="1vw" rowspan="6"></td><td class="shield_st" colspan="3">Shield: ]]..shield_percent..[[</td><td width="1vw" rowspan="6"></td><td class="tbl">LOAD</td><th class="tbl green" colspan="4" width="180vw">LOAD&nbsp&nbspDOW:&nbsp&nbsp<span class="yellow">]]..dow_m..[[</span>&nbsp<span class="cyan">t</span></th></tr>
        <tr height="25vh"><td width="40vw" class="an_lgt" style="color:]]..ldg_st..[[">LDG</td><td width="40vw" class="an_lgt" style="color:]]..ldg_st..[[">]]..gnd_alt..[[</td><td width="40vw" class="an_lgt" style="color:]]..r_active_hud..[[">ROCKET</td><td width="50vw" class="tbl cyan">AI</td><td class="left green">&nbspLOAD</td><td class="right">]]..cargo_m_t_hud..[[<span class="cyan">&nbspt&nbsp</span></td><td width="10vw" rowspan="4"></td><td width="30vw" class="px10 green">MTOW<br><span class="cyan">&nbsp]]..math.floor(MTOW/1000*10)/10 ..[[&nbspt</span></td></tr>
        <tr height="25vh"><td class="an_lgt">]]..a_fuelspy_hud..[[</td><td class="an_lgt">]]..s_fuelspy_hud..[[</td><td class="an_lgt">]]..r_fuelspy_hud..[[</td><td class="tbl cyan">SPC</td><td class="left green">&nbspZFW</td><td class="right">]]..zfw_m..[[<span class="cyan">&nbspt&nbsp</span></td><td>]]..MTOW_p..[[&nbsp%</td></tr>
        <tr height="25vh"><td class="tbl ecam" rowspan="3" colspan="3">]]..ECAM()..[[</td><td class="tbl cyan">ORB</td><td class="left green">&nbsp Fuel</td><td class="right">]]..fuel_mass..[[<span class="cyan">&nbspt&nbsp</span></td><td class="svg_box" rowspan="2">]]..MTOW_svg()..[[</td></tr>
        <tr height="25vh"><td class="tbl" style="color:]]..dmg_color..[[">DMG</td><td class="left green">&nbspGW</td><td class="right">]]..gw_m..[[<span class="cyan">&nbspt&nbsp</span></td></tr>
        <tr><td class="tbl" colspan="5"></td></tr>
       </table></div></div>]]
       art_h_svg()
       local HTML=table.concat(HUD_LOAD)
       return HTML
      end

     --OPTION 2 (AI page)
      function monitor_left_atmo()
       active_hud_mode="AI Mode"
       local HUDDistance=""
       if databank then ToWp=databank.getStringValue("navigator_target_destination") else ToWp="WP" end
       if (distance_to_wp=="n/a" or speed_hud<50) then time_to_wp_hud="n/a"
       else
        local ATA_h=tonumber(distance_to_wp) / speed_hud
        local ATA_m=(ATA_h - math.floor(ATA_h))*60
        local ATA_s=(ATA_m - math.floor(ATA_m))*60
        time_to_wp_hud=math.floor(ATA_h) ..":".. math.floor(ATA_m) ..":".. math.floor(ATA_s)
       end
       local gnd_alt=math.floor(unit.getSurfaceEngineAltitudeStabilization())

       if tonumber(distance_to_wp)~=nil then
        local Distance=tonumber(distance_to_wp)
        if Distance>200 then Distance=math.floor((Distance/200)*100)/100 ..[[</span> <span class="cyan">Su</span>]]
        else Distance=Distance  ..[[</span> <span class="cyan">Km</span>]] end
        HUDDistance=Distance
       else HUDDistance=distance_to_wp end

       local HUD_AI={}
       HUD_AI[#HUD_AI+1]=html_style()..left_monitor_html..[[
        <tr height="25vh"><td width="1vw" rowspan="6"></td><td class="shield_st" colspan="3">Shield: ]]..shield_percent..[[</td><td width="1vw" rowspan="6"></td><td class="tbl cyan">LOAD</td><td class="left lgt_green" width="180vw"> &nbsp;Docking Mode:<span class="f_right yellow">]]..DockingMode..[[ &nbsp;</span></td></tr>
        <tr height="25vh"><td width="40vw" class="an_lgt" style="color:]]..ldg_st..[[">LDG</td><td width="40vw" class="an_lgt" style="color:]]..ldg_st..[[">]]..gnd_alt..[[</td><td width="40vw" class="an_lgt" style="color:]]..r_active_hud..[[">ROCKET</td><td width="50vw" class="tbl">AI</td><td>]]..ConstructDocked..[[</td></tr>
        <tr height="25vh"><td class="an_lgt">]]..a_fuelspy_hud..[[</td><td class="an_lgt">]]..s_fuelspy_hud..[[</td><td class="an_lgt">]]..r_fuelspy_hud..[[</td><td class="tbl cyan">SPC</td><td></td></tr>
        <tr height="25vh"><td class="tbl ecam" rowspan="2" colspan="3">]]..ECAM()..[[</td><td class="tbl cyan">ORB</td><td class="left"> &nbsp;<span class="lgt_green">DOCKED: &nbsp;</span>]]..DockedConstructs..[[<span class="f_right">Mass: &nbsp;]]..DockedMass..[[ &nbsp;<span class="cyan">t &nbsp;</span></span></td></tr>
        <tr height="25vh"><td class="tbl" style="color:]]..dmg_color..[[">DMG</td><td class="left"> &nbsp;<span class="lgt_green">CREW + PAX: &nbsp;</span>]]..PaxOnBoard..[[<span class="f_right">Mass: &nbsp;]]..PaxOnBoardMass..[[ &nbsp;<span class="cyan">t &nbsp;</span></span></td></tr>
        <tr><td colspan="3"></td><td></td><td></td></tr>
       </table></div></div>]]
       local HTML=table.concat(HUD_AI) .. art_h_svg()
       return HTML
      end

     --OPTION 3 (Space page)
      function monitor_left_space()
       active_hud_mode,final_speed_brk="SPC Mode",0
       if warpdrive then
        warp_data=json.decode(warpdrive.getData())
        warp_cells_hud=warp_data.cellCount
        if (warp_data.destination~=Unknown and warp_data.destination~=navigator_target_destination_hud) then
         warp_destination=[[<br><span class="green">Warp to: </span>]]..warp_data.destination..[[&nbsp<span class="red">]]..warp_data.statusText..[[</span>]]
         destination_hud_spc=[[</span>&nbspTo:&nbsp<span class="cyan">]]..navigator_target_destination_hud..[[&nbsp]]..warp_destination..[[</span>]]
        elseif (warp_data.destination~=Unknown and warp_data.destination==navigator_target_destination_hud) then
         destination_hud_spc=[[</span>&nbspWarp To:&nbsp<span class="cyan">]]..warp_data.destination..[[</span><br><span class="red">]]..warp_data.statusText..[[</span>]]
        end
        if (warp_data.statusText~="NO DESTINATION" and warp_data.statusText~="PLANET TOO CLOSE") then warpdrive.show() else warpdrive.hide() end
       else
        warp_cells_hud="n/a"
        destination_hud_spc=[[</span>&nbspTo:&nbsp<span class="cyan">]]..navigator_target_destination_hud..[[</span>]]
       end
       local gnd_alt,SZ=math.floor(unit.getSurfaceEngineAltitudeStabilization()),""
       if (SafeZoneBorder>200000 or SafeZoneBorder<-200000) then SZ=math.floor(SafeZoneBorder/200000*100)/100 ..[[ <span class="cyan">Su</span>]]
       else SZ=math.floor(SafeZoneBorder/1000*10)/10 ..[[ <span class="cyan">Km</span>]] end
       if SafeZoneBorder<0 then SZ=[[<span class="red">]]..SZ..[[</span>]] end
       speedMS=math.floor(speed_hud/3.6)

       local HUD_SPC={}
       HUD_SPC[#HUD_SPC+1]=html_style()..top_left_html..[[
        <tr height="30vh" class="px16"><td width="1vw" rowspan="5"></td><td class="green left" colspan="3">From:&nbsp<span class="cyan">]]..navigator_from_hud..[[&nbsp]]..destination_hud_spc..[[</td></tr>
        <tr height="30vh"><th class="green">Dist.</th><td>]]..navigator_distance_hud..[[<span class="cyan">&nbspSu</span></td><td colspan="2" rowspan="4" width="180vw" height="120vh">]]..space_orientation_svg()..[[</td></tr>
        <tr height="30vh"><th class="green">Speed:</th><td>]]..navigator_speed_hud..[[<span class="cyan">&nbspKm/h</span></td></tr>
        <tr height="30vh"><th class="green">Time:</th><td>]]..navigator_eta_hud..[[</td></tr>
        <tr height="30vh"><th class="green">Warp C.</th><td>]]..warp_cells_hud..[[</td></tr>
       </table></div>
       ]]..top_right_html..[[
        <tr height="150vh"><td width="360vw">]]..interplanet_svg()..[[<td></tr>
        <tr><td>&nbspAuto Brake in:&nbsp<span class="white">]]..autobrake_in..[[</span>&nbsp<span class="cyan">Su</span> - <span class="white">]]..autobrake_stops_at..[[</span>&nbsp<span class="cyan">Su</span>&nbspFrom Dest.</td></tr>
       </table></div>
       ]]..left_monitor_html..[[
        <tr height="25vh"><td width="1vw" rowspan="6"></td><td class="shield_st" colspan="3">Shield: ]]..shield_percent..[[</td><td width="1vw" rowspan="6"></td><td class="tbl cyan">LOAD</td><th class="tbl green" colspan="2" width="180vw">Safe Zone Border <span class="f_right yellow">]].. SZ ..[[</span></th></tr>
        <tr height="25vh"><td width="40vw" class="an_lgt" style="color:]]..ldg_st..[[">LDG</td><td width="40vw" class="an_lgt" style="color:]]..ldg_st..[[">]]..gnd_alt..[[</td><td width="40vw" class="an_lgt" style="color:]]..r_active_hud..[[">ROCKET</td><td width="50vw" class="tbl cyan">AI</td><td class="green">Braking</td><td>]]..rrThrust_hud..[[<span class="cyan">&nbspkN</span></td></tr>
        <tr height="25vh"><td class="an_lgt">]]..a_fuelspy_hud..[[</td><td class="an_lgt">]]..s_fuelspy_hud..[[</td><td class="an_lgt">]]..r_fuelspy_hud..[[</td><td class="tbl">SPC</td><td class="green">Stop in:</td><td>]]..brake_su..[[<span class="syan">&nbspSu</span></td></tr>
        <tr height="25vh"><td class="tbl ecam" rowspan="3" colspan="3">]]..ECAM()..[[</td><td class="tbl cyan">ORB</td><td></td><td>]]..brake_km..[[<span class="cyan">&nbspKm</span></td></tr>
        <tr height="25vh"><td td class="tbl" style="color:]]..dmg_color..[[">DMG</td><td></td><td>]]..brake_min..[[<span class="cyan">'&nbsp</span>]]..brake_sec..[[<span class="cyan">"</span></td></tr>
        <tr><td class="tbl" colspan="3"></td></tr>
       </table></div></div>]]
       local HTML=table.concat(HUD_SPC) .. spc_hud()
       return HTML
      end

     --OPTION 4 (Orbit page)
      function monitor_left_orbit()
       active_hud_mode,final_speed_brk="ORB Mode",(orbit_circular_speed)/1000*60*60
       local gnd_alt=math.floor(unit.getSurfaceEngineAltitudeStabilization())
       local AtmoAltitude=math.floor(planet_Atmo_alt-planet_radius)
       if AtmoAltitude<=0 then AtmoAltitude=0 end
       local PEAltColor="yellow"
       if orbit_per_alt<=AtmoAltitude then PEAltColor="red" else PEAltColor="yellow" end
       local APAltColor="yellow"
       if orbit_apo_alt<=AtmoAltitude then APAltColor="red" else APAltColor="yellow" end
       speedMS=math.floor(speed_hud/3.6)

       local HUD_ORB={}
       HUD_ORB[#HUD_ORB+1]=html_style()..top_left_html..[[
        <tr height="30vh" class="px16"><td width="1vw" rowspan="6"></td><th width="360vw" colspan="4" class="green">ORBIT&nbsp&nbsp<span class="cyan">]]..planet_name..[[&nbsp&nbsp</span><span class="yellow">]]..math.floor(my_planet_alt/1000/200*100)/100 ..[[</span><span class="cyan">&nbsp&nbspSu</span></th></tr>
        <tr height="30vh"><td class="green">Atmosphere Altitude</td><td>]]..AtmoAltitude..[[&nbsp<span class="cyan">m</span></td><td></td><td></td></tr>
        <tr height="30vh"><td class="green">ECC</td><td>]]..orbit_ecc..[[</td><td class="green">T</td><td>]]..orbit_period..[[</td></tr>
        <tr height="30vh"><td class="green">PE Alt</td><td class="]]..PEAltColor..[[">]]..orbit_per_alt..[[&nbsp<span class="cyan">m</span></td><td class="green">AP Alt</td><td class="]]..APAltColor..[[">]]..orbit_apo_alt..[[&nbsp<span class="cyan">m</span></td></tr>
        <tr height="30vh"><td class="green">PE Speed</td><td>]]..orbit_per_speed..[[&nbsp<span class="cyan">m/s</span></td><td class="green">AP Speed</td><td>]]..orbit_apo_speed..[[&nbsp<span class="cyan">m/s</span></td></tr>
        <tr height="30vh"><td class="green">T to PE</td><td>]]..orbit_t_to_per..[[</td><td class="green">T to AP</td><td>]]..orbit_t_to_apo..[[</td></tr>
       </table></div>
       ]]..top_right_html..[[
        <tr height="150vh"><td width="360vw">]]..f_orbit_svg()..[[<td></tr>
        <tr><td class="left">&nbspTarget PE Altitude&nbsp<span class="white">]]..PeTargetAlt..[[</span>&nbsp<span class="cyan">m</span>
        <span class="f_right">Atmosphere Altitude<span class="white"> ]]..AtmoAltitude..[[</span>&nbsp<span class="cyan">m</span></td></tr>
       </table></div>
       ]]..left_monitor_html..[[
        <tr height="25vh"><td width="1vw" rowspan="6"></td><td class="shield_st" colspan="3">Shield: ]]..shield_percent..[[</td><td width="1vw" rowspan="6"></td><td class="tbl cyan">LOAD</td><th class="tbl green" colspan="2" width="180vw">Orbit&nbsp&nbsp<span class="yellow">]]..speedMS..[[</span><span class="cyan">&nbspm/s</span></tr>
        <tr height="25vh"><td width="40vw" class="an_lgt" style="color:]]..ldg_st..[[">LDG</td><td width="40vw" class="an_lgt" style="color:]]..ldg_st..[[">]]..gnd_alt..[[</td><td width="40vw" class="an_lgt" style="color:]]..r_active_hud..[[">ROCKET</td><td width="50vw" class="tbl cyan">AI</td><td class="green">Brake at:</td><td>]]..brake_km..[[&nbsp<span class="cyan">Km</span></td></tr>
        <tr height="25vh"><td class="an_lgt">]]..a_fuelspy_hud..[[</td><td class="an_lgt">]]..s_fuelspy_hud..[[</td><td class="an_lgt">]]..r_fuelspy_hud..[[</td><td class="tbl cyan">SPC</td><td colspan="2" rowspan="3"  width="180vw" height=" 75vh">]] .. space_orientation_svg() .. [[</td></tr>
        <tr height="25vh"><td class="tbl ecam" rowspan="3" colspan="3">]]..ECAM()..[[</td><td class="tbl">ORB</td></tr>
        <tr height="25vh"><td td class="tbl" style="color:]]..dmg_color..[[">DMG</td></tr>
        <tr><td class="tbl" colspan="3"></td></tr>
       </table></div></div>]]
       local HTML=table.concat(HUD_ORB) .. spc_hud()
       return HTML
      end

     --OPTION 5 (Damage page)
      function monitor_left_damage()
       active_hud_mode="DMG Mode"
       dmgrep=DamageModule.new()
       damage_html=dmgrep:renderHTML()
       local dmg_table_html=dead_elem_list_hud..high_damage_list_hud..medium_damage_list_hud..light_damage_list_hud
       local gnd_alt=math.floor(unit.getSurfaceEngineAltitudeStabilization())

       local HUD_DMG={}
       HUD_DMG[#HUD_DMG+1]=html_style()..top_left_html..[[
        <tr height="150vh"><td class="txcx" width="360vw">TOP VIEW<hr>]]..top_view_html_hud..[[</td></tr>
       </table></div>
       ]]..top_right_html..[[
        <tr height="150vh"><td width="360vw">SIDE VIEW<hr>]]..side_view_html_hud..[[</td></tr>
       </table></div>
       ]]..left_monitor_html..[[
        <tr height="25vh"><td width="1vw" rowspan="6"></td><td class="shield_st" colspan="3">Shield: ]]..shield_percent..[[</td><td width="1vw" rowspan="6"></td><td class="tbl cyan">LOAD</td><td width="180vw" class="tbl tomato">Damages Report</td></tr>
        <tr height="25vh"><td width="40vw" class="an_lgt" style="color:]]..ldg_st..[[">LDG</td><td width="40vw" class="an_lgt" style="color:]]..ldg_st..[[">]]..gnd_alt..[[</td><td width="40vw" class="an_lgt" style="color:]]..r_active_hud..[[">ROCKET</td><td width="50vw" class="tbl cyan">AI</td><td rowspan="4" height="75vh" class="top left">]]..dmg_table_html..[[</td></tr>
        <tr height="25vh"><td class="an_lgt">]]..a_fuelspy_hud..[[</td><td class="an_lgt">]]..s_fuelspy_hud..[[</td><td class="an_lgt">]]..r_fuelspy_hud..[[</td><td class="tbl cyan">SPC</td></tr>
        <tr height="25vh"><td class="tbl ecam" rowspan="3" colspan="3">]]..ECAM()..[[</td><td class="tbl cyan">ORB</td></tr>
        <tr height="25vh"><td td class="tbl">DMG</td></tr>
        <tr><td class="tbl" colspan="2"></td></tr>
       </table></div></div>]]
       local HTML=table.concat(HUD_DMG)
       return HTML
      end

    --HTML ASSEMBLER
     function html_assemble()
      air_data()
      left_panel=monitor_left_loading()
      right_panel=monitor_right()
      hud=right_panel
      hud=hud .. left_panel
      system.setScreen(hud)
      system.showScreen(1)
     end
     html_assemble()

    --TIMER
     unit.setTimer("loading_pg", 1/30)
  tick:
   args: [loading_pg]
   lua: |
    if atmofueltank_size~=0 then atmo_fuel_percent() a_fuel_minimum_time() end
    if spacefueltank_size~=0 then space_fuel_percent() s_fuel_minimum_time() end
    if rocketfueltank_size~=0 then rocket_fuel_percent() r_fuel_minimum_time() r_warning_light() end
    avg_fuel_percentage()
    landing_gear()
    f_lights_st()
    f_loading_data()
    gw_m=math.floor(core.getConstructMass()/1000*10)/10
    zfw_m=gw_m - fuel_mass
    dow_m=gw_m - fuel_mass - cargo_m_t
    MTOW_p=math.floor(gw_m*1000/MTOW*100)
    total_fuel_mass()
    if DMG_Report==true then dmg_checker() end
    if radar_1 then radar_contacts() end
    if shield then shield_function() end

    left_panel=monitor_left_loading()
    right_panel=monitor_right()
    hud=right_panel
    hud=hud .. left_panel
    system.setScreen(hud)
  tick:
   args: [atmo_pg]
   lua: |
    if atmofueltank_size~=0 then atmo_fuel_percent() a_fuel_minimum_time() end
    if spacefueltank_size~=0 then space_fuel_percent() s_fuel_minimum_time() end
    if rocketfueltank_size~=0 then rocket_fuel_percent() r_fuel_minimum_time() r_warning_light() end
    avg_fuel_percentage()
    Docking()
    landing_gear()
    f_lights_st()
    if DMG_Report==true then dmg_checker() end
    f_radioalt_hud()
    distance_to_wp_ai()
    space_orientation()
    if radar_1 then radar_contacts() end
    if shield then shield_function() end
    if (altitude_hold==true and auto_wp==true) then
     local wp=databank.getStringValue("navigator_target_destination")
     local ext=databank.getStringValue("wp_settings"):gsub("@@@","\"")
     ext=json.decode(ext)
     if (ext[wp] and density>1) then
      local alt=ext[wp].alt
      if alt~="" then TargetAltitude=tonumber(alt) end
      local speed=ext[wp].s
      if databank.getIntValue("Holding")==1 then
       local h_speed=databank.getIntValue("holding_speed")
       if tonumber(h_speed)~=0 then speed=h_speed end
      end
      if (speed~="" and unit.getControlMasterModeId()==1) then
       local thr=math.floor(unit.getThrottle())
       thr=math.floor(thr/100)
       if thr<tonumber(speed) then Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 1.0)
       elseif thr>tonumber(speed) then Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -1.0) end
      end
     end
    end

    left_panel=monitor_left_atmo()
    hud=right_panel
    hud=hud .. left_panel
    system.setScreen(hud)
  tick:
   args: [orbit_pg]
   lua: |
    if atmofueltank_size~=0 then atmo_fuel_percent() a_fuel_minimum_time() end
    if spacefueltank_size~=0 then space_fuel_percent() s_fuel_minimum_time() end
    if rocketfueltank_size~=0 then rocket_fuel_percent() r_fuel_minimum_time() r_warning_light() end
    avg_fuel_percentage()
    landing_gear()
    f_lights_st()
    if DMG_Report==true then dmg_checker() end
    f_radioalt_hud()
    distance_to_wp_ai()
    f_rrThrust_hud()
    braking_distance(final_speed_brk)
    orbital_data()
    space_orientation()
    databank_condition()
    if radar_1 then radar_contacts() end
    if shield then shield_function() end
    g_hud=math.floor(((core.g())/10)*10)/10

    left_panel=monitor_left_orbit()
    hud=right_panel
    hud=hud .. left_panel
    system.setScreen(hud)
  tick:
   args: [space_pg]
   lua: |
    if atmofueltank_size~=0 then atmo_fuel_percent() a_fuel_minimum_time() end
    if spacefueltank_size~=0 then space_fuel_percent() s_fuel_minimum_time() end
    if rocketfueltank_size~=0 then rocket_fuel_percent() r_fuel_minimum_time() r_warning_light() end
    avg_fuel_percentage()
    landing_gear()
    f_lights_st()
    if DMG_Report==true then dmg_checker() end
    f_radioalt_hud()
    distance_to_wp_ai()
    f_rrThrust_hud()
    orbital_data()
    braking_distance(final_speed_brk)
    if DbInitialised=="Verified" then
     if databank.getFloatValue("navigator_autobrake")~=nil then autobrake_stops_at=databank.getFloatValue("navigator_autobrake")
     else autobrake_stops_at=Autobrake_Stop_Distance end
    else autobrake_stops_at=Autobrake_Stop_Distance end
    space_orientation()
    databank_condition()
    if radar_1 then radar_contacts() end
    if shield then shield_function() end
    g_hud=math.floor(((core.g())/10)*10)/10

    left_panel=monitor_left_space()
    hud=right_panel
    hud=hud .. left_panel
    system.setScreen(hud)
  tick:
   args: [damage_pg]
   lua: |
    if atmofueltank_size~=0 then atmo_fuel_percent() a_fuel_minimum_time() end
    if spacefueltank_size~=0 then space_fuel_percent() s_fuel_minimum_time() end
    if rocketfueltank_size~=0 then rocket_fuel_percent() r_fuel_minimum_time() r_warning_light() end
    avg_fuel_percentage()
    f_radioalt_hud()
    landing_gear()
    f_lights_st()
    if radar_1 then radar_contacts() end
    if shield then shield_function() end

    left_panel=monitor_left_damage()
    hud=right_panel
    hud=hud .. left_panel
    system.setScreen(hud)
  tick:
   args: [autobrake]
   lua: |
    --AUTOBRAKE
     autobrake_function()
  tick:
   args: [maintaning_orbit]
   lua: |
    --MAINTAINING ORBIT
     maintaining_orbit()
  tick:
   args: [delay3sec]
   lua: |
    --3 SECONDS DELAY
     if autopilot_ecam_mode==[[<span class="tomato">Adjust Attitude</span><br><span class="cyan">Max Bank 45<br>Max Pitch +25 -15</span><br>]] then
      autopilot_ecam_mode=[[ ]]
      unit.stopTimer("delay3sec")
     end
     if (autopilot_ecam_mode==[[Autopilot ON - Mode 2]]) then orbiting_mode_delay()
     elseif (autopilot_ecam_mode==[[Autopilot ON - Mode 3]]) then destination_mode_delayed()
     end
  tick:
   args: [countdown]
   lua: |
    --3 SECONDS COUNTDOWN
     if (autopilot_ecam_mode==[[Autopilot ON - Mode 2]]) then
      time_to_align=time_to_align - 1
      adjusting_mode=[[Mainteining Orbit in: ]] .. time_to_align
     elseif (autopilot_ecam_mode==[[Autopilot ON - Mode 3]]) then
      time_to_align=time_to_align - 1
      adjusting_mode=[[Align to DEST in: ]] .. time_to_align
     end
  tick:
   args: [antigravity]
   lua: |
    --ANTIGRAVITY
     agg_b_alt=antigrav.getBaseAltitude()
     databank.setIntValue("agg_b_alt", agg_b_alt)
     local new_alt=databank.getIntValue("agg_t_alt")
     if new_alt~=antigrav_target_alt then
      antigrav_target_alt=new_alt
      antigrav.setBaseAltitude(antigrav_target_alt)
     end
     local state=antigrav.getState()
     if state==1 then
      databank.setStringValue("agg eng/stby", "ENG")
      databank.setStringValue("agg off/stby", "ACTIVE")
      agg_ecam_mode=[[AGG ON]]
     elseif state==0 then
      databank.setStringValue("agg eng/stby", "STBY")
      databank.setStringValue("agg off/stby", "STBY")
      agg_ecam_mode=[[<span class="cyan">AGG ARM</span>]]
     end
  tick:
   args: [antigravity_op]
   lua: |
    --ANTIGRAVITY OPERATION
     if databank.getStringValue("nav agg")~=navi_agg_op then
      navi_agg_op=databank.getStringValue("nav agg")
      if navi_agg_op=="OFF" then
       unit.stopTimer("antigravity", 1)
       databank.setStringValue("agg eng/stby", "STBY")
       databank.setStringValue("agg off/stby", "OFF")
       antigrav.hide()
       antigrav.deactivate()
       atigrav_widget=false
       antigrav_armed=false
       agg_ecam_mode=[[ ]]
      elseif navi_agg_op=="STBY" then
       antigrav.show()
       antigrav.deactivate()
       atigrav_widget=true
       antigrav_armed=true
       agg_ecam_mode=[[<span class="cyan">AGG ARM</span>]]
       databank.setStringValue("agg eng/stby", "STBY")
       databank.setStringValue("agg off/stby", "STBY")
       unit.setTimer("antigravity", 1)
      elseif navi_agg_op=="ENG" then
       unit.stopTimer("delay3sec")
       unit.stopTimer("countdown")
       unit.stopTimer("maintaning_orbit")
       auto_aligner=false
       prograde_mode=false
       destination_mode=false
       altitude_hold=false
       align_active_mode=[[ ]]
       adjusting_mode=[[ ]]
       autopilot_ecam_mode=[[ ]]
       alt_hold_color="none"
       agg_ecam_mode=[[AGG ON]]
       antigrav.activate()
      end
    end
  tick:
   args: [PVPupdate]
   lua: |
    if radar_1.isOperational()==1 then
     FleetListFunction()
     TargetListFunction()
     Target()
     if weaponlinked then wepdat() end
     radarData=getRadarData(radar_1.getData())
     system.updateData(radarDataValue, radarData)
    else
     system.destroyWidgetPanel(radarPanel)
     _autoconf.hideCategoryPanels()
     unit.setTimer("CheckRadarOp", 1)
     unit.stopTimer("PVPupdate")
     unit.stopTimer("PVPsender")
     RDRMaxRange,TargetList,TargetTotal,TargetInfo,ThreatList,AbandonedList=0,{},0,{},{},{} 
     SendingData()
    end
  tick:
   args: [PVPsender]
   lua: |
    local isIdentified=radar_1.getIdentifiedConstructIds()
    if #isIdentified>0 then TargetInfoFunction() else TargetInfo={} end
    if (databank and radar_1.isOperational()==1) then SendingData() end
  tick:
   args: [CheckRadarOp]
   lua: |
    if radar_1.isOperational()==1 then
     unit.stopTimer("CheckRadarOp")
     PVPStation()
    end
  stop:
   lua: |
    _autoconf.hideCategoryPanels()
    if antigrav~=nil then antigrav.hide() end
    if warpdrive~=nil then warpdrive.hide() end
    if shield~=nil then shield.hide() end
    if gyro~=nil then gyro.hide() end
    core.hide()
    Nav.control.switchOffHeadlights()
    if gyro then gyro.deactivate() end
    if databank then
     if UnitIsCockpit then databank.setStringValue("PVPCockpit", "OFF")
     elseif (UnitIsSeat and UnitType~="RemoteControlUnit") then databank.setStringValue("PVPGunner", "OFF")
     end
     if UnitType~="RemoteControlUnit" then databank.setStringValue("PVPStationData", "") end
    end
    system.showScreen(0)
 system:
  flush:
   lua: |
    --constants
    local pitchSpeedFactor=0.8
    local yawSpeedFactor=1
    local rollSpeedFactor=1.5
    local brakeSpeedFactor=3
    local brakeFlatFactor=1 --export: Increase the brake force (between 0.01 and 1)
    local autoRoll=autoRoll_activated
    local autoRollFactor=2
    local turnAssist=true
    local turnAssistFactor=2
    local torqueFactor=2 --export
    --validate params
    pitchSpeedFactor=math.max(pitchSpeedFactor, 0.01)
    yawSpeedFactor=math.max(yawSpeedFactor, 0.01)
    rollSpeedFactor=math.max(rollSpeedFactor, 0.01)
    torqueFactor=math.max(torqueFactor, 0.01)
    brakeSpeedFactor=math.max(brakeSpeedFactor, 0.01)
    brakeFlatFactor=math.max(brakeFlatFactor, 0.01)
    autoRollFactor=math.max(autoRollFactor, 0.01)
    turnAssistFactor=math.max(turnAssistFactor, 0.01)
    --final inputs
    local finalPitchInput=pitchInput + system.getControlDeviceForwardInput()
    local finalRollInput=rollInput + system.getControlDeviceYawInput()
    local finalYawInput=yawInput - system.getControlDeviceLeftRightInput()
    local finalBrakeInput=brakeInput
    --Axis
    local worldVertical=0
    if antigrav then
     if antigrav.getState()==1 then worldVertical=vec3(core.getWorldVertical())
     else worldVertical=vec3(core.getWorldGravity()) end
    else worldVertical=vec3(core.getWorldGravity()) end
    local constructUp=vec3(core.getConstructWorldOrientationUp())
    local constructForward=vec3(core.getConstructWorldOrientationForward())
    local constructRight=vec3(core.getConstructWorldOrientationRight())
    local constructVelocity=vec3(core.getWorldVelocity())
    local constructVelocityDir=vec3(core.getWorldVelocity()):normalize()
    local currentRollDeg=getRoll(worldVertical, constructForward, constructRight)
    local currentRollDegAbs=math.abs(currentRollDeg)
    local currentRollDegSign=utils.sign(currentRollDeg)
    --Rotation
    local constructAngularVelocity=vec3(core.getWorldAngularVelocity())

    --ALTITUDE HOLD
    if altitude_hold==true then
     altitude_hold_function()

     local LimitPitchDeg=getRoll(worldVertical, constructRight, -constructForward)
     local currentPitchDeg=math.max(math.min(getRoll(worldVertical, constructRight, -constructForward)/60, 1), -1)
     local heightDiff=math.max(math.min((TargetAltitude - altitude - fpa_hud)/500, 1), -1)
     local heightDiff=utils.smoothstep(heightDiff,-1,1)- 0.5
     finalPitchInput=(heightDiff - currentPitchDeg) - (vs_hud*3.6/2500)
     if LimitPitchDeg>25 then finalPitchInput=math.min(finalPitchInput, 0) end
     if LimitPitchDeg<-15 then finalPitchInput=math.max(finalPitchInput, 0) end

     if currentRollDeg>45 then
      finalRollInput=-1
     elseif currentRollDeg<-45 then
      finalRollInput=1
     end

     local roll_dead_zone=3
     if auto_wp==true then
      roll_dead_zone=0
     end
     if currentRollDeg>roll_dead_zone then
      finalYawInput=-0.002 * currentRollDeg
     elseif currentRollDeg<-roll_dead_zone then
      finalYawInput=-0.002 * currentRollDeg
     end
    end

    local targetAngularVelocity=finalPitchInput * pitchSpeedFactor * constructRight
     + finalRollInput * rollSpeedFactor * constructForward
     + finalYawInput * yawSpeedFactor * constructUp

    local atmo=unit.getAtmosphereDensity()
    if (worldVertical:len()>0.01 and atmo>0.0) then in_atmosphere=true else in_atmosphere=false end
    if radio_alt_1 then
     local g=core.g()/10
     local ra=tonumber(radio_alt_value)
     if (ra~=nil and ra<=10 and ra>=0 and atmo<=0.0 and g>0.01) then in_space=true else in_space=false end
    end

    if (in_atmosphere==true or in_space==true) then
     local autoRollRollThreshold=1.0
     --autoRoll on AND currentRollDeg is big enough AND player is not rolling
     if autoRoll==true and currentRollDegAbs>autoRollRollThreshold and finalRollInput==0 then
      local targetRollDeg=utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);
      if (rollPID==nil) then
       rollPID=pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1)
      end
      rollPID:inject(targetRollDeg - currentRollDeg)
      local autoRollInput=rollPID:get()
      targetAngularVelocity=targetAngularVelocity + autoRollInput * constructForward
     end
    end

    --In atmosphere
    if in_atmosphere==true then
     --AUTOPILOT
     if auto_wp==true then
      autopilot_wp()
      if yaw_WP_hud~=0 then
       local final_roll=math.min(30, math.abs(yaw_WP_hud))
       if yaw_WP_hud<0 then final_roll=-final_roll end
       local targetRollDeg=utils.clamp(0, final_roll, final_roll);
       if (rollPID==nil) then rollPID=pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) end
       rollPID:inject(targetRollDeg - currentRollDeg)
       local autoRollInput=rollPID:get()
       targetAngularVelocity=targetAngularVelocity + autoRollInput * constructForward
        + finalYawInput * yawSpeedFactor * constructUp
      end
     end

     local turnAssistRollThreshold=20.0
     --turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
     if turnAssist==true and currentRollDegAbs>turnAssistRollThreshold and finalPitchInput==0 and finalYawInput==0 then
      local rollToPitchFactor=turnAssistFactor * 0.1 --magic number tweaked to have a default factor in the 1-10 range
      local rollToYawFactor=turnAssistFactor * 0.025 --magic number tweaked to have a default factor in the 1-10 range
      --rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
      local rescaleRollDegAbs=((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
      local rollVerticalRatio=0
      if rescaleRollDegAbs<90 then
       rollVerticalRatio=rescaleRollDegAbs / 90
      elseif rescaleRollDegAbs<180 then
       rollVerticalRatio=(180 - rescaleRollDegAbs) / 90
      end
      rollVerticalRatio=rollVerticalRatio * rollVerticalRatio
      local turnAssistYawInput=- currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
      local turnAssistPitchInput=rollToPitchFactor * rollVerticalRatio
      targetAngularVelocity=targetAngularVelocity
           + turnAssistPitchInput * constructRight
           + turnAssistYawInput * constructUp
     end
    end

    --Engine commands
    local keepCollinearity=1
    local dontKeepCollinearity=0
    local tolerancePercentToSkipOtherPriorities=1

    --Rotation
    local angularAcceleration=torqueFactor * (targetAngularVelocity - constructAngularVelocity)
    local airAcceleration=vec3(core.getWorldAirFrictionAngularAcceleration())
    angularAcceleration=angularAcceleration - airAcceleration
    Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

    --Brakes
    local brakeAcceleration=-finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
    Nav:setEngineForceCommand('brake', brakeAcceleration)

    --AutoNavigation regroups all the axis command by 'TargetSpeed'
    local autoNavigationEngineTags=''
    local autoNavigationAcceleration=vec3()
    local autoNavigationUseBrake=false

    --Longitudinal Translation
    local longitudinalEngineTags='thrust analog longitudinal'
    local longitudinalCommandType=Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
    if (longitudinalCommandType==axisCommandType.byThrottle) then
     local longitudinalAcceleration=Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
     Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
    elseif  (longitudinalCommandType==axisCommandType.byTargetSpeed) then
     local longitudinalAcceleration=Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
     autoNavigationEngineTags=autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
     autoNavigationAcceleration=autoNavigationAcceleration + longitudinalAcceleration
     if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)==0 or
      Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<- Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5)
     then
      autoNavigationUseBrake=true
     end
    end

    --Lateral Translation
    local lateralStrafeEngineTags='thrust analog lateral'
    local lateralCommandType=Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
    if (lateralCommandType==axisCommandType.byThrottle) then
     local lateralStrafeAcceleration= Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
     Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
    elseif  (lateralCommandType==axisCommandType.byTargetSpeed) then
     local lateralAcceleration=Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
     autoNavigationEngineTags=autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
     autoNavigationAcceleration=autoNavigationAcceleration + lateralAcceleration
    end

    --Vertical Translation
    --VTOL
    if vtol_system==false then Nav:setEngineCommand('vtol_eng', vec3.zero, vec3.zero) end
    local verticalStrafeEngineTags='thrust analog vertical'
    local verticalCommandType=Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
    if (verticalCommandType==axisCommandType.byThrottle) then
     local verticalStrafeAcceleration=Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
     Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
    elseif (verticalCommandType==axisCommandType.byTargetSpeed) then
     local verticalAcceleration=Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
     autoNavigationEngineTags=autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
     autoNavigationAcceleration=autoNavigationAcceleration + verticalAcceleration
    end

    --Auto Navigation (Cruise Control)
    if (autoNavigationAcceleration:len()>constants.epsilon) then
     if (brakeInput~=0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward))<0.95)  --if the velocity is not properly aligned with the forward
     then
      autoNavigationEngineTags=autoNavigationEngineTags .. ', brake'
     end
     Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
    end

    --Rockets
    Nav:setBoosterCommand('rocket_engine')

    --PROGRADE ALIGNER
    if auto_aligner==true then auto_align() end
  update:
   lua: |
    Nav:update()
    local data_change=false
    if math.floor(core.getAltitude())~=altitude then data_change=true
     right_panel=monitor_right() end
    altitude=math.floor(core.getAltitude())
    if math.floor(unit.getPitch()*10)/10~=pitch_hud then data_change=true
     f_pitch_roll()
     right_panel=monitor_right() end
    if math.floor(unit.getRoll()*10)/10~=roll_hud then data_change=true
     f_pitch_roll()
     right_panel=monitor_right() end
    f_pitch_roll()
    if math.floor((vec3(core.getVelocity()):len())*3.6)~=speed_hud then data_change=true
     right_panel=monitor_right() end
    speed_hud=math.floor((vec3(core.getVelocity()):len())*3.6)
    if system.getMouseWheel()==1 then  data_change=true end
    thrust_setting()
    if math.floor(unit.getThrottle())~=thr then data_change=true
     right_panel=monitor_right() end
    thr=math.floor(unit.getThrottle())
    new_vs=vertical_speed()
    if new_vs~=vs_hud then data_change=true
     right_panel=monitor_right() end
    vs_hud=new_vs

    if  data_change==true then
     hud=right_panel
     hud=hud .. left_panel
     system.setScreen(hud)
    end
  actionStart:
   args: [option1]
   lua: |
    if not L_SHIFT then
    --LOADING page
     unit.stopTimer("atmo_pg")
     unit.stopTimer("space_pg")
     unit.stopTimer("orbit_pg")
     unit.stopTimer("damage_pg")

     loading_pg,atmo_pg,orbit_pg,space_pg,damage_pg=true,false,false,false,false

     left_panel=monitor_left_loading()
     hud=right_panel
     hud=hud .. left_panel
     system.setScreen(hud)

     unit.setTimer("loading_pg", 1/30)
    end
  actionStart:
   args: [option2]
   lua: |
    --ATMO page
     unit.stopTimer("loading_pg")
     unit.stopTimer("space_pg")
     unit.stopTimer("orbit_pg")
     unit.stopTimer("damage_pg")

     loading_pg,atmo_pg,orbit_pg,space_pg,damage_pg=false,true,false,false,false

     left_panel=monitor_left_atmo()
     hud=right_panel
     hud=hud .. left_panel
     system.setScreen(hud)

     unit.setTimer("atmo_pg", 1/30)
  actionStart:
   args: [option3]
   lua: |
    --SPACE page
     unit.stopTimer("loading_pg")
     unit.stopTimer("atmo_pg")
     unit.stopTimer("orbit_pg")
     unit.stopTimer("damage_pg")

     loading_pg,atmo_pg,orbit_pg,space_pg,damage_pg=false,false,false,true,false

     left_panel=monitor_left_space()
     hud=right_panel
     hud=hud .. left_panel
     system.setScreen(hud)

     unit.setTimer("space_pg", 1/30)
  actionStart:
   args: [option4]
   lua: |
    --ORBIT page
     unit.stopTimer("loading_pg")
     unit.stopTimer("atmo_pg")
     unit.stopTimer("space_pg")
     unit.stopTimer("damage_pg")

     loading_pg,atmo_pg,orbit_pg,space_pg,damage_pg=false,false,true,false,false

     left_panel=monitor_left_orbit()
     hud=right_panel
     hud=hud .. left_panel
     system.setScreen(hud)

     unit.setTimer("orbit_pg", 1/30)
  actionStart:
   args: [option5]
   lua: |
    --DAMAGE page
    if DMG_Report==true then
     unit.stopTimer("loading_pg")
     unit.stopTimer("atmo_pg")
     unit.stopTimer("space_pg")
     unit.stopTimer("orbit_pg")

     loading_pg,atmo_pg,orbit_pg,space_pg,damage_pg=false,false,false,false,true

     left_panel=monitor_left_damage()
     hud=right_panel
     hud=hud .. left_panel
     system.setScreen(hud)

     unit.setTimer("damage_pg", 1/2)
    end
  actionStart:
   args: [option6]
   lua: |
    --AUTOPILOT
     if (atmo_pg==true and auto_aligner==false and antigrav_armed==false and unit.getAtmosphereDensity()>0) then
      if (altitude_hold==false and auto_wp==false) then
       if (pitch_hud<25 and pitch_hud>-15 and roll_hud<45 and roll_hud>-45) then
        TargetAltitude=core.getAltitude()
        altitude_hold=true
        alt_hold_color="lightgreen"
        if databank then if databank.getStringValue("databank_verification")=="Verified" then NavDatabank=true end end
       else
        autopilot_ecam_mode=[[<span class="tomato">Adjust Attitude</span>]]
        unit.setTimer("delay3sec", 3)
       end
      elseif (altitude_hold==true and auto_wp==false and NavDatabank) then
       auto_wp=true
      elseif ((altitude_hold==true and auto_wp==true) or (altitude_hold==true and not NavDatabank)) then
       altitude_hold=false
       auto_wp=false
       autopilot_ecam_mode=[[ ]]
       alt_hold_color="none"
      end
     elseif ((space_pg==true or orbit_pg==true) and atmo_pg==false and antigrav_armed==false and unit.getAtmosphereDensity()==0) then
      if auto_aligner==false then
       altitude_hold=false
       auto_wp=false
       auto_aligner=true
       prograde_mode=true
       autopilot_ecam_mode=[[Autopilot ON - Mode 1]]

      elseif (auto_aligner==true and prograde_mode==true and orbit_maintainer==false) then
       altitude_hold=false
       auto_wp=false
       orbit_maintainer=true
       autopilot_ecam_mode=[[Autopilot ON - Mode 2]]
       unit.setTimer("delay3sec", 3)
       time_to_align=4
       unit.setTimer("countdown", 1)
       function orbiting_mode_delay()
        unit.setTimer("maintaning_orbit", 1/30)
        unit.stopTimer("delay3sec")
        unit.stopTimer("countdown")
       end

      elseif (auto_aligner==true and prograde_mode==true and orbit_maintainer==true) then
       unit.stopTimer("maintaning_orbit")
       orbit_maintainer=false
       adjusting_mode=[[ ]]
       prograde_mode=false
       autopilot_ecam_mode=[[Autopilot ON - Mode 3]]
       unit.setTimer("delay3sec", 3)
       time_to_align=4
       unit.setTimer("countdown", 1)
       function destination_mode_delayed()
        destination_mode=true
        unit.stopTimer("delay3sec")
        unit.stopTimer("countdown")
        adjusting_mode=[[ ]]
       end

      elseif (auto_aligner==true and (destination_mode==true or prograde_mode==false)) then
       unit.stopTimer("delay3sec")
       unit.stopTimer("countdown")
       altitude_hold=false
       auto_wp=false
       auto_aligner=false
       destination_mode=false
       align_active_mode=[[ ]]
       autopilot_ecam_mode=[[ ]]
       adjusting_mode=[[ ]]
      end
     elseif (antigrav_armed==true) then
      unit.stopTimer("delay3sec")
      unit.stopTimer("countdown")
      unit.stopTimer("maintaning_orbit")
      auto_aligner=false
      prograde_mode=false
      destination_mode=false
      altitude_hold=false
      auto_wp=false
      align_active_mode=[[ ]]
      adjusting_mode=[[ ]]
      autopilot_ecam_mode=[[ ]]
      alt_hold_color="none"
      if antigrav.getState()==0 then
       agg_ecam_mode=[[AGG ON]]
      elseif antigrav.getState()==1 then
       agg_ecam_mode=[[<span class="cyan">AGG ARM</span>]]
      end
      antigrav.toggle()
     elseif (atmo_pg==true) then
      unit.stopTimer("delay3sec")
      unit.stopTimer("countdown")
      unit.stopTimer("maintaning_orbit")
      auto_aligner=false
      prograde_mode=false
      destination_mode=false
      altitude_hold=false
      auto_wp=false
      align_active_mode=[[ ]]
      adjusting_mode=[[ ]]
      autopilot_ecam_mode=[[ ]]
     end
  actionStart:
   args: [option7]
   lua: |
    --BRAKE SYSTEM
     if (parking_brk_on==false and autobrake_arm==false and autobrake==false) and not L_SHIFT then
      parking_brk_on=true
      parking_brk()
     elseif (autobrake_arm==false and autobrake==false and parking_brk_on==false and speed_hud>100) and L_SHIFT then
      autobrake_arm=true
      unit.setTimer("autobrake", 1/2)
     elseif (parking_brk_on==true or autobrake_arm==true or autobrake==true) then
      if (parking_brk_on==true) then
       parking_brk_on=false
       parking_brk()
      elseif (autobrake_arm==true or autobrake==true) then
       autobrake_disengage()
      end
     end
  actionStart:
   args: [option8]
   lua: |
    if (du_radar_widgets==false and UnitType~="RemoteControlUnit") then
     local isPVPStationOn="OFF"
     if databank then isPVPStationOn=databank.getStringValue("PVPStation") end
    --PVP STATION
     if (radar_size>0 and isPVPStationOn=="ON") then PVPStation() end   
     if isPVPStationOn=="OFF" then _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_periscope", "Periscope"), "periscope") end
     if (radar_size>0 and isPVPStationOn=="OFF") then _autoconf.displayCategoryPanel(radar, radar_size, "Radar", "radar") end
     if isPVPStationOn=="OFF" then
      coreCombatStressPanelId=system.createWidgetPanel("Core combat stress")
      coreCombatStressgWidgetId=system.createWidget(coreCombatStressPanelId,"core_stress")
      system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)
     end
     du_radar_widgets=true
    --SHIELD SHOW
     if shield~=nil then shield.show() end
    --RADAR HIDE
    elseif (du_radar_widgets==true and UnitType~="RemoteControlUnit") then
     unit.stopTimer("PVPupdate")
     unit.stopTimer("PVPsender")
     unit.stopTimer("CheckRadarOp")
     if databank then
      if UnitIsCockpit then databank.setStringValue("PVPCockpit", "OFF")
      elseif UnitIsSeat then databank.setStringValue("PVPGunner", "OFF")
      end
      databank.setStringValue("PVPStationData", "")
     end
     _autoconf.hideCategoryPanels()
     system.destroyWidgetPanel(coreCombatStressPanelId)
     system.destroyWidgetPanel(radarPanel)
     du_radar_widgets=false
    --SHIELD HIDE
     if shield~=nil then shield.hide() end
    end
    --RCFREEZE
    if Nav.control.isRemoteControlled()==1 then if rcfreeze==1 then rcfreeze=0 else rcfreeze=1 end system.freeze(rcfreeze) end
  actionStart:
   args: [option9]
   lua: |
    --WIDGETS SHOW
     if du_widgets==false then
      unit.show()
      core.show()
      if warpdrive~=nil then warpdrive.show() end
      parentingPanelId=system.createWidgetPanel("Docking")
      parentingWidgetId=system.createWidget(parentingPanelId,"parenting")
      system.addDataToWidget(unit.getDataId(),parentingWidgetId)
      du_widgets=true
    --WIDGETS HIDE
     elseif du_widgets==true then
      unit.hide()
      core.hide()
      if warpdrive~=nil then warpdrive.hide() end
      system.destroyWidgetPanel(parentingPanelId)
      system.destroyWidgetPanel(coreCombatStressPanelId)
      _autoconf.hideCategoryPanels()
      du_widgets=false
     end
  actionStart:
   args: [gear]
   lua: |
    if not GearInhibit then
     gearExtended=not gearExtended
     if gearExtended then Nav.control.extendLandingGears()
     else Nav.control.retractLandingGears() end
    end
  actionStart:
   args: [light]
   lua: |
    if Nav.control.isAnyHeadlightSwitchedOn()==1 then
     Nav.control.switchOffHeadlights()
    else
     Nav.control.switchOnHeadlights()
    end
    if databank then
     helmet_hud_color()
    end
  actionStart:
   args: [forward]
   lua: pitchInput=pitchInput - 1
  actionStop:
   args: [forward]
   lua: pitchInput=0
  actionStart:
   args: [backward]
   lua: pitchInput=pitchInput + 1
  actionStop:
   args: [backward]
   lua: pitchInput=0
  actionStart:
   args: [left]
   lua: rollInput=rollInput - 1
  actionStop:
   args: [left]
   lua: rollInput=0
  actionStart:
   args: [right]
   lua: rollInput=rollInput + 1
  actionStop:
   args: [right]
   lua: rollInput=0
  actionStart:
   args: [straferight]
   lua: if not L_ALT then Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0) end
  actionStop:
   args: [straferight]
   lua: if not L_ALT then Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0) end
  actionStart:
   args: [strafeleft]
   lua: if not L_ALT then Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0) end
  actionStop:
   args: [strafeleft]
   lua: if not L_ALT then Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0) end
  actionStart:
   args: [up]
   lua: |
    if not L_ALT then
     Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
     Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
    end
  actionStop:
   args: [up]
   lua: |
    if not L_ALT then
     Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
     Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
    end
  actionStart:
   args: [down]
   lua: |
    if not L_ALT then 
     Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
     Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
    end
  actionStop:
   args: [down]
   lua: |
    if not L_ALT then 
     Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
     Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
    end
  actionStart:
   args: [groundaltitudeup]
   lua: |
    if (speed_hud<50 and antigrav_armed==false) then Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0) end
    if (altitude_hold==true and speed_hud>=100 and antigrav_armed==false) then TargetAltitude=TargetAltitude +100 end
    if (antigrav~=nil and antigrav_armed==true) then antigrav_target_alt=antigrav_target_alt +10
     if DbInitialised=="Verified" then databank.setIntValue("agg_t_alt", antigrav_target_alt) end
     antigrav.setBaseAltitude(antigrav_target_alt)
     if antigrav.getState()==1 then agg_ecam_mode=[[AGG ON]]
     elseif antigrav.getState()==0 then agg_ecam_mode=[[<span class="cyan">AGG ARM</span>]]
     end
    end
  actionLoop:
   args: [groundaltitudeup]
   lua: |
    if (speed_hud<50 and antigrav_armed==false) then Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0) end
    if (altitude_hold==true and speed_hud>=100 and antigrav_armed==false) then TargetAltitude=TargetAltitude +1 end
    if (antigrav~=nil and antigrav_armed==true) then antigrav_target_alt=antigrav_target_alt +10
     if DbInitialised=="Verified" then databank.setIntValue("agg_t_alt", antigrav_target_alt) end
     antigrav.setBaseAltitude(antigrav_target_alt)
     if antigrav.getState()==1 then agg_ecam_mode=[[AGG ON]]
     elseif antigrav.getState()==0 then agg_ecam_mode=[[<span class="cyan">AGG ARM</span>]]
     end
    end
  actionStart:
   args: [groundaltitudedown]
   lua: |
    if (speed_hud<50 and antigrav_armed==false) then Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0) end
    if (altitude_hold==true and speed_hud>=100 and antigrav_armed==false) then TargetAltitude=TargetAltitude -100 end
    if (antigrav~=nil and antigrav_armed==true) then antigrav_target_alt=antigrav_target_alt -10
     if antigrav_target_alt<1000 then antigrav_target_alt=1000 end
     antigrav.setBaseAltitude(antigrav_target_alt)
     if DbInitialised=="Verified" then databank.setIntValue("agg_t_alt", antigrav_target_alt) end
     if antigrav.getState()==1 then agg_ecam_mode=[[AGG ON]]
     elseif antigrav.getState()==0 then agg_ecam_mode=[[<span class="cyan">AGG ARM</span>]]
     end
    end
  actionLoop:
   args: [groundaltitudedown]
   lua: |
    if (speed_hud<50 and antigrav_armed==false) then Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0) end
    if (altitude_hold==true and speed_hud>=100 and antigrav_armed==false) then TargetAltitude=TargetAltitude -1 end
    if (antigrav~=nil and antigrav_armed==true) then antigrav_target_alt=antigrav_target_alt -10
     if antigrav_target_alt<1000 then antigrav_target_alt=1000 end
     antigrav.setBaseAltitude(antigrav_target_alt)
     if DbInitialised=="Verified" then databank.setIntValue("agg_t_alt", antigrav_target_alt) end
     if antigrav.getState()==1 then agg_ecam_mode=[[AGG ON]]
     elseif antigrav.getState()==0 then agg_ecam_mode=[[<span class="cyan">AGG ARM</span>]]
     end
    end
  actionStart:
   args: [yawright]
   lua: yawInput=yawInput - 1
  actionStop:
   args: [yawright]
   lua: yawInput=0
  actionStart:
   args: [yawleft]
   lua: yawInput=yawInput + 1
  actionStop:
   args: [yawleft]
   lua: yawInput=0
  actionStart:
   args: [brake]
   lua: |
    brakeInput=brakeInput + 1
    local longitudinalCommandType=Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
    if (longitudinalCommandType==axisCommandType.byTargetSpeed) then
     local targetSpeed=Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
     if (math.abs(targetSpeed)>constants.epsilon) then
      Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
     end
    end
  actionStop:
   args: [brake]
   lua: brakeInput=brakeInput - 1
  actionLoop:
   args: [brake]
   lua: |
    local longitudinalCommandType=Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
    if (longitudinalCommandType==axisCommandType.byTargetSpeed) then
     local targetSpeed=Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
     if (math.abs(targetSpeed)>constants.epsilon) then
      Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
     end
    end
  actionStart:
   args: [booster]
   lua: Nav:toggleBoosters()
  actionStart:
   args: [stopengines]
   lua: |
    if L_SHIFT==false then
     Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
    end
  actionStart:
   args: [speedup]
   lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
  actionLoop:
   args: [speedup]
   lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
  actionStart:
   args: [speeddown]
   lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
  actionLoop:
   args: [speeddown]
   lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)
  actionStart:
   args: [antigravity]
   lua: |
    if (antigrav~=nil and atigrav_widget==false) then
     antigrav.show()
     atigrav_widget=true
     antigrav_armed=true
     agg_ecam_mode=[[<span class="cyan">AGG ARM</span>]]
     if DbInitialised=="Verified" then
      databank.setStringValue("nav agg", "STBY")
      databank.setStringValue("agg eng/stby", "STBY")
      databank.setStringValue("agg off/stby", "STBY")
      unit.setTimer("antigravity", 1)
     end
    elseif (antigrav~=nil and atigrav_widget==true) then
     unit.stopTimer("antigravity", 1)
     if DbInitialised=="Verified" then
      databank.setStringValue("nav agg", "OFF")
      databank.setStringValue("agg eng/stby", "STBY")
      databank.setStringValue("agg off/stby", "OFF")
     end
     antigrav.hide()
     antigrav.deactivate()
     atigrav_widget=false
     antigrav_armed=false
     agg_ecam_mode=[[ ]]
    end
  actionStart:
   args: [warp]
   lua: if warpdrive~=nil then warpdrive.activateWarp() end
  actionLoop:
   args: [lshift]
   lua: L_SHIFT, GearInhibit=true, true
  actionStop:
   args: [lshift]
   lua: L_SHIFT, GearInhibit=false, false
  actionLoop:
   args: [lalt]
   lua: |
    L_ALT=true
  actionStop:
   args: [lalt]
   lua: |
    L_ALT=false
  actionStop:
   args: [stopengines]
   lua: |
    if L_SHIFT then
     if gyro then
      gyro.toggle()
      gyroscope_state=gyro.getState()
      if gyroscope_state==1 then
       gyroscope_state_ecam=[[<span style="color:#ff00ff">Gyro ON</span><br>]]
      else
       gyroscope_state_ecam=[[ ]]
      end
     else
      if vtol_system==false then vtol_system=true gyroscope_state_ecam=[[<span style="color:#ff00ff">VTOL</span><br>]]
      elseif vtol_system==true then vtol_system=false gyroscope_state_ecam=[[ ]] end
     end
    end
    stopengines_pressed=false
  inputText(text):
   lua: |
    local T=text
    local check=string.find(T, "/help")
    if check then
     system.print("1 << REMOTE CONTROLLER >>")
     system.print("Player Freeze = ALT+8")
     system.print("")
     system.print("2 << FLIGHT MODES >>")
     system.print("LOAD = ALT+1")
     system.print("AI = ALT+2")
     system.print("SPC = ALT+3")
     system.print("ORB = ALT+4")
     system.print("DMG = ALT+5")
     system.print("")
     system.print("3 << HELMET HUD >>")
     system.print("ON/OFF = ALT+FLIGHT MODE")
     system.print("Cycle Colors = SHIFT+L")
     system.print("")
     system.print("4 << AUTOMATIONS >>")
     system.print("ALT HOLD = 1x ALT+6 (AI)")
     system.print("Altitude +/- 100m = ALT+SpaceBar/C")
     system.print("Autopilot ON = 2x ALT+6 (AI)")
     system.print("Align PROGRADE = 1x ALT+6 (LOAD,SPC,ORB,DMG)")
     system.print("Maint. ORBIT = 2x ALT+6 (LOAD,SPC,ORB,DMG)")
     system.print("Align DESTINATION = 3x ALT+6 (LOAD,SPC,ORB,DMG)")
     system.print("")
     system.print("5 << BRAKING SYSTEM >>")
     system.print("Parking Brake ON/OFF = ALT+7")
     system.print("Autobrake ARM ON/OFF = L.SHIFT+ALT+7 (spd>100)")
     system.print("")
     system.print("6 << AGG >>")
     system.print("ARM/OFF = ALT+G")
     system.print("ON/ARM = ALT+6 (Override any active mode)")
     system.print("Target Altitude +/- = ALT+SpaceBar/C")
     system.print("")
     system.print("7 << WEAPONS AND RADAR >>")
     system.print("ON/OFF = ALT+8")
     system.print("Shield Venting ON/OFF = L.SHIFT+G")
     system.print("")
     system.print("8 << WIDGETS >>")
     system.print("ON/OFF = ALT+9")
     system.print("")
     system.print("9 << VTOL >>")
     system.print("Tag the VTOL engines with vtol_eng")
     system.print("ON/OFF = L.SHIFT+MMB")
     system.print("")
     system.print("10 << GYRO >>")
     system.print("ON/OFF = L.SHIFT+MMB")
    end