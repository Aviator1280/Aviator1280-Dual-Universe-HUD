name: Aviator1280 v8.0.3

slots:
 core:
  class: CoreUnit
 gyro:
  class: GyroUnit
 warpdrive:
  class: WarpDriveUnit
 atmofueltank:
  class: AtmoFuelContainer
  select: all
 spacefueltank:
  class: SpaceFuelContainer
  select: all
 rocketfueltank:
  class: RocketFuelContainer
  select: manual
 weapon:
  class: WeaponUnit
  select: manual
 radar:
  class: RadarPVPUnit
  select: manual
 container:
  class: ItemContainer
  select: manual
 db:
  class: databank
 radio_alt:
  class: VerticalBooster
  select: manual
 radio_alt:
  class: Hovercraft
  select: manual
 radio_alt:
  class: TelemeterUnit
  select: manual
 antigrav:
  class: AntiGravityGeneratorUnit
 shield:
  class: ShieldGeneratorUnit
handlers:
 library:
  onStart:
   lua: |
    --MINIFIER
     S=system
     S1=string.format
     if db then
      G1=db.getStringValue
      G2=db.setStringValue
      G3=db.getFloatValue
     end
     M1=math.floor

    --LUA PARAMETERS
     Thrust_Lever=false --export
     Gear_Installed=true --export
     Parking_Brake_Set=true --export
     Widgets_ON_OFF=false --export
     DMG_Report=true --export
     Fix_Panels=false --export
     rcfreeze=true --export
     HUD_Color="aqua" --export

     GND_Altitude=0 --export
     Maximum_Take_Off_Weight=730000 --export
     Periapsis_Target_Altitude= 20000 --export
     Autobrake_Stop_Distance=2.3 --export

     Targets_To_Show=10 --export

     DMG_REP_Scale=3 --export
     DmgTopUpDn=-20 --export
     DmgTopLhRh=30 --export
     DmgSideUpDn=40 --export
     DmgSideLhRh=100 --export

     HUD_Magnifier=1 --export
     RH_Panel_Y=2 --export
     RH_Panel_X=20 --export
     LH_Panel_Y=2 --export
     LH_Panel_X=15 --export
     RH_TOP_Panel_Y=47 --export
     RH_TOP_Panel_X=14 --export
     LH_TOP_Panel_Y=47 --export
     LH_TOP_Panel_X=2 --export

    --SERIALIZE
     if db then if G1("Serialize")~="" then SerializeFunction=G1("Serialize") load(SerializeFunction)()() end end
    --CONTROLLER
     function Controller(hybrid,hasbrake,range)
      local self={}
      if hybrid==nil then hybrid=true end
      if hybrid then hasbrake=false range=false end
      if hasbrake==nil then hasbrake=false end
      if range==nil then range=true end
      local construct,system=construct,system
      local getVelocity=construct.getWorldVelocity
      local getAxis=S.getAxisValue
      local getMass=construct.getMass
      local getMaxBrake=construct.getMaxBrake
      local getTime=S.getArkTime

      local function getRawThrottle()
       if range then return (getAxis(3)+1)*0.5 else local currentThrottle=getAxis(3)
        if not hybrid then return currentThrottle else
         if currentThrottle<0 then return 0 else return currentThrottle end
        end
       end
      end

      local function getRawBrake()
       if hasbrake then return (getAxis(4)+1)*0.5 elseif hybrid then local currentThrottle=-getAxis(3)
        if currentThrottle>0 then return currentThrottle else return 0 end
       end
       return 0
      end

      function self.getRawRoll() return getAxis(0) end
      function self.getRawPitch() return getAxis(1) end
      function self.getRawYaw() return getAxis(2) end
      function self.getRawThrottle() return getRawThrottle(3) end
      function self.getRawBrake() return getRawBrake() end
      function self.getRawStrafe() return getAxis(5) end
      function self.getRawVertical() return getAxis(6) end

      function self.getRawAxis7() return getAxis(7) end
      function self.getRawAxis8() return getAxis(8) end
      function self.getRawAxis9() return getAxis(9) end

      local deadzones={0,0,0,0.05,0,0,0,0,0}
      local inputs={self.getRawRoll(),self.getRawPitch(),self.getRawYaw(),self.getRawThrottle(),self.getRawBrake(),self.getRawStrafe(),self.getRawVertical(),self.getRawAxis7(),self.getRawAxis8(),self.getRawAxis9()}
      local lastTimeCached={0,0,0,0,0,0,0,0,0,0}
      local function setDeadzone(deadzoneIndex,value)
       if value>=1 then deadzone[deadzoneIndex]=0.999 elseif value<=0 then deadzone[deadzoneIndex]=0 else deadzone[deadzoneIndex]=value end
      end

      function self.setRollDeadzone(newDeadzone) setDeadzone(0,newDeadzone) end
      function self.setPitchDeadzone(newDeadzone) setDeadzone(1,newDeadzone) end
      function self.setYawDeadzone(newDeadzone) setDeadzone(2,newDeadzone) end
      function self.setThrottleDeadzone(newDeadzone) setDeadzone(3,newDeadzone) end
      function self.setBrakeDeadzone(newDeadzone) setDeadzone(4,newDeadzone) end
      function self.setStafeDeadzone(newDeadzone) setDeadzone(5,newDeadzone) end
      function self.setVerticalDeadzone(newDeadzone) setDeadzone(6,newDeadzone) end
      function self.setAxis7Deadzone(newDeadzone) setDeadzone(7,newDeadzone) end
      function self.setAxis8Deadzone(newDeadzone) setDeadzone(8,newDeadzone) end
      function self.setAxis9Deadzone(newDeadzone) setDeadzone(9,newDeadzone) end

      local function handleCenterDeadzone(value,deadzone)
       if value<0 then return value<-deadzone and (value+deadzone)*(1/(1-deadzone)) or 0 else return value>deadzone and (value-deadzone)*(1/(1-deadzone)) or 0 end
      end

      local function handleEdgeDeadzone(value,deadzone)
       value=value*(1/(1-deadzone))
       if value<0 then return value>-1 and value or -1 else return value<1 and value or 1 end
      end

      local function handleDeadzone(value,deadzone)
       if range then return handleEdgeDeadzone(value,deadzone) else local valueCentered=handleCenterDeadzone(value,deadzone)
        local edged=handleEdgeDeadzone(valueCentered,deadzone)
        return edged
       end
      end

      local function getGenericInput(axisIndex)
       axisIndex=axisIndex+1
       local newTime=getTime()
       if newTime-lastTimeCached[axisIndex]>1/65 then
        lastTimeCached[axisIndex]=newTime
        local newinput=getAxis(axisIndex-1)
        local diff=inputs[axisIndex]-newinput
        if diff<0.8 and diff>-0.8 then
         newInput=handleCenterDeadzone(newinput,deadzones[axisIndex])
         inputs[axisIndex]=newInput
         return newInput
         else return inputs[axisIndex]
        end
       else return inputs[axisIndex] end
      end

      function self.getRollInput() return getGenericInput(0) end
      function self.getPitchInput() return getGenericInput(1) end
      function self.getYawInput() return getGenericInput(2) end

      function self.getThrottleInput()
       local newTime=getTime()
       if newTime-lastTimeCached[4]>1/65 then
        lastTimeCached[4]=newTime
        local currentThrottle=getRawThrottle()
        local diff=currentThrottle-inputs[4]
        if diff<0.8 and diff>-0.8 then
         currentThrottle=handleDeadzone(currentThrottle,deadzones[4])
         inputs[4]=currentThrottle
         return currentThrottle
        else return inputs[4] end
       else return inputs[4] end
      end

      function self.getBrakeInput()
       local newTime=getTime()
       if newTime-lastTimeCached[5]>1/65 then
        lastTimeCached[5]=newTime
        local currentBrake=getRawBrake()
        local diff=currentBrake-inputs[5]
        if diff<0.8 and diff>-0.8 then
         currentBrake=handleDeadzone(currentBrake,deadzones[5])
         inputs[5]=currentBrake
         return currentBrake
        else return inputs[5] end
       else return inputs[5] end
      end

      function self.getStafeInput() return getGenericInput(5) end
      function self.getVerticalInput() return getGenericInput(6) end
      function self.getAxis7Input() return getGenericInput(7) end
      function self.getAxis8Input() return getGenericInput(8) end
      function self.getAxis9Input() return getGenericInput(9) end

      function self.getBrakeVectorUnpacked() -- experimental
       local velocity=getVelocity()
       local vx,vy,vz=velocity[1],velocity[2],velocity[3]
       local mag=(vx*vx+vy*vy+vz*vz)^0.5

       local maxAcc=getMaxBrake()/getMass()
       local brakeInput=-self.getBrakeInput()*maxAcc

       return brakeInput*vx/mag,brakeInput*vy/mag,brakeInput*vz/mag
      end

      function self.getBrakeVector() -- experimental
       return {self.getBrakeVectorUnpacked()}
      end

      return self
     end

 player:
  onStart:
   lua: |
 unit:
  onStart:
   lua: |
    --[[ Author: Aviator1280 --]]

    --DU CODE
     pitchInput,rollInput,yawInput,brakeInput=0,0,0,0

     Nav=Navigator.new(system,core,unit)
     Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})

     Nav.axisCommandManager:setTargetGroundAltitude(GND_Altitude)

     _autoconf.displayCategoryPanel(weapon, weapon_size, L_TEXT("ui_lua_widget_weapon", "Weapons"), "weapon", true)
     core.showWidget()
     _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_periscope", "Periscope"), "periscope")
     placeRadar=true
     if atmofueltank_size>0 then _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"), "fuel_container")
      if placeRadar then _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar") placeRadar=false end
     end
     if spacefueltank_size>0 then _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"), "fuel_container")
      if placeRadar then _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar") placeRadar=false end
     end
     _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"), "fuel_container")
     if placeRadar then _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar") placeRadar=false end
     if antigrav~=nil then antigrav.showWidget() end
     if warpdrive~=nil then warpdrive.showWidget() end
     if gyro~=nil then gyro.showWidget() end
     if shield~=nil then shield.showWidget() end

     if Nav.control.isRemoteControlled() then player.freeze(rcfreeze) end

     gearExtended=Nav.control.isAnyLandingGearDeployed()
     if gearExtended then Nav.control.deployLandingGears() else Nav.control.retractLandingGears() end

    --HUD CODE
     SysVer="v8.0.3"
     NIver,NINSver,FMver,PVPSver,VerChk="v8.0.0","v8.0.1","v8.0.0","v8.0.0","Check: "
     if db then
      G2("Aviator1280 HUD ver",SysVer)
      local NavInt,NavIntNS,FuelMdl,PvP=G1("Navigator Interface ver"),G1("Navigator Interface No Scr ver"),G1("Fuel Module ver"),G1("PVP Station ver")
      if (NavInt=="" or NavInt==NIver) then VerChk=VerChk else VerChk="Navigator Interface at or above "..NIver.."; " end
      if (NavIntNS=="" or NavIntNS==NINSver) then VerChk=VerChk else VerChk=VerChk.."Navigator Interface No Scr at or above "..NINSver.."; " end
      if (FuelMdl=="" or FuelMdl==FMver) then VerChk=VerChk else VerChk=VerChk.."Fuel Module at or above "..FMver.."; " end
      if (PvP=="" or PvP==PVPSver) then VerChk=VerChk else VerChk=VerChk.."PVP Station at or above "..PVPSver.."; " end
      if VerChk=="Check: " then VerChk="All Installed Module Ver. Check OK" end
     end

     S.print("----------------------------------------") S.print("AVIATOR1280 Flyght System ONLINE") S.print("Release "..SysVer) S.print(VerChk) S.print("") S.print("<< FOR HELP type: /help >>") S.print("")

     controller=Controller(false,false,true)
     ThrRev=false
     ScrW,ScrH,Vfov=S.getScreenWidth(),S.getScreenHeight(),S.getCameraVerticalFov()
     Vratio,LoadPg,autoRoll_activated,atmo_pg,space_pg,orbit_pg,damage_pg,yaw_bird_corr,HUDColorId,DeorbitPossible=ScrH/Vfov,true,false,false,false,false,false,0,0,false
     AltHoldColor,DbInit="none",""
     if db then DbInit=G1("databank_verification") end
     UnitIsCockpit,UnitIsSeat,UnitType=false,false,unit.getClass()
     if UnitType=="CockpitFighterUnit" then UnitIsCockpit=true else UnitIsSeat=true end

     if not Widgets_ON_OFF then unit.hideWidget() core.hideWidget()
      if gyro~=nil then gyro.hideWidget() end if antigrav~=nil then antigrav.hideWidget() end if warpdrive~=nil then warpdrive.hideWidget() end if shield~=nil then shield.hideWidget() end
      _autoconf.hideCategoryPanels() du_widgets,du_radar_widgets=false,false
     else du_widgets,du_radar_widgets=true,true end

     hud_color={[1]=HUD_Color,[2]="lightgreen",[3]="red",[4]="orange",[5]="yellow",[6]="white",[7]="none"}
     ActiveHUDColor=hud_color[1]

     ScRt=ScrH/1080*HUD_Magnifier

     if DbInit=="Verified" then
      if G3("navigator_pe_target_altitude")~=nil then PeTargetAlt=G3("navigator_pe_target_altitude") else PeTargetAlt=20000 end
     else PeTargetAlt=Periapsis_Target_Altitude end

     if (db and DbInit=="") then db.setFloatValue("DMG Scale",DMG_REP_Scale) db.setFloatValue("DMG TV U/D",DmgTopUpDn) db.setFloatValue("DMG TV L/R",DmgTopLhRh) db.setFloatValue("DMG SV U/D",DmgSideUpDn) db.setFloatValue("DMG SV L/R",DmgSideLhRh) end

    --TOOLS
     --STRING CONVERTER TO VEC3
      function vec3FromStr(vStr)
       local v3={};
       for num in string.gmatch(vStr,"[-%d%.]+") do
        local vN=string.gsub(num,"%+","")
        table.insert(v3,tonumber(vN))
       end
       return vec3(table.unpack(v3))
      end

     --ROUND
      function round(num,numDecimalPlaces)
       return tonumber(S1("%." .. (numDecimalPlaces or 0) .. "f",num))
      end

     --ATLAS
       DUatlas=require('atlas')

     --PLANETREF
      function planetref()
       local function isNumber(n) return type(n)=='number' end
       local function isSNumber(n) return type(tonumber(n))=='number' end
       local function isTable(t) return type(t)=='table' end
       local function isString(s) return type(s)=='string' end
       local function isVector(v) return isTable(v) and isNumber(v.x and v.y and v.z) end

       local function isMapPosition(m) return isTable(m) and isNumber(m.latitude and m.longitude and m.altitude and m.bodyId and m.systemId) end

       local deg2rad=math.pi/180
       local rad2deg=180/math.pi
       local epsilon=1e-10
       local num=' *([+-]?%d+%.?%d*e?[+-]?%d*)'
       local posPattern='::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' .. num ..  ',' .. num .. '}'

       local utils=require('cpml.utils')
       local vec3=require('cpml.vec3')
       local clamp=utils.clamp

       local function float_eq(a,b)
        if a==0 then return math.abs(b)<1e-09 end
        if b==0 then return math.abs(a)<1e-09 end
        return math.abs(a-b)<math.max(math.abs(a),math.abs(b))*epsilon
       end

       local function formatNumber(n)
        local result=string.gsub(string.reverse(S1('%.4f',n)),'^0*%.?','')
        return result=='' and '0' or string.reverse(result)
       end

       local function formatValue(obj)
        if isVector(obj) then return S1('{x=%.3f,y=%.3f,z=%.3f}',obj.x,obj.y,obj.z) end

        if isTable(obj) and not getmetatable(obj) then
         local list={}
         local nxt=next(obj)

         if type(nxt)=='nil' or nxt==1 then
          for i,a in ipairs(obj) do list[i]=formatValue(a) end
         else
          for k,v in pairs(obj) do
           local value=formatValue(v)
           if type(k)=='number' then table.insert(list,S1('[%s]=%s',k,value)) else table.insert(list,S1('%s=%s',k,value)) end
          end
         end
         return S1('{%s}',table.concat(list,','))
        end

        if isString(obj) then return S1("[[%s]]",obj) end
        return tostring(obj)
       end

       local BodyParameters={}
       BodyParameters.__index=BodyParameters
       BodyParameters.__tostring=
       function(obj,indent)
        local keys={}
        for k in pairs(obj) do table.insert(keys,k) end
        table.sort(keys)
        local list={}
        for _,k in ipairs(keys) do
         local value=formatValue(obj[k])
         if type(k)=='number' then table.insert(list,S1('[%s]=%s',k,value)) else table.insert(list,S1('%s=%s',k,value)) end
        end
        if indent then return S1('%s%s',indent,table.concat(list,',\n' .. indent)) end
        return S1('{%s}',table.concat(list,','))
       end
       BodyParameters.__eq=function(lhs,rhs)
        return lhs.planetarySystemId==rhs.planetarySystemId and lhs.bodyId==rhs.bodyId and float_eq(lhs.radius,rhs.radius) and float_eq(lhs.center.x,rhs.center.x) and float_eq(lhs.center.y,rhs.center.y) and float_eq(lhs.center.z,rhs.center.z) and float_eq(lhs.GM,rhs.GM)
       end

       local function mkBodyParameters(systemId,bodyId,radius,worldCoordinates,GM)
        assert(isSNumber(systemId),'Argument 1 (planetarySystemId) must be a number:' .. type(systemId))
        assert(isSNumber(bodyId),'Argument 2 (bodyId) must be a number:' .. type(bodyId))
        assert(isSNumber(radius),'Argument 3 (radius) must be a number:' .. type(radius))
        assert(isTable(worldCoordinates),'Argument 4 (worldCoordinates) must be a array or vec3.' .. type(worldCoordinates))
        assert(isSNumber(GM),'Argument 5 (GM) must be a number:' .. type(GM))
        return setmetatable({planetarySystemId=tonumber(systemId),bodyId=tonumber(bodyId),radius=tonumber(radius),center=vec3(worldCoordinates),GM=tonumber(GM) },BodyParameters)
       end

       local MapPosition={}
       MapPosition.__index=MapPosition
       MapPosition.__tostring=function(p)
        return S1('::pos{%d,%d,%s,%s,%s}',p.systemId,p.bodyId,formatNumber(p.latitude*rad2deg),formatNumber(p.longitude*rad2deg),formatNumber(p.altitude))
       end
       MapPosition.__eq=function(lhs,rhs)
        return lhs.bodyId==rhs.bodyId and lhs.systemId==rhs.systemId and float_eq(lhs.latitude,rhs.latitude) and float_eq(lhs.altitude,rhs.altitude) and (float_eq(lhs.longitude,rhs.longitude) or float_eq(lhs.latitude,math.pi/2) or float_eq(lhs.latitude,-math.pi/2))
       end

       local function mkMapPosition(overload,bodyId,latitude,longitude,altitude)
        local systemId=overload

        if isString(overload) and not longitude and not altitude and not bodyId and not latitude then
         systemId,bodyId,latitude,longitude,altitude=string.match(overload,posPattern)
         assert(systemId,'Argument 1 (position string) is malformed.')
        else
         assert(isSNumber(systemId),'Argument 1 (systemId) must be a number:' .. type(systemId))
         assert(isSNumber(bodyId),'Argument 2 (bodyId) must be a number:' .. type(bodyId))
         assert(isSNumber(latitude),'Argument 3 (latitude) must be in degrees:' .. type(latitude))
         assert(isSNumber(longitude),'Argument 4 (longitude) must be in degrees:' .. type(longitude))
         assert(isSNumber(altitude),'Argument 5 (altitude) must be in meters:' .. type(altitude))
        end
        systemId=tonumber(systemId)
        bodyId=tonumber(bodyId)
        latitude=tonumber(latitude)
        longitude=tonumber(longitude)
        altitude=tonumber(altitude)

        if bodyId==0 then return setmetatable({latitude=latitude,longitude=longitude,altitude=altitude,bodyId=bodyId,systemId=systemId},MapPosition) end
        return setmetatable({latitude=deg2rad*clamp(latitude,-90,90),longitude=deg2rad*(longitude % 360),altitude=altitude,bodyId=bodyId,systemId=systemId},MapPosition)
       end

       local PlanetarySystem={}
       PlanetarySystem.__index=PlanetarySystem

       PlanetarySystem.__tostring=
       function (obj,indent)
        local sep=indent and (indent .. '  ' )
        local bdylist={}
        local keys={}
        for k in pairs(obj) do table.insert(keys,k) end
        table.sort(keys)
        for _,bi in ipairs(keys) do
         bdy=obj[bi]
         local bdys=BodyParameters.__tostring(bdy,sep)
         if indent then table.insert(bdylist,S1('[%s]={\n%s\n%s}',bi,bdys,indent)) else table.insert(bdylist,S1('  [%s]=%s',bi,bdys)) end
        end
        if indent then return S1('\n%s%s%s',indent,table.concat(bdylist,',\n' .. indent),indent) end
        return S1('{\n%s\n}',table.concat(bdylist,',\n'))
       end

       local function mkPlanetarySystem(systemReferenceTable)
        local atlas={}
        local pid
        for _,v in pairs(systemReferenceTable) do local id=v.planetarySystemId
         if id==nil then id=0 v.planetarySystemId=id end
         if type(id)~='number' then error('Invalid planetary system ID: ' .. tostring(id)) elseif pid and id~=pid then error('Mismatch planetary system IDs: ' .. id .. ' and ' .. pid) end
         local bid=v.bodyId
         if bid==nil then bid=v.id v.bodyId=bid end
         if type(bid)~='number' then error('Invalid body ID: ' .. tostring(bid))
         elseif atlas[bid] then error('Duplicate body ID: ' .. tostring(bid)) end
         v.center=vec3(v.center)
         atlas[bid]=setmetatable(v,BodyParameters)
         pid=id
        end
        return setmetatable(atlas,PlanetarySystem)
       end

       PlanetaryReference={}
       local function mkPlanetaryReference(referenceTable) return setmetatable({ galaxyAtlas=referenceTable or {} },PlanetaryReference) end

       PlanetaryReference.__index=
       function(t,i)
        if type(i)=='number' then local system=t.galaxyAtlas[i] return mkPlanetarySystem(system) end
        return rawget(PlanetaryReference,i)
       end
       PlanetaryReference.__pairs=
       function(obj)
        return function(t,k)
        local nk,nv=next(t,k)
        return nk,nv and mkPlanetarySystem(nv) end,obj.galaxyAtlas,nil
       end
       PlanetaryReference.__tostring=
       function (obj)
        local pslist={}
        for _,ps in pairs(obj or {}) do
         local psi=ps:getPlanetarySystemId()
         local pss=PlanetarySystem.__tostring(ps,'    ')
         table.insert(pslist,S1('  [%s]={%s\n  }',psi,pss))
        end
        return S1('{\n%s\n}\n',table.concat(pslist,',\n'))
       end

       PlanetaryReference.BodyParameters=mkBodyParameters
       PlanetaryReference.MapPosition=mkMapPosition
       PlanetaryReference.PlanetarySystem=mkPlanetarySystem

       function PlanetaryReference.createBodyParameters(planetarySystemId,bodyId,surfaceArea,aPosition,verticalAtPosition,altitudeAtPosition,gravityAtPosition)
        assert(isSNumber(planetarySystemId),'Argument 1 (planetarySystemId) must be a number:' .. type(planetarySystemId))
        assert(isSNumber(bodyId),'Argument 2 (bodyId) must be a number:' .. type(bodyId))
        assert(isSNumber(surfaceArea),'Argument 3 (surfaceArea) must be a number:' .. type(surfaceArea))
        assert(isTable(aPosition),'Argument 4 (aPosition) must be an array or vec3:' .. type(aPosition))
        assert(isTable(verticalAtPosition),'Argument 5 (verticalAtPosition) must be an array or vec3:' .. type(verticalAtPosition))
        assert(isSNumber(altitudeAtPosition),'Argument 6 (altitude) must be in meters:' .. type(altitudeAtPosition))
        assert(isSNumber(gravityAtPosition),'Argument 7 (gravityAtPosition) must be number:' .. type(gravityAtPosition))
        local radius=math.sqrt(surfaceArea/4/math.pi)
        local distance=radius+altitudeAtPosition
        local center=vec3(aPosition)+distance*vec3(verticalAtPosition)
        local GM=gravityAtPosition*distance*distance
        return mkBodyParameters(planetarySystemId,bodyId,radius,center,GM)
       end

       PlanetaryReference.isMapPosition=isMapPosition

       function PlanetaryReference:getPlanetarySystem(overload)
        if self.galaxyAtlas then local planetarySystemId=overload
         if isMapPosition(overload) then planetarySystemId=overload.systemId end
         if type(planetarySystemId)=='number' then local system=self.galaxyAtlas[planetarySystemId]
          if system then
           if getmetatable(system)~=PlanetarySystem then system=mkPlanetarySystem(system) end
           return system
          end
         end
        end
        return nil
       end

       function PlanetarySystem:castIntersections(origin,direction,sizeCalculator,bodyIds)
        local sizeCalculator=sizeCalculator or
        function (body) return 1.05*body.radius end
        local candidates={}

        if bodyIds then for _,i in ipairs(bodyIds) do candidates[i]=self[i] end
        else bodyIds={}
         for k,body in pairs(self) do
          table.insert(bodyIds,k)
          candidates[k]=body
         end
        end
        local function compare(b1,b2)
         local v1=candidates[b1].center-origin
         local v2=candidates[b2].center-origin
         return v1:len()<v2:len()
        end
        table.sort(bodyIds,compare)
        local dir=direction:normalize()

        for i,id in ipairs(bodyIds) do
         local body=candidates[id]
         local c_oV3=body.center-origin
         local radius=sizeCalculator(body)
         local dot=c_oV3:dot(dir)
         local desc=dot^2-(c_oV3:len2()-radius^2)

         if desc>=0 then
          local root=math.sqrt(desc)
          local farSide=dot+root
          local nearSide=dot-root
          if nearSide>0 then return body,farSide,nearSide
          elseif farSide>0 then return body,farSide,nil end
         end
        end
        return nil,nil,nil
       end

       function PlanetarySystem:closestBody(coordinates)
        assert(type(coordinates)=='table','Invalid coordinates.')
        local minDistance2,body
        local coord=vec3(coordinates)

        for _,params in pairs(self) do
         local distance2=(params.center-coord):len2()
         if not body or distance2<minDistance2 then body=params minDistance2=distance2 end
        end
        return body
       end

       function PlanetarySystem:convertToBodyIdAndWorldCoordinates(overload)
        local mapPosition=overload
        if isString(overload) then mapPosition=mkMapPosition(overload) end

        if mapPosition.bodyId==0 then return 0,vec3(mapPosition.latitude,mapPosition.longitude,mapPosition.altitude) end
        local params=self:getBodyParameters(mapPosition)

        if params then return mapPosition.bodyId,params:convertToWorldCoordinates(mapPosition) end
       end

       function PlanetarySystem:getBodyParameters(overload)
        local bodyId=overload

        if isMapPosition(overload) then bodyId=overload.bodyId end
        assert(isSNumber(bodyId),'Argument 1 (bodyId) must be a number:' .. type(bodyId))

        return self[bodyId]
       end

      function PlanetarySystem:getPlanetarySystemId() local k,v=next(self) return v and v.planetarySystemId end

       function BodyParameters:convertToMapPosition(worldCoordinates)
        assert(isTable(worldCoordinates),'Argument 1 (worldCoordinates) must be an array or vec3:' .. type(worldCoordinates))
        local worldVec=vec3(worldCoordinates)

        if self.bodyId==0 then return setmetatable({latitude=worldVec.x,longitude=worldVec.y,altitude=worldVec.z,bodyId=0,systemId=self.planetarySystemId},MapPosition) end
        local coords=worldVec-self.center
        local distance=coords:len()
        local altitude=distance-self.radius
        local latitude=0
        local longitude=0

        if not float_eq(distance,0) then
         local phi=math.atan(coords.y,coords.x)
         longitude=phi>=0 and phi or (2*math.pi+phi)
         latitude=math.pi/2-math.acos(coords.z/distance)
        end
        return setmetatable({latitude=latitude,longitude=longitude,altitude=altitude,bodyId=self.bodyId,systemId=self.planetarySystemId},MapPosition)
       end

       function BodyParameters:convertToWorldCoordinates(overload)
        local mapPosition=isString(overload) and mkMapPosition(overload) or overload
        if mapPosition.bodyId==0 then return vec3(mapPosition.latitude,mapPosition.longitude,mapPosition.altitude) end
        assert(isMapPosition(mapPosition),'Argument 1 (mapPosition) is not an instance of "MapPosition".')
        assert(mapPosition.systemId==self.planetarySystemId,'Argument 1 (mapPosition) has a different planetary system ID.')
        assert(mapPosition.bodyId==self.bodyId,'Argument 1 (mapPosition) has a different planetary body ID.')
        local xproj=math.cos(mapPosition.latitude)
        return self.center+(self.radius+mapPosition.altitude)*vec3(xproj*math.cos(mapPosition.longitude),xproj*math.sin(mapPosition.longitude),math.sin(mapPosition.latitude))
       end

       function BodyParameters:getAltitude(worldCoordinates) return (vec3(worldCoordinates)-self.center):len()-self.radius end

       function BodyParameters:getDistance(worldCoordinates) return (vec3(worldCoordinates)-self.center):len() end

       function BodyParameters:getGravity(worldCoordinates)
        local radial=self.center-vec3(worldCoordinates)
        local len2=radial:len2()
        return (self.GM/len2)*radial/math.sqrt(len2)
       end

       return setmetatable(PlanetaryReference,{ __call=function(_,...) return mkPlanetaryReference(...) end })
      end

     --KEPLER
      function kepler()
       local vec3=require('cpml.vec3')
       local PlanetRef=planetref()

       local function isString(s) return type(s)=='string' end
       local function isTable(t)  return type(t)=='table'  end

       local function float_eq(a,b)
        if a==0 then return math.abs(b)<1e-09 end
        if b==0 then return math.abs(a)<1e-09 end
        return math.abs(a-b)<math.max(math.abs(a),math.abs(b))*epsilon
       end

       Kepler={}
       Kepler.__index=Kepler

       function Kepler:escapeAndOrbitalSpeed(altitude)
        assert(self.body)
        local distance=altitude+self.body.radius

        if not float_eq(distance,0) then
         local orbit=math.sqrt(self.body.GM/distance)
         return math.sqrt(2)*orbit,orbit
        end
        return nil,nil
       end

       function Kepler:orbitalParameters(overload,velocity)
        assert(self.body)
        assert(isTable(overload) or isString(overload))
        assert(isTable(velocity))
        local pos=(isString(overload) or PlanetRef.isMapPosition(overload)) and
         self.body:convertToWorldCoordinates(overload) or
         vec3(overload)
        local v=vec3(velocity)
        local r=pos-self.body.center
        local v2=v:len2()
        local d=r:len()
        local mu=self.body.GM
        local e=((v2-mu/d)*r-r:dot(v)*v)/mu
        local a=mu/(2*mu/d-v2)

        local ecc=e:len()
        local dir=e:normalize()
        local pd=a*(1-ecc)
        local ad=a*(1+ecc)
        local per=pd*dir+self.body.center
        local apo=ecc<=1 and -ad*dir+self.body.center or nil
        local trm=math.sqrt(a*mu*(1-ecc*ecc))
        local Period=apo and 2*math.pi*math.sqrt(a^3/mu)
        local trueAnomaly=math.acos((e:dot(r))/(ecc*d))
        if r:dot(v)<0 then trueAnomaly=-(trueAnomaly-2*math.pi) end
        local EccentricAnomaly=math.acos((math.cos(trueAnomaly)+ecc)/(1+ecc*math.cos(trueAnomaly)))
        local timeTau=EccentricAnomaly
        if timeTau<0 then timeTau=timeTau+2*math.pi end
        local MeanAnomaly=timeTau-ecc*math.sin(timeTau)
        local TimeSincePeriapsis=0
        local TimeToPeriapsis=0
        local TimeToApoapsis=0
        if Period~=nil then
         TimeSincePeriapsis=MeanAnomaly/(2*math.pi/Period)
         TimeToPeriapsis=Period-TimeSincePeriapsis
         TimeToApoapsis=TimeToPeriapsis+Period/2
         if trueAnomaly-math.pi>0 then
          TimeToPeriapsis=TimeSincePeriapsis
          TimeToApoapsis=TimeToPeriapsis+Period/2
         end
         if TimeToApoapsis>Period then TimeToApoapsis=TimeToApoapsis-Period end
        end

       return { periapsis={ position=per,speed=trm/pd,circularOrbitSpeed=math.sqrt(mu/pd),altitude=pd-self.body.radius},
        apoapsis=apo and
        { position=apo,speed=trm/ad,circularOrbitSpeed=math.sqrt(mu/ad),altitude=ad-self.body.radius},
        currentVelocity=v,currentPosition=pos,eccentricity=ecc,period=apo and 2*math.pi*math.sqrt(a^3/mu),eccentricAnomaly=EccentricAnomaly,meanAnomaly=MeanAnomaly,timeToPeriapsis=TimeToPeriapsis,timeToApoapsis=TimeToApoapsis
         }
       end

       local function new(bodyParameters)
        local params=PlanetRef.BodyParameters(bodyParameters.planetarySystemId,bodyParameters.bodyId,bodyParameters.radius,bodyParameters.center,bodyParameters.GM)
        return setmetatable({body=params},Kepler)
       end

       return setmetatable(Kepler,{ __call=function(_,...) return new(...) end })
      end

     --AUTHOR CATHARIUS
      --DAMAGE REPORT MODULE
       if DMG_Report then
        DMGLayoutTOP,DMGxTOP,DMGyTOP,DMGLayoutSIDE,DMGxSIDE,DMGySIDE=-90,90,30,0,0,0

       --General Functions
        function getElemCategory(elemtype)
         ElemCat="UNKNOWN"
         if elemtype~=nil then
          local CriticList={"DYNAMIC CORE","RESURRECTION NODE","RADAR"}
          local AvionicList={"ENGINE","FUEL-TANK","ADJUSTOR","VERTICAL BOOSTER","RETRO-ROCKET BRAKE","WING","ATMOSPHERIC AIRBRAKE"}
          local WpnList={"GUNNER MODULE","LASER","COMMAND SEAT CONTROLLER","COCKPIT","CANNON","MISSILE","RAILGUN"}

          --CRITICALS
           for _,reftype in ipairs(CriticList) do if string.match(elemtype,reftype) then ElemCat="CRITICALS" break end end

          --AVIONICS
           if ElemCat=="UNKNOWN" then for _,reftype in ipairs(AvionicList) do if string.match(elemtype,reftype) then ElemCat="AVIONICS" break end end

          --WEAPONS
           if ElemCat=="UNKNOWN" then for _,reftype in ipairs(WpnList) do if elemtype=="LASER" then ElemCat="WEAPON" break elseif string.match(elemtype,reftype) then ElemCat="WEAPON" break end end
           end end end
         return ElemCat
        end

       --Element Class
        Element={}
        Element.__index=Element

        function Element.new(elem_id,elem_type,ElemCat,elem_name,ElemX,ElemY,ElemZ)
         local self=setmetatable({},Element)
         self.elem_id=elem_id self.elem_maxhp=core.getElementMaxHitPointsById(elem_id) self.elem_type=elem_type self.ElemCat=ElemCat self.elem_name=elem_name self.ElemX=ElemX self.ElemY=ElemY self.ElemZ=ElemZ
         return self
        end

       --DmgMdl Class
        DmgMdl={}
        DmgMdl.__index=DmgMdl

        function DmgMdl.new()
         if DbInit=="Verified" then if G3("DMG Scale")~="" then DmgSize=G3("DMG Scale") else DmgSize=DMG_REP_Scale end else DmgSize=DMG_REP_Scale end

         local self=setmetatable({},DmgMdl)
         self.elem_list={}
         self.DmgMdlRatio=0

         --Getting the core offset
          local core_offset=-5
          self.DmgMdlRatio=10
          local core_hp=core.getElementHitPointsById(core.getLocalId())
          if core_hp>10000 then core_offset=-128 self.DmgMdlRatio=1 elseif core_hp>1000 then core_offset=-64 self.DmgMdlRatio=2 elseif core_hp>150 then core_offset=-32 self.DmgMdlRatio=5 end
          self.core_offset=core_offset

          --Adjustments
           self.DmgMdlRatio=self.DmgMdlRatio+DmgSize
           self.max_x=-999999999 self.min_x=999999999 self.max_y=-999999999 self.min_y=999999999 self.max_z=-999999999 self.min_z=999999999

         --Storing Ship Element
          for i,idelem in ipairs(core.getElementIdList()) do
           local elem_type=core.getElementDisplayNameById(idelem):upper()
           local elem_categ=getElemCategory(elem_type)
           local elem_name=core.getElementNameById(idelem)
           local x,y,z=table.unpack(core.getElementPositionById(idelem))
           x=(x+core_offset)*self.DmgMdlRatio y=(y+core_offset)*self.DmgMdlRatio z=(z+core_offset)*self.DmgMdlRatio
           if self.min_x>x then self.min_x=x end if self.min_y>y then self.min_y=y end if self.min_z>z then self.min_z=z end if self.max_x<x then self.max_x=x end if self.max_y<y then self.max_y=y end if self.max_z<z then self.max_z=z end
           self:add(Element.new(idelem,elem_type,elem_categ,elem_name,x,y,z))
          end

         --Computing ship size
          self.ship_width=0
          if self.min_x<0 then self.ship_width=self.ship_width+(self.min_x)*-1 else self.ship_width=self.ship_width+self.min_x end
          if self.max_x<0 then self.ship_width=self.ship_width+(self.max_x)*-1 else self.ship_width=self.ship_width+self.max_x end
          self.ship_height=0
          if self.min_y<0 then self.ship_height=self.ship_height+(self.min_y)*-1 else self.ship_height=self.ship_height+self.min_y end
          if self.max_y<0 then self.ship_height=self.ship_height+(self.max_y)*-1 else self.ship_height=self.ship_height+self.max_y end
          self.ship_z=0
          if self.min_z<0 then self.ship_z=self.ship_z+(self.min_z)*-1 else self.ship_z=self.ship_z+self.min_z end
          if self.max_z<0 then self.ship_z=self.ship_z+(self.max_z)*-1 else self.ship_z=self.ship_z+self.max_z end
         return self
        end

        function DmgMdl.add(self,element) table.insert(self.elem_list,element) end

        function DmgMdl.renderHTML(self)
         if DbInit=="Verified" then
          if G3("DMG TV U/D")~="" then DmgTranXTop=G3("DMG TV U/D") else DmgTranXTop=DmgTopUpDn end
          if G3("DMG TV L/R")~="" then DmgTranYTop=G3("DMG TV L/R") else DmgTranYTop=DmgTopLhRh end
          if G3("DMG SV U/D")~="" then DmgTranYside=G3("DMG SV U/D") else DmgTranYside=DmgSideUpDn end
          if G3("DMG SV L/R")~="" then DmgTranXside=G3("DMG SV L/R") else DmgTranXside=DmgSideLhRh end
         else DmgTranXTop=DmgTopUpDn DmgTranYTop=DmgTopLhRh DmgTranYside=DmgSideUpDn DmgTranXside=DmgSideLhRh end

         top_view_html_hud,side_view_html_hud,dead_elem_list_hud,high_damage_list_hud,medium_damage_list_hud,light_damage_list_hud="","","","","",""
         local label_x=self.max_x-self.min_x
         local maxtoptv,maxtopsv=-99999999999,-99999999999

         for _,elem in ipairs(self.elem_list) do
          local elem_hp=core.getElementHitPointsById(elem.elem_id)
          local elemmax_hp=core.getElementMaxHitPointsById(elem.elem_id)
          local ElemHpPercent=(elem_hp*100)/elemmax_hp
          local elem_restore=core.getRemainingRestorations(elem.elem_id)
          local color,opacity="",0.2
          ElemHpPercent=round(ElemHpPercent)
          if ElemHpPercent>=100 then color="#9BFFAC"
          elseif ElemHpPercent>=75 then opacity=0.3 color="#FFDD8E" light_damage_list_hud=light_damage_list_hud..[[<span class="ldmg">&nbsp]]..elem.elem_name..[[</span>&nbsp<span class="r">]]..ElemHpPercent..[[%</span><span class="f_right">(]]..elem_restore..[[)</span><br>]]
          elseif ElemHpPercent>=50 then color="#FF9E66" opacity=0.4 medium_damage_list_hud=medium_damage_list_hud..[[<span class="mdmg">&nbsp]]..elem.elem_name..[[</span>&nbsp<span class="r">]]..ElemHpPercent..[[%</span><span class="f_right">(]]..elem_restore..[[)</span><br>]]
          elseif ElemHpPercent>0 then color="#FF2819" opacity=0.5 high_damage_list_hud=high_damage_list_hud..[[<span class="hdmg">&nbsp]]..elem.elem_name..[[</span>&nbsp<span class="r">]]..ElemHpPercent..[[%</span><span class="f_right">(]]..elem_restore..[[)</span><br>]]
          elseif ElemHpPercent==0 then color="#7F120C" opacity=1 dead_elem_list_hud=dead_elem_list_hud..[[<span class="dead">&nbsp]]..elem.elem_name..[[</span>&nbsp<span class="r">0%</span><span class="f_right">(]]..elem_restore..[[)</span><br>]] end
          local left,top=0,0
         --Top view x,y
          if (elem.ElemX>=self.min_x and elem.ElemX<=0) and (elem.ElemY>=0 and elem.ElemY<=self.max_y) then
           left=((self.min_x*-1)+elem.ElemX)*ScRt
           top=(self.max_y-elem.ElemY)*ScRt
          elseif (elem.ElemX>0 and elem.ElemX<=self.max_x) and (elem.ElemY>=0 and elem.ElemY<=self.max_y) then
           left=((self.min_x*-1)+elem.ElemX)*ScRt
           top=(self.max_y-elem.ElemY)*ScRt
          elseif (elem.ElemX>=self.min_x and elem.ElemX<=0) and (elem.ElemY>=self.min_y and elem.ElemY<0) then
           left=((self.min_x*-1)+elem.ElemX)*ScRt
           top=(self.max_y+(elem.ElemY*-1))*ScRt
          elseif (elem.ElemX>0 and elem.ElemX<=self.max_x) and (elem.ElemY>=self.min_y and elem.ElemY<0) then
           left=((self.min_x*-1)+elem.ElemX)*ScRt
           top=(self.max_y+(elem.ElemY*-1))*ScRt
          end
          if maxtoptv<top then maxtoptv=top end
          top_view_html_hud=top_view_html_hud..[[<g transform=" rotate(]].. DMGLayoutTOP ..[[,]].. DMGxTOP ..[[,]].. DMGyTOP ..[[) translate(]].. DmgTranXTop ..[[,]].. DmgTranYTop ..[[)"><circle fill-opacity="]]..opacity..[[" cx="]]..left..[[" cy="]]..top..[[" r="5" fill="]]..color..[["/></g>]]
         --Side view y,z
          if (elem.ElemY>=self.min_y and elem.ElemY<=0) and (elem.ElemZ>=0 and elem.ElemZ<=self.max_z) then 
           left=((self.min_y*-1)+elem.ElemY)*ScRt
           top=(self.max_z-elem.ElemZ)*ScRt
          elseif (elem.ElemY>0 and elem.ElemY<=self.max_y) and (elem.ElemZ>=0 and elem.ElemZ<=self.max_z) then 
           left=((self.min_y*-1)+elem.ElemY)*ScRt
           top=(self.max_z-elem.ElemZ)*ScRt
          elseif (elem.ElemY>=self.min_y and elem.ElemY<=0) and (elem.ElemZ>=self.min_z and elem.ElemZ<0) then 
           left=((self.min_y*-1)+elem.ElemY)*ScRt
           top=(self.max_z+(elem.ElemZ*-1))*ScRt
          elseif (elem.ElemY>0 and elem.ElemY<=self.max_y) and (elem.ElemZ>=self.min_z and elem.ElemZ<0) then 
           left=((self.min_y*-1)+elem.ElemY)*ScRt
           top=(self.max_z+(elem.ElemZ*-1))*ScRt
          end
          if maxtopsv<top then maxtopsv=top end
          side_view_html_hud=side_view_html_hud..[[<g transform=" rotate(]].. DMGLayoutSIDE ..[[,]].. DMGxSIDE ..[[,]].. DMGySIDE ..[[) translate(]].. DmgTranXside ..[[,]].. DmgTranYside ..[[)"><circle fill-opacity="]]..opacity..[[" cx="]]..left..[[" cy="]]..top..[[" r="5" fill="]]..color..[["/></g>]]
         end

        --Top view code x,y
         top_view_html_hud=[[<svg width="]]..360*ScRt..[[" height="]]..150*ScRt..[[">]]..top_view_html_hud
         top_view_html_hud=top_view_html_hud ..[[</svg>]]
        --side view y,z
         side_view_html_hud=[[<svg width="]]..360*ScRt..[[" height="]]..150*ScRt..[[">]]..side_view_html_hud
         side_view_html_hud=side_view_html_hud ..[[</svg>]]

         return {dead_elem_list_hud,high_damage_list_hud,medium_damage_list_hud,light_damage_list_hud,top_view_html_hud,side_view_html_hud}
        end
        dmgrep=DmgMdl.new()
       end

    --AIR DATA
     function air_data()
      --ORBITAL DATA
       function orbital_data()
        local myPos,myVelocity=ConstructPos(),ConstructVel()

        local PlanetaryReference,Kepler,galaxyReference=planetref(),kepler(),PlanetaryReference(DUatlas)
        local helios=galaxyReference[0]
        local alioth=helios[2]
        local closestbody=helios:closestBody(myPos)
        local orbitInfo=Kepler(closestbody)
        local orbit=orbitInfo:orbitalParameters(myPos,myVelocity)
        local periapsis,apoapsis=orbit.periapsis.position,0
        if orbit.apoapsis~=nil then apoapsis=orbit.apoapsis.position end

        planet_name,planet_id,planet_pos,planet_radius=closestbody.name[1],closestbody.bodyId,closestbody.center,closestbody.radius
                if DUatlas[0][planet_id].atmosphereRadius then planet_Atmo_alt=M1(DUatlas[0][planet_id].atmosphereRadius) else planet_Atmo_alt=0 end
        if DUatlas[0][planet_id].maxStaticAltitude then SafeAlt=M1(DUatlas[0][planet_id].maxStaticAltitude) else SafeAlt=0 end
        orbit_ecc=M1(orbit.eccentricity*10000)/10000
        local orbit_per_pos=periapsis
        if orbit.period==nil then orbit.period=0 end
        OrbTSec=M1(orbit.period)
        local T_time_h=M1(OrbTSec/3600)
        local T_time_m=M1(((OrbTSec/3600)-T_time_h)*60)
        local T_time_s=M1(((((OrbTSec/3600)-T_time_h)*60)- T_time_m)*60)
        orbit_period=S1("%d:%02d:%02d",T_time_h,T_time_m,T_time_s)
        local orbit_apo_pos=apoapsis
        if orbit.apoapsis==nil then ApAlt,ApSpeed=0,0 else ApAlt,ApSpeed=M1(orbit.apoapsis.altitude),M1(orbit.apoapsis.speed) end

        if (TAp==nil or speed_hud==0 or speed_hud<50) then TAp="n/a" else
         TApSec=M1(orbit.timeToApoapsis)
         local ver=tostring(TApSec)
         if (ver=="nan" or ver=="inf" or ver=="-nan(ind)") then TApSec=0 end
         local A_time_h=M1(TApSec/3600)
         local A_time_m=M1(((TApSec/3600)-A_time_h)*60)
         local A_time_s=M1(((((TApSec/3600)-A_time_h)*60)-A_time_m)*60)
         TAp=S1("%d:%02d:%02d",A_time_h,A_time_m,A_time_s)
        end
        if (TPe==nil or speed_hud==0 or speed_hud<50) then TPe="n/a" else
         TPeSec=M1(orbit.timeToPeriapsis)
         local ver=tostring(TPeSec)
         if (ver=="nan" or ver=="inf" or ver=="-nan(ind)") then TPeSec=0 end
         local P_time_h=M1(TPeSec/3600)
         local P_time_m=M1(((TPeSec/3600)-P_time_h)*60)
         local P_time_s=M1(((((TPeSec/3600)-P_time_h)*60)-P_time_m)*60)
         TPe=S1("%d:%02d:%02d",P_time_h,P_time_m,P_time_s)
        end
        if orbit.periapsis==nil then PeAlt,PeSpeed=0,0 else PeAlt=M1(orbit.periapsis.altitude) end
        if orbit.periapsis.speed>0 then PeSpeed=M1(orbit.periapsis.speed) else PeSpeed,TAp,TPe=0,0,0 end

        orbit_circular_speed=M1(orbit.periapsis.circularOrbitSpeed)
        pe_dis=((orbit_per_pos-myPos):len())/1000
        apo_dis=((orbit_apo_pos-myPos):len())/1000
        my_planet_alt=(planet_pos-myPos):len()

        if DbInit=="Verified" then
         if G3("navigator_pe_target_altitude")~=0 then PeTargetAlt=M1(G3("navigator_pe_target_altitude")) else PeTargetAlt=PeTargetAlt end
        else PeTargetAlt=PeTargetAlt end
       end
       orbital_data()

      --BRAKE SYSTEM
       CTRL=false
       if DbInit=="Verified" then if G3("navigator_autobrake")~=nil then BrkStop=G3("navigator_autobrake") else BrkStop=Autobrake_Stop_Distance end
       else BrkStop=Autobrake_Stop_Distance end
       autobrake,autobrake_arm,parking_brk_on,autobrake_ecam_mode,autobrake_in=false,false,false,[[]],[[ Autobrake OFF ]]

       function parking_brk()
        if parking_brk_on then Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
         brakeInput,autoRoll_activated,autobrake_ecam_mode=1,true,[[<span style="color:tomato">Parking ON</span>]]
        elseif not parking_brk_on then brakeInput,autoRoll_activated,autobrake_ecam_mode=0,false,[[]] end
       end

       function autobrake_function()
        if space_pg then
         local cruise_speed,maxBurn=G3("navigator_speed"),MaxBurnSpeed()
         if (cruise_speed=="n/a" or cruise_speed==0 or cruise_speed=="") then cruise_speed=MaxSpeed()-100 end
         if (air_density()>0 and cruise_speed>maxBurn) then cruise_speed=maxBurn end
         autobrake_ecam_mode=[[<span style="color:yellow">Autobrake</span>&nbsp<span style="color:#00FFFF">ARM</span><br>Cruise Speed: <span style="color:#00FFFF">]]..M1(cruise_speed)..[[</span><br>]]
         if (distance_PPOS_B_hud~=nil and space_pg) then
          if DbInit=="Verified" then
           if G3("navigator_autobrake")~=nil then BrkStop=G3("navigator_autobrake") else BrkStop=Autobrake_Stop_Distance end
          else BrkStop=Autobrake_Stop_Distance end
          autobrake_in=M1((distance_PPOS_B_hud-brake_su-BrkStop)*100)/100
          if (distance_PPOS_B_hud>(brake_su+BrkStop) and autobrake_arm) then cruise_speed_f(cruise_speed) else CruiseSpeed=false end
          if (distance_PPOS_B_hud-0.02)<=(brake_su+BrkStop) then Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal) brakeInput=1 autobrake_arm,autobrake=false,true
           autobrake_ecam_mode=[[<span style="color:#7FFF00">Autobrake ON</span>]]
           if (distance_PPOS_B_hud<=BrkStop) then unit.stopTimer("autobrake") end
          else brakeInput=0 end
         end
        elseif orbit_pg then autobrake_ecam_mode=[[<span class="tomato">SPC to <span class="cyan">ENG</span> Autobrake]] end
       end

       function autobrake_disengage()
        autobrake_in,autobrake_ecam_mode=[[ Autobrake OFF ]],[[]]
        if autobrake then brakeInput=brakeInput-1 end
        autobrake,autobrake_arm=false,false
        Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
        unit.stopTimer("autobrake")
       end

      --AIR DENSITY
       function air_density() local D=M1((unit.getAtmosphereDensity())*100*10)/10 return D end

      --ALTITUDE
       altitude=M1(core.getAltitude())

      --ALTITUDE HOLD
       altitude_hold,autopilot_ecam_mode,TargetAltitude=false,[[]],[[]]
       function altitude_hold_function() autopilot_ecam_mode=[[ALT HOLD]] end

      --AUTOPILOT
       auto_wp=false
       function autopilot_wp() autopilot_ecam_mode=[[Autopilot ON<br>ALT HOLD]] end

      --SPEED/CRUISE SPEED
       speed_hud=M1((Velocity():len())*3.6)
       if Parking_Brake_Set then if speed_hud<10 then parking_brk_on=true parking_brk() end end

       if CruiseSpeed==nil then CruiseSpeed=false end
       function cruise_speed_f(speed)
        CruiseSpeed=true
        local speed,refSpeed=speed/3.6,speed+50
        if (throttlePID==nil) then throttlePID=pid.new(0.1,0,1) end
        local Velocity,Forward=ConstructVel(),Forward()
        local actualSpeed,thrLow=Velocity:dot(Forward),0.05
        if autobrake_arm then throttlePID:inject(speed-actualSpeed+10) else throttlePID:inject(speed-actualSpeed) thrLow=0 end
        if autobrake_arm then ThrPIDGet=throttlePID:get()/10 else ThrPIDGet=throttlePID:get() end
        if (ThrPIDGet<=thrLow and actualSpeed>speed) then ThrPIDGet=0 elseif ThrPIDGet>1 then ThrPIDGet=1 end
        calculatedThrottle=utils.clamp(ThrPIDGet,0,1)
        Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal,calculatedThrottle)
       end

      --PITCH/ROLL/YAW/BIRD/COMPASS
       function f_pitch_roll()

        function unit.getPitch()
         local world=0
         if antigrav then
          if antigrav.isActive() then world=(vec3(core.getWorldVertical())):normalize() else world=(vec3(core.getWorldGravity())):normalize() end
         else world=(vec3(core.getWorldGravity())):normalize() end
         local construct=Forward()
         local prod=math.asin(world:dot(construct))*-constants.rad2deg
         return prod
        end
        pitch_hud=M1((unit.getPitch())*10)/10

        function unit.getRoll()
         local worldVertical=0
         if antigrav then
          if antigrav.isActive() then worldVertical=vec3(core.getWorldVertical()) else worldVertical=vec3(core.getWorldGravity()) end
          else worldVertical=vec3(core.getWorldGravity()) end
         local constructForward,constructRight=Forward(),Right()
         local currentRollDeg=getRoll(worldVertical,constructForward,constructRight)
         local currentRollDegAbs=math.abs(currentRollDeg)
         local currentRollDegSign=utils.sign(currentRollDeg)
        return currentRollDeg
        end
        roll_hud=M1(unit.getRoll()*10)/10

        roll_direction=0
        if roll_hud<0 then roll_direction=[[<span style="font-size:]]..15*ScRt..[[px;color:#00FFFF"><</span>&nbsp]]..math.abs(roll_hud)
        elseif roll_hud>0 then roll_direction=math.abs(roll_hud) ..[[&nbsp<span style="font-size:]]..15*ScRt..[[px; color:#00FFFF">></span>]] end

        if speed_hud<20 then pitch_bird_hud,yaw_bird_hud,fpa_hud=0,0,0 else
         function getBirdPitch()
          local up=vec3(core.getWorldVertical())
          local velocity_vector=ConstructVel():normalize()
          local prod=math.asin(velocity_vector:dot(up))*constants.rad2deg
          local prod=prod+pitch_hud
          if roll_hud>90 or roll_hud<-90 then return -prod else return prod end
         end
         pitch_bird_hud=M1(getBirdPitch()*10)/10
         fpa_hud=M1((pitch_hud-pitch_bird_hud)*10)/10

         function getBirdYaw()
          local right=Right()
          local velocity_vector=ConstructVel():normalize()
          local cross=vec3(right:cross(velocity_vector))
          local forward=Forward():project_on_plane(cross):normalize()
          local prod=math.asin(velocity_vector:dot(right))*constants.rad2deg
          local prod=math.acos(velocity_vector:dot(forward))*constants.rad2deg
          local side=math.asin(velocity_vector:dot(right))*constants.rad2deg
          if side>0 then prod=prod else prod=-prod end
          return prod
         end
         yaw_bird_hud=M1(getBirdYaw()*10)/10

         if (roll_hud>15 and roll_hud<-15) then yaw_bird_corr=(pitch_bird_hud/math.tan(roll_hud)) else yaw_bird_corr=0 end
         yaw_bird_hud=(yaw_bird_hud+yaw_bird_corr)
        end

        function compass()
         local up=-vec3(core.getWorldVertical())
         local forward=Forward() forward=forward-forward:project_on(up)
         local north=vec3(0,0,1) north=north-north:project_on(up)
         local east=north:cross(up)
         local angle=north:angle_between(forward)*constants.rad2deg
         if forward:dot(east)<0 then angle=M1((360-angle)*10)/10 end
         return angle
        end
        compass_hud=compass()
       end
       f_pitch_roll()

      --SPACE ORIENTATION
       autopilot_ecam_mode,align_active_mode,adjusting_mode,deorb_ecam_mode=[[]],[[]],[[]],[[]]
       function space_orientation()
        if speed_hud==0 then pitch_space_hud,yaw_space_hud=0,0 else
         function unit.getSpacePitch()
          local up=Up()
          local velocity_vector=ConstructVel():normalize()
          local cross=vec3(up:cross(velocity_vector))
          local forward=Forward():project_on_plane(cross):normalize()
          local prod=math.acos(velocity_vector:dot(forward))*constants.rad2deg
          local side=math.asin(velocity_vector:dot(up))*constants.rad2deg
          if side<0 then prod=prod else prod=-prod end
          return prod
         end
         pitch_space_hud=M1(unit.getSpacePitch()*10)/10

         function unit.getSpaceYaw()
          local right=Right()
          local velocity_vector=ConstructVel():normalize()
          local cross=vec3(right:cross(velocity_vector))
          local forward=Forward():project_on_plane(cross):normalize()
          local prod=math.acos(velocity_vector:dot(forward))*constants.rad2deg
          local side=math.asin(velocity_vector:dot(right))*constants.rad2deg
          if side>0 then prod=prod else prod=-prod end
         return prod
         end
         yaw_space_hud=M1(unit.getSpaceYaw()*10)/10
        end

        if DbInit=="Verified" then
         if (db.getNbKeys()~=0 and G1("navigator_coordinates")~="n/a") then planet_B_coord=vec3FromStr(G1("navigator_coordinates")) else planet_B_coord=planet_pos end
        else planet_B_coord=planet_pos end

        function unit.getWPPitch()
         local up=Up()
         local myPos=ConstructPos()
         local wp_vector=(planet_B_coord-myPos):normalize()
         local cross=vec3(up:cross(wp_vector))
         local forward=Forward():project_on_plane(cross):normalize()
         local prod=math.acos(wp_vector:dot(forward))*constants.rad2deg
         local side=math.asin(wp_vector:dot(up))*constants.rad2deg
         if side<0 then prod=prod else prod=-prod end
        return prod
        end
        pitch_WP_hud=M1(unit.getWPPitch()*10)/10

        if atmo_pg then
         function unit.getWPYaw()
          local up=-vec3(core.getWorldVertical())
          local forward=Forward() forward=forward-forward:project_on(up)
          local myPos=ConstructPos()
          local wp_vector=(planet_B_coord-myPos):normalize() wp_vector=wp_vector-wp_vector:project_on(up)
          local right=wp_vector:cross(up)
          local angle=forward:angle_between(wp_vector)*constants.rad2deg
          if forward:dot(right)<0 then angle=M1((360-angle)*10)/10 end
          return angle
         end
         yaw_WP_hud=(M1(unit.getWPYaw()*10)/10)
        else
         function unit.getWPYaw()
          local right=Right()
          local myPos=ConstructPos()
          local wp_vector=(planet_B_coord-myPos):normalize()
          local cross=vec3(right:cross(wp_vector))
          local forward=Forward():project_on_plane(cross):normalize()
          local prod=math.acos(wp_vector:dot(forward))*constants.rad2deg
          local side=math.asin(wp_vector:dot(right))*constants.rad2deg
          if side>0 then prod=prod else prod=-prod end
          return prod
         end
         yaw_WP_hud=M1(unit.getWPYaw()*10)/10
        end

       end
       space_orientation()

      --SHIP ALIGNER
       auto_aligner,prograde_mode,orbit_maintainer,destination_mode,deorbit_mode=false,false,false,false,false
       function auto_align()
        if prograde_mode then target_pitch_to_align,target_yaw_to_align,align_active_mode=pitch_space_hud,yaw_space_hud,[[Aligning PROG]] end

        if destination_mode then target_pitch_to_align=pitch_WP_hud
         if not atmo_pg then target_yaw_to_align=yaw_WP_hud else
          if yaw_WP_hud>=180 then target_yaw_to_align=(360-yaw_WP_hud) elseif yaw_WP_hud<180 then target_yaw_to_align=-yaw_WP_hud end
         end
         align_active_mode=[[Aligning DEST]]
        end

        local up,right,constructAngularVelocity,pitchAngle,yawAngle=Up(),Right(),AngVelocity(),target_pitch_to_align,target_yaw_to_align

        local pitchAngleAbs,yawAngleAbs=math.abs(pitchAngle),math.abs(yawAngle)

        local autoPitchThreshold,autoPitchFactor,autoYawThreshhold,autoYawFactor,torqueFactor=0,0.8,0,0.3,2

        if pitchAngleAbs>autoPitchThreshold or yawAngleAbs>autoYawThreshhold then
         local targetPitchDeg=utils.clamp(0,pitchAngleAbs-30,pitchAngleAbs+30);
         local targetYawDeg=utils.clamp(0,yawAngleAbs-30,yawAngleAbs+30);
         if (pitchPID==nil) then pitchPID=pid.new(autoPitchFactor*0.01,0,autoPitchFactor*0.1) end
         if (yawPid==nil) then yawPID=pid.new(autoYawFactor*0.01,0,autoYawFactor*0.1) end
         pitchPID:inject(targetPitchDeg-pitchAngle)
         yawPID:inject(targetYawDeg-yawAngle)
         local autoPitchInput=pitchPID:get()
         local autoYawInput=yawPID:get()
         targetAngularVelocity=autoPitchInput*autoPitchFactor*right+autoYawInput*autoYawFactor*up
         local angularAcceleration=torqueFactor*(targetAngularVelocity-constructAngularVelocity)
         local airAcceleration=AirFriction()
         angularAcceleration=angularAcceleration-airAcceleration
         Nav:setEngineTorqueCommand('torque',angularAcceleration,keepCollinearity,'airfoil','','',tolerancePercentToSkipOtherPriorities)
        else targetAngularVelocity=0 Nav:setEngineTorqueCommand("torque",vec3.zero,targetAngularVelocity) end
       end

      --MAINTAINING ORBIT
       function maintaining_orbit()
        local AtmoAltitude=M1(planet_Atmo_alt-planet_radius)
        local function Inc() brakeInput=0 autobrake=false Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal,100) end
        local function Dec() Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal) brakeInput=1 autobrake=true end

        if (orbit_pg and auto_aligner and adjusting_mode==[[Orbiting ARM Auto]] and pe_dis<=(brake_km+(brake_km*0.05)) and speedMS>orbit_circular_speed and orbit_ecc>=0.8 and PeAlt>PeTargetAlt) then Dec()
        elseif not parking_brk_on and not CTRL then brakeInput=0 autobrake=false end

        if (not parking_brk_on and not CTRL and orbit_pg and auto_aligner and orbit_ecc<0.8 and ApAlt~=nil and PeAlt~=nil and TPeSec~=nil and TApSec~=nil and math.abs(target_pitch_to_align)<2 and math.abs(target_yaw_to_align)<2 and PeAlt>AtmoAltitude) then

         if (PeAlt<PeTargetAlt and TPeSec<TApSec and pe_dis>(apo_dis/3) and orbit_ecc<0.9) then Inc() adjusting_mode=[[Inc PE]]

         elseif (ApAlt<PeTargetAlt and TApSec<TPeSec and apo_dis>(pe_dis/3)) then Inc() adjusting_mode=[[Inc AP]]

         elseif (PeAlt>PeTargetAlt+5000 and TPeSec<TApSec and pe_dis>(apo_dis/3) and ApAlt>(PeTargetAlt+2000)) then Dec() adjusting_mode=[[Dec PE]]

         elseif (ApAlt>PeTargetAlt+5000 and TApSec<TPeSec and PeAlt>PeTargetAlt) then Dec() adjusting_mode=[[Dec AP]]

         elseif TApSec<=2 then
          if PeAlt<PeTargetAlt then Inc() adjusting_mode=[[Inc PE]] elseif PeAlt>PeTargetAlt+1000 then Dec() adjusting_mode=[[Dec PE]] end

         elseif TPeSec<=2 then
          if ApAlt<PeTargetAlt then Inc() adjusting_mode=[[Inc AP]] elseif ApAlt>PeTargetAlt+1000 then Dec() adjusting_mode=[[Dec AP]] end

         elseif (PeAlt<AtmoAltitude and TPeSec<TApSec and (pe_dis<=apo_dis/3)) then
          Dec() adjusting_mode=[[Unafe Orbit BRK ENG]] unit.setTimer("autobrake",1/2) autobrake_ecam_mode=[[<span style="color:#7FFF00">Autobrake ON</span>]]

         else Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal) brakeInput=0 autobrake=false adjusting_mode=[[</span><span style="color:#7FFF00">Maint ORBIT]]
         end
        else
         if ((space_pg or LoadPg or atmo_pg) and adjusting_mode~=[[</span><span style="color:#7FFF00">Maint ORBIT]]) then adjusting_mode=[[</span><span style="color:tomato">ORB Mode to ARM]] else adjusting_mode=[[Orbiting ARM]] end

         if adjusting_mode==[[Orbiting ARM]] then if New_pe_dis==nil then New_pe_dis=pe_dis end
          if (PeAlt>PeTargetAlt and planet_name==navigator_target_destination_hud and pe_dis>=brake_km and New_pe_dis>=pe_dis) then adjusting_mode=adjusting_mode..[[ Auto]] else adjusting_mode=adjusting_mode..[[ <span style="color:tomato">Pilot</span>]] end
         end
        end
       end

      --RADIO ALTIMITER/LDG GEAR
       GearInhibit=false
       function RadioAndGear()
        radioalt_hud=[[R.A. n/a]]
        local ra=""
        if radio_alt_1 then
         local MaxD=radio_alt_1.getMaxDistance()
         local T=radio_alt_1.getName()
         local TM=string.find(T,"Telemeter")
         if TM then ra=M1(radio_alt_1.raycast().distance) else ra=M1(radio_alt_1.getDistance()) end
         if ra~=-1 then radioalt_hud=[[R.A. ]]..ra..[[ m]] Nav.control.deployLandingGears() else radioalt_hud="" Nav.control.retractLandingGears() end
        end
        ldg_st=unit.isAnyLandingGearDeployed()
        if not ldg_st and Gear_Installed then ldg_st=[[red]] GND_Altitude=100 Nav.axisCommandManager:setTargetGroundAltitude(GND_Altitude) else ldg_st=[[green]] end
        radio_alt_value=ra
        return radioalt_hud
       end
       RadioAndGear()

      --DISTANCE TO WP FOR AI
       wp_color_init="none"
       function distance_to_wp_ai()
        if DbInit=="Verified" then
         if (db.getNbKeys()~=0 and G1("navigator_coordinates")~="n/a") then
          local WP_coordinates=vec3FromStr(G1("navigator_coordinates"))
          local myPos=ConstructPos()
          distance_to_wp=S1("%.1f",((WP_coordinates-myPos):len())/1000)
          wp_color=ActiveHUDColor
         else distance_to_wp,wp_color="n/a","none" end
        else distance_to_wp,wp_color="n/a","none" end
        if wp_color~=wp_color_init then wp_color_init=wp_color end
        return distance_to_wp
       end
       distance_to_wp_ai()

      --THROTTLE
       function thrust_setting()
        local mode=unit.getControlMode()
        if mode==0 then
         if ThrPIDGet==nil then ThrPIDGet=0 end
         if CruiseSpeed then thr=M1(ThrPIDGet*100) if thr>100 then thr=100 end
         else thr=M1(unit.getThrottle()) Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal,thr/100) end
         thr_h_svg,thr_hud,thr_text=thr,thr.." %",""
        elseif mode==1 then
         thr=M1(unit.getThrottle())
         thr_hud,thr_text,thr_h_svg=M1(thr/100),"Km/h",0
        end
       end
       thrust_setting()

      --VERTICAL SPEED
       function vertical_speed()
        local worldVelocity,gravity=ConstructVel(),vec3(core.getWorldGravity())
        local vs=M1(worldVelocity:dot(-gravity:normalize()))
        return vs
       end
       vs_hud=vertical_speed()

      --VTOL
       vtol_system,L_SHIFT=false,false
       function VtolGyro()
        if gyro then gyro.toggle() gyroscope_state=gyro.isActive()
         if gyroscope_state then gyroscope_state_ecam=[[<span style="color:#ff00ff">Gyro ON</span><br>]] else gyroscope_state_ecam=[[]] end
        else
         if not vtol_system then vtol_system=true gyroscope_state_ecam=[[<span style="color:#ff00ff">VTOL</span><br>]] elseif vtol_system then vtol_system=false gyroscope_state_ecam=[[]] end
        end
        stopengines_pressed=false
       end

      --FUEL MASS
       fuel_mass=0
       function total_fuel_mass()
        local a_fuel_mass=0
        if atmofueltank_size~=0 then
         for i=1,atmofueltank_size do a_fuel_mass=a_fuel_mass+atmofueltank[i].getItemsMass() t_a_fuel_mass=M1(a_fuel_mass/1000*10)/10 end
        else t_a_fuel_mass=0 end

        local s_fuel_mass=0
        if spacefueltank_size~=0 then
         for i=1,spacefueltank_size do s_fuel_mass=s_fuel_mass+spacefueltank[i].getItemsMass() t_s_fuel_mass=M1(s_fuel_mass/1000*10)/10 end
        else t_s_fuel_mass=0 end

        local r_fuel_mass=0
        if rocketfueltank_size~=0 then
         for i=1,rocketfueltank_size do r_fuel_mass=r_fuel_mass+rocketfueltank[i].getItemsMass() t_r_fuel_mass=M1(r_fuel_mass/1000*10)/10 end
        else t_r_fuel_mass=0 end

        fuel_mass=t_a_fuel_mass+t_s_fuel_mass+t_r_fuel_mass

       return fuel_mass
       end

      --DOCKING
       DockingMode,ConstructDocked,DockedConstructs,DockedMass,PaxOnBoard,PaxOnBoardMass="","","","","",""
       local MyId=ConstructId()
       function Docking()
        local a=ConstructDockingMode()
        if a==1 then DockingMode="Manual" elseif a==2 then DockingMode="Auto" elseif a==3 then DockingMode="Semi-Auto" end
        local b,c=Parent(),ClosestParent()
        if a==1 then if b~=0 then ConstructDocked="ALT+Y To Undock" elseif c~=0 then ConstructDocked="ALT+T To Dock" else ConstructDocked="" end
        else if b~=0 then ConstructDocked="Docked" elseif b==0 then ConstructDocked="" end end
        local d=DockedConstruct()
        if #d>0 then local counter,mass=0,0
         for i,v in pairs(d) do counter=counter+1 mass=mass+DockedConstructMass(v) end DockedConstructs=counter DockedMass=S1("%.1f",mass/1000)
        else DockedConstructs=0 DockedMass=0.0 end
        local e=PlayerOnBoard()
        if #e>0 then local counter,mass=0,0
         for i,v in pairs(e) do counter=counter+1 mass=mass+PlayerMass(v) end PaxOnBoard=counter PaxOnBoardMass=S1("%.1f",mass/1000)
        else PaxOnBoard=0 PaxOnBoardMass=0.0 end
       end
       Docking()

      --LOADING DATA
       function f_loading_data()
        if DbInit=="Verified" then
         if G3("navigator_MTOW")~=nil then MTOW=G3("navigator_MTOW") else MTOW=Maximum_Take_Off_Weight end
        else MTOW=Maximum_Take_Off_Weight end
        local cargo_m=0
        if container_size~=0 then
         for i=1,container_size do cargo_m=cargo_m+container[i].getItemsMass() cargo_m_t=M1((cargo_m/1000)*10)/10 cargo_m_t_hud=cargo_m_t+DockedMass end
        elseif DockedMass>0 then cargo_m_t,cargo_m_t_hud=DockedMass,DockedMass
        else cargo_m_t,cargo_m_t_hud=0,"n/a" end
       return cargo_m_t,cargo_m_t_hud
       end
       f_loading_data()

      --GW/ZFW/DOW
       gw_m,zfw_m,dow_m=ConstructMass(),0,0

      --MTOW PERCENTAGE
       MTOW_p=M1(gw_m*1000/MTOW*100)

      --NUMBER OF TANKS
       if atmofueltank_size~=0 then a_fuel_tank_n=atmofueltank_size else a_fuel_tank_n="0" end if spacefueltank_size~=0 then s_fuel_tank_n=spacefueltank_size else s_fuel_tank_n="0" end if rocketfueltank_size~=0 then r_fuel_tank_n=rocketfueltank_size else r_fuel_tank_n="0" end

      --AVG FUEL PERCENTAGE
       s_fuel_percent_avg_hud,a_fuel_percent_avg_hud,r_fuel_percent_avg_hud=0,0,0

       function avg_fuel_percentage()
        local a_fuel_percent=0
        if atmofueltank_size~=0 then for i=1,atmofueltank_size do if json.decode(atmofueltank[i].getWidgetData()).percentage then a_fuel_percent=a_fuel_percent+json.decode(atmofueltank[i].getWidgetData()).percentage end end
         a_fuel_percent_avg_hud=math.ceil(a_fuel_percent/atmofueltank_size)
        else a_fuel_percent_avg_hud=[[n/a]] end

        if spacefueltank_size~=0 then local s_fuel_percent=0
         for i=1,spacefueltank_size do if json.decode(spacefueltank[i].getWidgetData()).percentage then s_fuel_percent=s_fuel_percent+json.decode(spacefueltank[i].getWidgetData()).percentage end end
         s_fuel_percent_avg_hud=math.ceil(s_fuel_percent/spacefueltank_size)
        else s_fuel_percent_avg_hud=[[n/a]] end

        if rocketfueltank_size~=0 then local r_fuel_percent=0
         for i=1,rocketfueltank_size do if json.decode(rocketfueltank[i].getWidgetData()).percentage then r_fuel_percent=r_fuel_percent+json.decode(rocketfueltank[i].getWidgetData()).percentage end end
          r_fuel_percent_avg_hud=math.ceil(r_fuel_percent/rocketfueltank_size)
        else r_fuel_percent_avg_hud=[[n/a]] end
       end
       avg_fuel_percentage()

      --ATMO FUEL WARNING
       AFuelSpy,AFuelWrn=[[<span style="color:#141fad">A Fuel</span>]],[[]]
       if atmofueltank_size>0 then
        function atmo_fuel_percent()
         local FuelPerc=0 AFuelSpy,AFuelWrn=[[<span style="color:#141fad">A Fuel</span>]],[[]]
         for i=1,atmofueltank_size do
          if json.decode(atmofueltank[i].getWidgetData()).percentage then FuelPerc=json.decode(atmofueltank[i].getWidgetData()).percentage
           if FuelPerc<20 and FuelPerc>0 then AFuelSpy=[[<span style=" color:orange">A Fuel</span>]] AFuelWrn=AFuelWrn ..[[<span style=" color: orange">A Fuel Tank ]]..i..[[ LO LVL</span><br>]]
           elseif FuelPerc==0 then AFuelSpy=[[<span style=" color:red">A Fuel</span>]] AFuelWrn=AFuelWrn.. [[<span style=" color: red">A Fuel Tank ]]..i..[[ EMPTY</span><br>]]
           end
          end
         end
         return AFuelSpy,AFuelWrn
        end
       end

      --SPACE FUEL WARNING
       SFuelSpy,SFuelWrn=[[<span style=" color:#141fad">S Fuel</span>]],[[]]
       if spacefueltank_size>0 then
        function space_fuel_percent()
         local FuelPerc=0
         SFuelSpy,SFuelWrn=[[<span style=" color:#141fad">S Fuel</span>]],[[]]
         for i=1,spacefueltank_size do
          if json.decode(spacefueltank[i].getWidgetData()).percentage then FuelPerc=json.decode(spacefueltank[i].getWidgetData()).percentage
           if FuelPerc<20 and FuelPerc>0 then
            SFuelSpy=[[<span style=" color:orange">S Fuel</span>]]
            SFuelWrn=SFuelWrn ..[[<span style=" color: orange">S Fuel Tank ]]..i..[[ LO LVL</span><br>]]
           elseif FuelPerc==0 then
            SFuelSpy=[[<span style=" color:red">S Fuel</span>]]
            SFuelWrn=SFuelWrn.. [[<span style=" color: red">S Fuel Tank ]]..i..[[ EMPTY</span><br>]]
           end
          end
         end
         return SFuelSpy,SFuelWrn
        end
       end

      --ROCKET FUEL WARNING
       RFuelSpy,RFuelWrn,RktAct=[[<span style=" color:#141fad">R Fuel</span>]],[[]],[[#141fad]]
       if rocketfueltank_size>0 then
        function rocket_fuel_percent()
         local FuelPerc=0 RFuelSpy,RFuelWrn=[[<span style=" color:#141fad">R Fuel</span>]],[[]]
         for i=1,rocketfueltank_size do
          if json.decode(rocketfueltank[i].getWidgetData()).percentage then FuelPerc=json.decode(rocketfueltank[i].getWidgetData()).percentage
           if FuelPerc<20 and FuelPerc>0 then RFuelSpy=[[<span style=" color:orange">R Fuel</span>]] RFuelWrn=RFuelWrn ..[[<span style=" color: orange">R Fuel Tank ]]..i..[[ LO LVL</span><br>]]
           elseif FuelPerc==0 then RFuelSpy=[[<span style=" color:red">R Fuel</span>]] RFuelWrn=RFuelWrn.. [[<span style=" color: red">R Fuel Tank ]]..i..[[ EMPTY</span><br>]]
           end
          end
         end
         return RFuelSpy,RFuelWrn
        end
      --ROCKET WARNING LIGHT
        function r_warning_light()
         for i=1,rocketfueltank_size do RktAct=json.decode(rocketfueltank[i].getWidgetData()).timeLeft
          if RktAct=="n/a" then RktAct=[[#141fad]] else RktAct=[[red]] end
         end
        end
        r_warning_light()
       end

      --AGG
       AgArm,atigrav_widget,antigrav_base_alt=false,false,1000
       if DbInit=="Verified" and antigrav then navi_agg_op="" unit.setTimer("antigravity_op",1)
        if G1("agg eng/stby")~="ENG" then antigrav.deactivate() end
        if (db.getIntValue("agg_t_alt")~=nil and db.getIntValue("agg_t_alt")>=1000) then antigrav_target_alt=db.getIntValue("agg_t_alt") else antigrav_target_alt=1000 db.setIntValue("agg_t_alt",1000) end
       else antigrav_target_alt=1000 end
       agg_ecam_mode=[[]]
       function agg_status()
        if antigrav~=nil then antigravity_state=antigrav.isActive()
         if antigravity_state then AgArm,atigrav_widget=true,true antigrav.showWidget() agg_ecam_mode=[[AGG ON]]
          if DbInit=="Verified" then G2("agg off/stby","ACTIVE") G2("nav agg","ENG") unit.setTimer("antigravity",1) end
         end
        end
       end
       agg_status()

      --ECAM
       function ECAM()

        function autobrake_ecam()
         local br4=[[]]
         if (autobrake_ecam_mode==[[<span style="color:yellow">Autobrake</span>&nbsp<span style="color:#00FFFF">ARM</span><br>Cruise Speed: <span style="color:#00FFFF">]] or autobrake_ecam_mode==[[<span style="color:#7FFF00">Autobrake ON</span>]] or autobrake_ecam_mode==[[<span style="color:tomato">Parking ON</span>]] or autobrake_ecam_mode==[[<span class="tomato">SPC to <span class="cyan">ENG</span> Autobrake]]) then br4=[[<br>]] end
         local autobrake_ecam=autobrake_ecam_mode..br4
         return autobrake_ecam
        end
        autobrake_ecam()

        function agg_ecam()
         local br0,agg_ecam=[[]],[[]]
         if (agg_ecam_mode==[[AGG ON]] or agg_ecam_mode==[[<span class="cyan">AGG ARM</span>]]) then br0=[[<br>]] end

         if (agg_ecam_mode==[[AGG ON]] or agg_ecam_mode==[[<span class="cyan">AGG ARM</span>]]) then agg_ecam_mode=agg_ecam_mode..[[<br>Target: <span class="cyan">]]..antigrav_target_alt..[[&nbsp m</span><br>]] end

         agg_ecam=autobrake_ecam()..[[<span style="color:#7FFF00">]]..agg_ecam_mode..[[</span>]]..br0
         return agg_ecam
        end
        agg_ecam()

        function autopilot_ecam()
         local br1,br2,br3=[[]],[[]],[[]]
         if (autopilot_ecam_mode==[[<span class="tomato">Adjust Attitude</span>]] or autopilot_ecam_mode==[[DEORBITING]] or autopilot_ecam_mode==[[ALT HOLD]] or autopilot_ecam_mode==[[Autopilot ON<br>ALT HOLD]] or autopilot_ecam_mode==[[Autopilot ON-M1]] or autopilot_ecam_mode==[[Autopilot ON-M2]] or autopilot_ecam_mode==[[Autopilot ON-M3]]) then br1=[[<br>]] end

         if (autopilot_ecam_mode==[[<span class="tomato">Adjust Attitude</span>]]) then autopilot_ecam_mode=autopilot_ecam_mode..[[<br><span class="cyan">Max Bank 45<br>Max Pitch +25 -15</span><br>]] end

         if (DeorbitPossible and (autopilot_ecam_mode==[[Autopilot ON-M1]] or autopilot_ecam_mode==[[Autopilot ON-M2]])) then
          if DeorbDist==nil then DeorbDist=0 end
          deorb_ecam_mode=[[<br><span class="cyan">DEORB ]]..DeorbDist..[[ Km</span>]]
         else deorb_ecam_mode=[[]] end

         if (autopilot_ecam_mode==[[ALT HOLD]]) or autopilot_ecam_mode==[[Autopilot ON<br>ALT HOLD]] then autopilot_ecam_mode=autopilot_ecam_mode..[[<br><span class="cyan">]]..M1(TargetAltitude)..[[&nbsp m</span><br>]] end

         if (align_active_mode==[[Aligning PROG]] or align_active_mode==[[Aligning DEST]]) then br2=[[<br>]] end

         if (adjusting_mode==[[</span><span style="color:#7FFF00">Maint ORBIT]] or adjusting_mode==[[Maint ORB in: 3]] or adjusting_mode==[[Maint ORB in: 2]] or adjusting_mode==[[Maint ORB in: 1]] or adjusting_mode==[[Align DEST in: 3]] or adjusting_mode==[[Align DEST in: 2]] or adjusting_mode==[[Align DEST in: 1]] or adjusting_mode==[[Inc PE]] or adjusting_mode==[[Inc AP]] or adjusting_mode==[[Dec PE]] or adjusting_mode==[[Dec AP]] or adjusting_mode==[[Orbiting ARM Auto]] or adjusting_mode==[[Orbiting ARM <span style="color:tomato">Pilot</span>]] or adjusting_mode==[[Unafe Orbit BRK ENG]] or adjusting_mode==[[</span><span style="color:tomato">ORB Mode to ARM]]) then br3=[[<br>]] end

         local autopilot_ecam=agg_ecam()..[[<span style="color:#7FFF00">]]..autopilot_ecam_mode..[[</span><span style="color: #00FFFF">]]
         autopilot_ecam=autopilot_ecam..deorb_ecam_mode..br1..align_active_mode
         autopilot_ecam=autopilot_ecam..br2..adjusting_mode..[[</span>]]..br3
         return autopilot_ecam
        end
        autopilot_ecam()

        function gyro_ecam()
         local gyro_ecam=autopilot_ecam()
         if gyroscope_state_ecam==[[<span style="color:#ff00ff">Gyro ON</span><br>]] or gyroscope_state_ecam==[[<span style="color:#ff00ff">VTOL</span><br>]] then gyro_ecam=gyro_ecam..gyroscope_state_ecam end
         return gyro_ecam
        end
        gyro_ecam()

        function fuel_ecam()
         local fuel_ecam=gyro_ecam()..AFuelWrn fuel_ecam=fuel_ecam..SFuelWrn fuel_ecam=fuel_ecam..RFuelWrn
         return fuel_ecam
        end
        fuel_ecam()

        function ship_config()
         local ship_config_ecam=fuel_ecam()
         if radio_alt_1 then ship_config_ecam=ship_config_ecam else ship_config_ecam=ship_config_ecam..[[<br><span class="ecam_rec">R.A. Not Installed</span>]] end
         if container_1 then ship_config_ecam=ship_config_ecam else ship_config_ecam=ship_config_ecam..[[<br><span class="ecam_rec">Containers Not Linked</span>]] end
         if db then
          if DbInit~="Verified" then ship_config_ecam=ship_config_ecam..[[<br><span class="ecam_rec">Inizialize Databank</span>]] else ship_config_ecam=ship_config_ecam end
         else ship_config_ecam=ship_config_ecam..[[<br><span class="ecam_rec">Databank Not Installed</span>]] end
         return ship_config_ecam
        end
        ship_config()

        return ship_config()
       end
       ECAM()

      --ATMO FUEL MIN TIME
       a_t_h,a_t_m,a_t_s=0,0,0

       if atmofueltank_size~=0 then
        function a_fuel_minimum_time()
         local key,i=1,1
         local minutes_min=json.decode(atmofueltank[i].getWidgetData()).timeLeft
         while minutes_min=="n/a" do i=i+1 if i>atmofueltank_size then i,minutes_min=1,0 else minutes_min=json.decode(atmofueltank[i].getWidgetData()).timeLeft end end
         for k,v in ipairs(atmofueltank) do
          local timeleft=json.decode(atmofueltank[k].getWidgetData()).timeLeft
          if timeleft~="n/a" and timeleft>0 then if timeleft<minutes_min then key,minutes_min=k,timeleft end end
         end
         a_t_h=minutes_min/3600
         if a_t_h>999 then a_t_h=999 end
         a_t_m=(a_t_h-(M1(a_t_h)))*60
         a_t_s=(a_t_m-(M1(a_t_m)))*60
        end
       end

      --SPACE FUEL MIN TIME
       s_t_h,s_t_m,s_t_s=0,0,0

       if spacefueltank_size~=0 then
        function s_fuel_minimum_time()
         local key,i=1,1
         local minutes_min=json.decode(spacefueltank[i].getWidgetData()).timeLeft
         while minutes_min=="n/a" do i=i+1 if i>spacefueltank_size then i,minutes_min=1,0 else minutes_min=json.decode(spacefueltank[i].getWidgetData()).timeLeft end end
         for k,v in ipairs(spacefueltank) do
          local timeleft=json.decode(spacefueltank[k].getWidgetData()).timeLeft
          if timeleft~="n/a" and timeleft>0 then if timeleft<minutes_min then key,minutes_min=k,timeleft end end
         end
         s_t_h=minutes_min/3600
         if s_t_h>999 then s_t_h=999 end
         s_t_m=(s_t_h-(M1(s_t_h)))*60
         s_t_s=(s_t_m-(M1(s_t_m)))*60
        end
       end

      --ROCKET FUEL MIN TIME
       r_t_h,r_t_m,r_t_s=0,0,0

       if rocketfueltank_size~=0 then
        function r_fuel_minimum_time()
         local key,i=1,1
         local minutes_min=json.decode(rocketfueltank[i].getWidgetData()).timeLeft   
         while minutes_min=="n/a" do i=i+1 if i>rocketfueltank_size then i,minutes_min=1,0 else minutes_min=json.decode(rocketfueltank[i].getWidgetData()).timeLeft end end
         for k,v in ipairs(rocketfueltank) do
          local timeleft=json.decode(rocketfueltank[k].getWidgetData()).timeLeft
          if timeleft~="n/a" and timeleft>0 then if timeleft<minutes_min then key,minutes_min=k,timeleft end end
         end
         r_t_h=minutes_min/3600
         if r_t_h>999 then r_t_h=999 end
         r_t_m=(r_t_h-(M1(r_t_h)))*60
         r_t_s=(r_t_m-(M1(r_t_m)))*60
        end
       end

      --LIGHTS
       unit.switchOnHeadlights()

      --CHECK FOR DAMAGES
       dmg_color="#00FFFF"
       function dmg_checker()
        local ElementsID,eleMaxHp,eleHp=core.getElementIdList(),core.getElementMaxHitPointsById,core.getElementHitPointsById
        for k in pairs(ElementsID) do local hp,mhp=0,0
         mhp,hp=eleMaxHp(ElementsID[k]),eleHp(ElementsID[k])
         if ((mhp-hp)>2) then dmg_color="red" break else dmg_color="#00FFFF" end
        end
       end
       dmg_checker()

      --BRAKING DISTANCE
       final_speed_brk=0
       function braking_distance(final_speed_brk)

        local initialSp=(M1((Velocity():len())*3.6))
        local v=initialSp*0.277777777778

        local finalSp=(final_speed_brk)*0.277777777778
        local restMass=(ConstructMass()+DockedMass)*1000
        local rrThrust=MaxBrake()

        local totA,distance,time=rrThrust*1000/restMass,0,0

        if (initialSp>finalSp) then
         local t=v/totA
         local d=(v*v)/(2*totA)
         distance=distance+d
         time=time+t
        end

        brake_min=M1(time/60)
        brake_sec=M1(((time/60)-brake_min)*60)
        brake_su=M1(distance/200000*100)/100
        brake_km=M1(distance/1000)
       end
       braking_distance(final_speed_brk)

      --SPACE DATA
       function navigator_space_data()
        if G1("navigator_target_destination") then navigator_target_destination_hud=G1("navigator_target_destination") else navigator_target_destination_hud="no Dest." end

        if (db.getIntValue("navigator_eta_h") or db.getIntValue("navigator_eta_m") or db.getIntValue("navigator_eta_s")) then
         local time_h=db.getIntValue("navigator_eta_h")
         local time_m=db.getIntValue("navigator_eta_m")
         local time_s=db.getIntValue("navigator_eta_s")
         navigator_eta_hud=S1("%d:%02d:%02d",time_h,time_m,time_s)
        else navigator_eta_hud="0:00:00" end

        if G3("navigator_speed") then navigator_speed_hud=M1(G3("navigator_speed")) else navigator_speed_hud=0 end

        if G3("navigator_distance") then
         if G3("navigator_distance")==0 then navigator_distance_hud=0 else navigator_distance_hud=G3("navigator_distance") end
        end

        if G1("navigator_coordinates") then navigator_coordinates_hud=G1("navigator_coordinates") else navigator_coordinates_hud="n/a" end

        if G1("navigator_from") then navigator_from_hud=G1("navigator_from") else navigator_from_hud="no From" end

        if G1("navigator_from_coordinates") then navigator_from_coordinates_hud=G1("navigator_from_coordinates") else navigator_from_coordinates_hud="n/a" end
       end

      --RADAR
       radar_warning_hud=""
       function radar_contacts()
        if radar_1 then
         local ContactsID=table.unpack(radar_1.getConstructIds())
         if ContactsID~=nil then
          local radar_data,counter,min_distance=radar_1.getWidgetData():gmatch('"constructId":"[0-9]*","distance":[%d%.]*'),0,0
          for v in radar_data do counter=counter+1
           if counter<21 then
            local id,distance=v:match('"constructId":"([0-9]*)","distance":([%d%.]*)')
            local cDistance=round(distance/1000,2)
            local cType=radar_1.getConstructKind(id)
            if min_distance==0 then min_distance=cDistance elseif cDistance<min_distance then min_distance=cDistance end
            if (cType>=5 and cType<=7) then radar_warning_hud=[[<span class="rdr_hud red">RDR CONTACT</span><br><span class="rdr_hud white">]]..min_distance..[[</span>&nbsp<span class="rdr_hud units">Km</span>]]
            else radar_warning_hud="" end
           else break end
          end
         else radar_warning_hud="" end
        else radar_warning_hud="" end
       end
       radar_contacts()

      --SHIELD
       function shield_function()
        if shield then
         local shield_sts=shield.isActive()
         if shield_sts then shield_st_color="#7FFF00" else shield_st_color="#ff3333" end
         local max_shield,hp_shield=shield.getMaxShieldHitpoints(),shield.getShieldHitpoints()
         shield_percent=(hp_shield/max_shield*100).."%"
        else shield_st_color,shield_percent="#ff3333","Not Installed" end
       end
       shield_function()

      --DATABANK CONDITION for SPACE DATA
       function databank_condition()
        if db then
         if DbInit~="Verified" then navigator_target_destination_hud,navigator_eta_hud,navigator_speed_hud,navigator_distance_hud,navigator_coordinates_hud,navigator_from_hud,navigator_from_coordinates_hud="Interface is Off Turn ON to Initialize","n/a",0,0,"n/a","n/a","n/a"
         else navigator_space_data() end
        else navigator_target_destination_hud,navigator_eta_hud,navigator_speed_hud,navigator_distance_hud,navigator_coordinates_hud,navigator_from_hud,navigator_from_coordinates_hud="Databank Not Installed","n/a",0,0,"n/a","n/a","n/a" end
       end
       databank_condition()

      --HELMET HUD COLORS
       function helmet_hud_color()
        if HUDColorId==7 then HUDColorId=0 end
        HUDColorId=HUDColorId+1
        ActiveHUDColor=hud_color[HUDColorId]
       end

      --PVP STATION
       function PvP()
       --SETUP
        _autoconf.displayCategoryPanel(weapon,weapon_size, "Weapons","weapon",true)
        _autoconf.displayCategoryPanel(radar,radar_size, "Periscope","periscope")
        if UnitIsCockpit then G2("PVPCockpit","ON") elseif (UnitIsSeat and UnitType~="RemoteControlUnit") then G2("PVPGunner","ON") end

        RDRMaxRange=radar_1.getRange()
        local RDRRagnge=radar_1.getIdentifyRanges()
        local XSRange,SRange,MRange,LRange=RDRRagnge[1],RDRRagnge[2],RDRRagnge[3],RDRRagnge[4]
        local NbOfTargets=Targets_To_Show
        WeaponList={}
        weaponlinked=false
        local IDList={}

       --FRIEND LIST
        function FleetListFunction()
         FleetList={}
         local DBFleetList={}
         DBFleetList=G1("Fleet") DBFleetList=json.decode(DBFleetList)
         if (DBFleetList==nil or DBFleetList=="") then DBFleetList={} end
         for i=1,#DBFleetList do
          local id,n=tonumber(DBFleetList[i].id),DBFleetList[i].n
          local dist=radar_1.getConstructDistance(id)
          FleetList[i]={n=n,id=id,dist=dist}
         end
        end
        if db then FleetListFunction() end

       --TARGET LIST
        function TargetListFunction()
         local dataID=radar_1.getConstructIds()
         local radar_data=radar_1.getWidgetData():gmatch('"constructId":"[0-9]*","distance":[%d%.]*')
         DynamicTargetList={} TargetTotal=#dataID AbandonedList={} ThreatList={} IDList={}
         NbOfTargets=Targets_To_Show
         local RDRcounter,counterMAX,ABDcounter,THRcounter,Abandoned=0,NbOfTargets,0,0,false

         for v in radar_data do
          if RDRcounter<counterMAX then
           local id,distance=v:match('"constructId":"([0-9]*)","distance":([%d%.]*)')
           local cType=radar_1.getConstructKind(id)
           Abandoned=radar_1.isConstructAbandoned(id)
           if (cType==5 and not Abandoned) then local isFleet=false
            for x=1,#FleetList do if tonumber(id)==FleetList[x].id then isFleet=true break end end
            if not isFleet then RDRcounter=RDRcounter+1 DynamicTargetList[RDRcounter]={id=tonumber(id),dist=distance} end
            end
                      end
         end

         for i,v in pairs(dataID) do Abandoned=radar_1.isConstructAbandoned(v)
          if (Abandoned and ABDcounter<counterMAX) then ABDcounter=ABDcounter+1
           local n,dist=radar_1.getConstructName(v),radar_1.getConstructDistance(v)
           AbandonedList[ABDcounter]={n=n,dist=dist}
           IDList[#IDList+1]=v
          end
         end

         for i,v in pairs(dataID) do local Threat=radar_1.getThreatRateFrom(v)
          if (Threat>1 and THRcounter<counterMAX) then THRcounter=THRcounter+1
           local n,dist=radar_1.getConstructName(v),radar_1.getConstructDistance(v)
           ThreatList[THRcounter]={n=n,dist=dist}
           IDList[#IDList+1]=v
          end
         end

        end
        if radar_1.getOperationalState() then TargetListFunction() end

       --NB OF TARGETS TO SHOW
        PrevMin=0
        function Target()
         TargetList={}
         if NbOfTargets>#DynamicTargetList then NbOfTargets=#DynamicTargetList end
         for x=1,NbOfTargets do local id,idINS,min_distance,name,TLvl,Size,InRange=0,0,0,"","","",false
          for index in pairs(DynamicTargetList) do id=DynamicTargetList[index].id
           local distance=radar_1.getConstructDistance(id)
           if min_distance==0 then InRange=false idINS=id min_distance=distance name=radar_1.getConstructName(id) TLvl=radar_1.getThreatRateFrom(id) Size=radar_1.getConstructCoreSize(id)
            if Size=="XS" then if distance<=XSRange then InRange=true end
            elseif Size=="S" then if distance<=SRange then InRange=true end
            elseif Size=="M" then if distance<=MRange then InRange=true end
            elseif Size=="L" then if distance<=LRange then InRange=true end
            end
            if min_distance<PrevMin then min_distance=PrevMin end
           elseif ((distance<min_distance and distance>PrevMin) or (PrevMin==min_distance and distance>PrevMin)) then InRange=false idINS=id min_distance=distance name=radar_1.getConstructName(id) TLvl=radar_1.getThreatRateFrom(id) Size=radar_1.getConstructCoreSize(id)
            if Size=="XS" then if distance<=XSRange then InRange=true end
            elseif Size=="S" then if distance<=SRange then InRange=true end
            elseif Size=="M" then if distance<=MRange then InRange=true end
            elseif Size=="L" then if distance<=LRange then InRange=true end
            end
           end
          end
          IDList[#IDList+1]=idINS
          TargetList[x]={n=name,dist=tonumber(min_distance),TLvl=TLvl,InRange=InRange}
          if x==NbOfTargets then PrevMin=0 else PrevMin=min_distance end
         end
        end
        if radar_1.getOperationalState() then Target() end

       --TARGET INFO
        function TargetInfoFunction()
         TargetInfo={}
         local IDList=radar_1.getIdentifiedConstructIds()
         if IDList==nil then IDList={} end
         for i=1,#IDList do local id=IDList[i]
          local name,target,lock,speed,Aspeed=radar_1.getConstructName(id),radar_1.getTargetId(),false,0,0
          if target==id then speed=radar_1.getConstructSpeed(id) Aspeed=radar_1.getConstructRadialSpeed(id) lock=true end
          local TLel,size,dist,weapons=radar_1.getThreatRateFrom(id),radar_1.getConstructCoreSize(id),radar_1.getConstructDistance(id),radar_1.getConstructInfos(id).weapons
          if (weapons*0)~=0 then weapons=1.0 end
          local radars,spaceEngines=radar_1.getConstructInfos(id).radars,radar_1.getConstructInfos(id).spaceEngines
          TargetInfo[i]={n=name,lock=lock,TLvl=TLvl,size=size,dist=dist,weapons=weapons,radars=radars,spaceEngines=spaceEngines,speed=speed,Aspeed=Aspeed}
         end
        end

       --WEAPONS DATA
        if (weapon_size~=nil and weapon_size>0) then weaponlinked=true
         function wepdat()
          WeaponList={}
          for i=1,weapon_size do
           local data=weapon[i].getWidgetData() data=json.decode(data)
           local name,fireBlocked,fireReady,hitProb,optDist,optCone=data.name,data.properties.fireBlocked,data.properties.fireReady,data.properties.hitProbability,data.properties.optimalDistance,data.properties.optimalAimingCone
           WeaponList[i]={name=name,fireBlocked=fireBlocked,fireReady=fireReady,hitProb=hitProb,optDist=optDist,optCone=optCone}
          end
         end
        end

       --SENDING DATA
        function SendingData()
         local UpdateData={RDRMaxRange=RDRMaxRange,TargetList=TargetList,TargetTotal=TargetTotal,FleetList=FleetList,TargetInfo=TargetInfo,ThreatList=ThreatList,AbandonedList=AbandonedList,WeaponList=WeaponList}
         if serialize then UpdateData=serialize(UpdateData) G2("PVPStationData",UpdateData) else S.print("System Failed") end
        end

       --UPDATE
        unit.setTimer("PVPupdate",1) unit.setTimer("PVPsender",1/10)
       end

     end --AIR DATA

    --SVG
     --SVG A FUEL
      function a_fuel_svg()
       return [[<svg width="]]..30*ScRt..[[" height="]]..86*ScRt..[["><rect x="0" y="0" width="]]..30*ScRt..[[" height="]]..a_fuel_percent_avg_hud..[[%" style="fill:dodgerblue" transform="rotate(180,]]..15*ScRt..[[,]]..43*ScRt..[[)"/></svg>]]
      end

     --SVG S FUEL
      function s_fuel_svg()
       return [[<svg width="]]..30*ScRt..[[" height="]]..86*ScRt..[["><rect x="0" y="0" width="]]..30*ScRt..[[" height="]]..s_fuel_percent_avg_hud..[[%" style="fill:yellow" transform="rotate(180,]]..15*ScRt..[[,]]..43*ScRt..[[)"/></svg>]]
      end

     --SVG R FUEL
      function r_fuel_svg()
       return [[<svg width="]]..30*ScRt..[[" height="]]..86*ScRt..[["><rect x="0" y="0" width="]]..30*ScRt..[[" height="]]..r_fuel_percent_avg_hud..[[%" style="fill:slateblue" transform="rotate(180,]]..15*ScRt..[[,]]..43*ScRt..[[)"/></svg>]]
      end

     --SVG MTOW
      function MTOW_svg()
       return [[<svg width="]]..30*ScRt..[[" height="]]..44*ScRt..[["><rect x="0" y="0" width="]]..30*ScRt..[[" height="]]..MTOW_p..[[%" style="fill:yellow" transform="rotate(180,]]..15*ScRt..[[,]]..22*ScRt..[[)"/></svg>]]
      end

     --SVG THRUST
      function thr_svg()
       return [[<svg width="]]..36*ScRt..[[" height="]]..54*ScRt..[["><rect x="0" y="0" width="]]..36*ScRt..[[" height="]]..thr_h_svg..[[%" style="fill:#00FFFF" transform="rotate(180,]]..18*ScRt..[[,]]..27*ScRt..[[)"/>
        <text text-anchor="middle" x="]]..18*ScRt..[[" y="]]..25*ScRt..[[" style="fill:#00FFFF">]]..thr_text..[[</text></svg>]]
      end

     --SVG ARTIFICIAL HORIZON
      function art_h_svg()
       if vs_hud>300 then vs_svg=240 elseif vs_hud<-300 then vs_svg=360 else vs_svg=300+(vs_hud/-5) end
       local density,AtmoAltitude,wp_compass,compass=air_density(),M1(planet_Atmo_alt-planet_radius),M1(compass_hud-yaw_WP_hud),(-compass_hud)*10+250

       if wp_compass<0 then wp_compass=wp_compass+360 end
       if yaw_WP_hud>=180 then wp_box=(360-yaw_WP_hud)*10 elseif yaw_WP_hud<180 then wp_box=-yaw_WP_hud*10 end
       local HUDDistance=""
       if ToWp==nil then ToWp="WP" end
       if wp_color==ActiveHUDColor then
        if db then ToWp=G1("navigator_target_destination") else ToWp="WP" end
        if (distance_to_wp=="n/a" or speed_hud<50) then time_to_wp_hud="n/a" else local ATA_h=tonumber(distance_to_wp)/speed_hud local ATA_m=(ATA_h-M1(ATA_h))*60 local ATA_s=(ATA_m-M1(ATA_m))*60
         time_to_wp_hud=S1("%d:%02d:%02d",M1(ATA_h),M1(ATA_m),M1(ATA_s))
        end
        local gnd_alt=M1(unit.getSurfaceEngineAltitudeStabilization())
        if tonumber(distance_to_wp)~=nil then local Distance=tonumber(distance_to_wp)
         if Distance>200 then Distance=M1((Distance/200)*100)/100 .." Su" else Distance=Distance .." Km" end
         HUDDistance=Distance
        else HUDDistance=distance_to_wp end
       else time_to_wp_hud=0 end
       if AltHoldColor=="lightgreen" then AltHoldColor=ActiveHUDColor end
       if tgtSpeed==nil then tgtSpeed=0 end
       athrHUD,tgtSpeedHUD="A/THR OFF","" if CruiseSpeed then athrHUD,tgtSpeedHUD="A/THR ON","tgt "..tgtSpeed end

       local HUD_HELM={}
       HUD_HELM[#HUD_HELM+1]=[[<div class="hud_ai"><table><tr><td><svg width="]]..502*ScRt..[[" height="]]..25*ScRt..[[">
        <g transform="translate(]].. wp_box*ScRt ..[[ 0)"><rect x="]]..247.5*ScRt..[[" y="]]..15*ScRt..[[" width="]]..5*ScRt..[[" height="]]..10*ScRt..[[" fill="]].. wp_color ..[["/></g>
        <polyline id="HDGtriangle" class="linesHELM" points="]]..250*ScRt..[[,]]..15*ScRt..[[ ]]..245*ScRt..[[,0 ]]..255*ScRt..[[,0 ]]..250*ScRt..[[,]]..15*ScRt..[["/><g class="textHELM" transform="translate(]].. compass*ScRt ..[[ 0)">
        <text x="]].. -200*ScRt..[[" y="]]..23*ScRt..[[" text-anchor="middle">340<tspan x="]].. -100*ScRt..[[">350</tspan><tspan x="0">N</tspan>]]
       local x,y=0,0
       for i=1,8 do x=x+100 HUD_HELM[#HUD_HELM+1]=[[<tspan x="]].. x*ScRt ..[[">]].. S1("%.0f",x/10) ..[[</tspan>]] end
       HUD_HELM[#HUD_HELM+1]=[[<tspan x="]]..900*ScRt..[[">E</tspan>]]
       x=900
       for i=1,8 do x=x+100 HUD_HELM[#HUD_HELM+1]=[[<tspan x="]].. x*ScRt ..[[">]].. S1("%.0f",x/10) ..[[</tspan>]] end
       HUD_HELM[#HUD_HELM+1]=[[<tspan x="]]..1800*ScRt..[[">S</tspan>]]
       x=1800
       for i=1,8 do x=x+100 HUD_HELM[#HUD_HELM+1]=[[<tspan x="]].. x*ScRt ..[[">]].. S1("%.0f",x/10) ..[[</tspan>]] end
       HUD_HELM[#HUD_HELM+1]=[[<tspan x="]]..2700*ScRt..[[">W</tspan>]]
       x=2700
       for i=1,8 do x=x+100 HUD_HELM[#HUD_HELM+1]=[[<tspan x="]].. x*ScRt ..[[">]].. S1("%.0f",x/10) ..[[</tspan>]] end
       HUD_HELM[#HUD_HELM+1]=[[<tspan x="]]..3600*ScRt..[[">N</tspan><tspan x="]]..3700*ScRt..[[">10</tspan><tspan x="]]..3800*ScRt..[[">20</tspan></text></g></svg></tr></td>
        <tr><td><svg width="]]..502*ScRt..[[" height="]]..600*ScRt..[["><g class="linesHELM" transform="rotate(]].. -roll_hud ..[[,]]..250*ScRt..[[,]]..300*ScRt..[[) translate(0 ]].. pitch_hud*Vratio ..[[)">]]

       for i=1,37 do if i==19 then i=20 end
        local deg=95-(i*5)
        local y1,y2,d=300*ScRt+deg*Vratio,310*ScRt+deg*Vratio,0 if i<19 then d,y2=10,290*ScRt+deg*Vratio end
        HUD_HELM[#HUD_HELM+1]=[[<g class="pitchHELM"><text x="]]..110*ScRt..[[" y="]]..y1..[[" text-anchor="start">]]..-deg..[[</tspan><tspan x="]]..375*ScRt..[[" y="]]..y1..[[">]]..-deg..[[</tspan></tspan></text></g>
        <polyline points="]]..229*ScRt..[[,]]..y1..[[ ]]..130*ScRt..[[,]]..y1..[[ ]]..130*ScRt..[[,]]..y2..[[" stroke-dasharray="]]..d*ScRt..[["/>
        <polyline points="]]..271*ScRt..[[,]]..y1..[[ ]]..370*ScRt..[[,]]..y1..[[ ]]..370*ScRt..[[,]]..y2..[[" stroke-dasharray="]]..d*ScRt..[["/>]]
       end

       HUD_HELM[#HUD_HELM+1]=[[<polyline points="]]..229*ScRt..[[,]]..300*ScRt..[[ ]]..100*ScRt..[[,]]..300*ScRt..[[ ]]..100*ScRt..[[,]]..310*ScRt..[["/><polyline points="]]..271*ScRt..[[,]]..300*ScRt..[[ ]]..400*ScRt..[[,]]..300*ScRt..[[ ]]..400*ScRt..[[,]]..310*ScRt..[["/>
        <line id="Nose" class="lines05HELM" x1="]]..250*ScRt..[[" y1="]]..300*ScRt-pitch_hud*Vratio..[[" x2="]]..250*ScRt+yaw_bird_hud*Vratio..[[" y2="]]..300*ScRt+(-fpa_hud*Vratio)..[["/>
        <g class="linesHELM" transform="translate(]]..yaw_bird_hud*Vratio.." "..(-fpa_hud*Vratio)..[[) rotate(]]..roll_hud..[[,]]..250*ScRt..[[,]]..300*ScRt..[[)">
        <circle cx="]]..250*ScRt..[[" cy="]]..300*ScRt..[[" r="]]..5*ScRt..[[" fill-opacity="0"/>
        <line x1="]]..250*ScRt..[[" y1="]]..295*ScRt..[[" x2="]]..250*ScRt..[[" y2="]]..285*ScRt..[["/><line x1="]]..245*ScRt..[[" y1="]]..300*ScRt..[[" x2="]]..230*ScRt..[[" y2="]]..300*ScRt..[["/><line x1="]]..255*ScRt..[[" y1="]]..300*ScRt..[[" x2="]]..270*ScRt..[[" y2="]]..300*ScRt..[["/></g></g>
        <g class="circleHELM"><circle cx="]]..250*ScRt..[[" cy="]]..300*ScRt..[[" r="]]..3*ScRt..[["/></g>
        <g class="linesHELM"><rect x="0" y="]]..50*ScRt..[[" width="]]..90*ScRt..[[" height="]]..25*ScRt..[["/>
        <g class="textHELM"><text text-anchor="middle" x="]]..45*ScRt..[[" y="]]..68*ScRt..[[">]].. speed_hud ..[[</text><text text-anchor="left" x="]]..100*ScRt..[[" y="]]..68*ScRt..[[">Km/h</text>
        <text text-anchor="middle" x="]]..45*ScRt..[[" y="]]..100*ScRt..[[">]].. athrHUD ..[[</text>
        <text text-anchor="middle" x="]]..45*ScRt..[[" y="]]..120*ScRt..[[">]].. tgtSpeedHUD ..[[</text></g></g>
        <g class="textHELM">
        <text text-anchor="end" x="]]..40*ScRt..[[" y="]]..180*ScRt..[[">Atmo <tspan text-anchor="start" x="]]..40*ScRt..[[">]].. density ..[[&nbsp%</tspan>
        <tspan text-anchor="end" x="]]..40*ScRt..[[" y="]]..210*ScRt..[[">Atl </tspan><tspan text-anchor="start" x="]]..40*ScRt..[[">]].. AtmoAltitude ..[[ m</tspan>
        <tspan text-anchor="end" x="]]..40*ScRt..[[" y="]]..240*ScRt..[[">Safe </tspan><tspan text-anchor="start" x="]]..40*ScRt..[[">]].. SafeAlt+100 ..[[ m</tspan></text></g>
        <g class="textHELM"><text text-anchor="end" x="]]..39*ScRt..[[" y="]]..270*ScRt..[[">&alpha; <tspan text-anchor="start" x="]]..40*ScRt..[[">]].. (M1((pitch_bird_hud)*10)/10) ..[[</tspan></text></g>
        <g class="textHELM"><text text-anchor="end" x="]]..39*ScRt..[[" y="]]..300*ScRt..[[">FPA <tspan text-anchor="start" x="]]..40*ScRt..[[">]].. fpa_hud ..[[</tspan></text></g>
        <g class="linesHELM"><rect x="]]..410*ScRt..[[" y="]]..50*ScRt..[[" width="]]..90*ScRt..[[" height="]]..25*ScRt..[["/>
        <g class="textHELM"><text text-anchor="left" x="]]..385*ScRt..[[" y="]]..68*ScRt..[[">m</text>
        <text text-anchor="middle" x="]]..455*ScRt..[[" y="]]..68*ScRt..[[">]].. altitude ..[[</text></g></g>
        <g class="alt_hold"><text text-anchor="middle" x="]]..455*ScRt..[[" y="]]..100*ScRt..[[">ALT HOLD</text></g>
        <g class="linesHELM"><g class="textHELM">
        <text text-anchor="start" x="]]..420*ScRt..[[" y="]]..180*ScRt..[[">]].. radioalt_hud ..[[</text>
        <text text-anchor="start" x="]]..420*ScRt..[[" y="]]..220*ScRt..[[">V/S
        <tspan text-anchor="end" x="]]..500*ScRt..[[">]].. vs_hud ..[[</tspan></text></g>]]
       if brakeInput>0 then HUD_HELM[#HUD_HELM+1]=[[<g class="textHELM"><text text-anchor="middle" x="]]..250*ScRt..[[" y="]]..355*ScRt..[[">SPD BRK</text></g>]] end
       y,x=220*ScRt,425*ScRt
       for i=1,7 do y=y+20*ScRt if i==4 then x=410*ScRt else x=425*ScRt end HUD_HELM[#HUD_HELM+1]=[[<line x1="]]..440*ScRt..[[" y1="]].. y ..[[" x2="]].. x ..[[" y2="]].. y ..[["/>]] end
       HUD_HELM[#HUD_HELM+1]=[[<polyline points="]]..500*ScRt..[[,]]..300*ScRt..[[ ]]..445*ScRt..[[,]].. vs_svg*ScRt ..[[ ]]..425*ScRt..[[,]].. vs_svg*ScRt ..[["/></g>
        <g class="wptext"><rect class="wpHELM" x="]]..3*ScRt..[[" y="]]..364*ScRt..[[" width="]]..50*ScRt..[[" height="]]..20*ScRt..[["/>
        <text text-anchor="middle" x="]]..30*ScRt..[[" y="]]..380*ScRt..[[">]].. wp_compass ..[[
        <tspan text-anchor="start" x="]]..3*ScRt..[[" y="]]..400*ScRt..[[">]].. ToWp ..[[
        <tspan x="]]..3*ScRt..[[" y="]]..420*ScRt..[[">]].. HUDDistance ..[[</tspan>
        <tspan text-anchor="middle" x="]]..455*ScRt..[[" y="]]..420*ScRt..[[">]].. time_to_wp_hud ..[[</tspan>
        </text></g></svg></td></tr></table></div>]]
       local HTML=table.concat(HUD_HELM)
       return HTML
      end

     --SVG SPACE ORIENTATION
      function spc_hud()
       if g_hud==nil then g_hud=M1(((core.getGravityIntensity())/10)*10)/10 end
       local yawK=(16.6+math.abs(yaw_WP_hud/3*0.2))
       local pitchK=(16.6+math.abs(pitch_WP_hud/3*0.2))
       local HUD_HELM={}
       HUD_HELM[#HUD_HELM+1]=[[<div class="hud_spc"><table><tr><td><svg width="]].. ScrW ..[[" height="]]..25*ScRt..[["><g class="textHELM">
        <text x="]].. ScrW/2 ..[[" y="]]..23*ScRt..[[" text-anchor="middle">]].. active_hud_mode ..[[</text></g></svg></tr></td>
        <tr><td><svg width="]].. ScrW ..[[" height="]].. ScrH ..[["><g transform="translate(]].. (ScrW/2)-251*ScRt ..[[ 0)">
        <g class="linesHELM" transform="translate(]].. yaw_space_hud*yawK*ScRt .." ".. pitch_space_hud*pitchK*ScRt ..[[)">]]
       if speed_hud>=60 then HUD_HELM[#HUD_HELM+1]=[[<circle id="VelVector" cx="]]..251*ScRt..[[" cy="]]..300*ScRt..[[" r="]]..35*ScRt..[["/><line x1="]]..225*ScRt..[[" y1="]]..300*ScRt..[[" x2="]]..275*ScRt..[[" y2="]]..300*ScRt..[["/><line x1="]]..251*ScRt..[[" y1="]]..275*ScRt..[[" x2="]]..251*ScRt..[[" y2="]]..325*ScRt..[["/></g>
        <g class="linesHELM" transform="translate(]].. yaw_space_hud*10*ScRt .." ".. pitch_space_hud*10*ScRt ..[[)">]] end
       local cx,cy=2050*ScRt,3900*ScRt 
       for i=1,8 do if i<=3 then cy=(cy-1800)*ScRt elseif (i==4 and i==5) then cx=250*ScRt cy=cy-3600*ScRt elseif i>=6 then cx=-1500*ScRt cy=(cy-1800)*ScRt end
        HUD_HELM[#HUD_HELM+1]=[[<circle cx="]].. cx*ScRt ..[[" cy="]].. cy*ScRt ..[[" r="]]..25*ScRt..[["/>]]
        if i==3 then cy=5700*ScRt elseif i==5 then cy=3900*ScRt end
       end
       if speed_hud>=60 then HUD_HELM[#HUD_HELM+1]=[[
        <rect x="]].. -668*ScRt..[[" y="]]..282*ScRt..[[" width="]]..36*ScRt..[[" height="]]..36*ScRt..[["/><text class="textHELM" text-anchor="middle" x="]].. -650*ScRt..[[" y="]]..305*ScRt..[[">-90</text>
        <rect x="]]..1132*ScRt..[[" y="]]..282*ScRt..[[" width="]]..36*ScRt..[[" height="]]..36*ScRt..[["/><text class="textHELM" text-anchor="middle" x="]]..1150*ScRt..[[" y="]]..305*ScRt..[[">+90</text>
        <rect x="]].. -668*ScRt..[[" y="]]..2082*ScRt..[[" width="]]..36*ScRt..[[" height="]]..36*ScRt..[["/><text class="textHELM" text-anchor="middle" x="]].. -650*ScRt..[[" y="]]..2105*ScRt..[[">-90</text>
        <rect x="]]..1132*ScRt..[[" y="]].. -1518*ScRt..[[" width="]]..36*ScRt..[[" height="]]..36*ScRt..[["/><text class="textHELM" text-anchor="middle" x="]]..1150*ScRt..[[" y="]].. -1495*ScRt..[[">+90</text>
        <rect x="]].. -668*ScRt..[[" y="]].. -1518*ScRt..[[" width="]]..36*ScRt..[[" height="]]..36*ScRt..[["/><text class="textHELM" text-anchor="middle" x="]].. -650*ScRt..[[" y="]].. -1495*ScRt..[[">-90</text>
        <rect x="]]..1132*ScRt..[[" y="]]..2082*ScRt..[[" width="]]..36*ScRt..[[" height="]]..36*ScRt..[["/><text class="textHELM" text-anchor="middle" x="]]..1150*ScRt..[[" y="]]..2105*ScRt..[[">+90</text>
        <polyline points="]]..250*ScRt..[[,]].. -625*ScRt..[[ ]]..275*ScRt..[[,]].. -600*ScRt..[[ ]]..250*ScRt..[[,]].. -575*ScRt..[[ ]]..225*ScRt..[[,]].. -600*ScRt..[[ ]]..250*ScRt..[[,]].. -625*ScRt..[["/>
        <polyline points="]]..250*ScRt..[[,]]..1175*ScRt..[[ ]]..275*ScRt..[[,]]..1200*ScRt..[[ ]]..250*ScRt..[[,]]..1225*ScRt..[[ ]]..225*ScRt..[[,]]..1200*ScRt..[[ ]]..250*ScRt..[[,]]..1175*ScRt..[["/>
        <polyline points="]].. -1550*ScRt..[[,]].. -625*ScRt..[[ ]].. -1525*ScRt..[[,]].. -600*ScRt..[[ ]].. -1550*ScRt..[[,]].. -575*ScRt..[[ ]].. -1575*ScRt..[[,]].. -600*ScRt..[[ ]].. -1550*ScRt..[[,]].. -625*ScRt..[["/>
        <polyline points="]]..2050*ScRt..[[,]].. -625*ScRt..[[ ]]..2075*ScRt..[[,]].. -600*ScRt..[[ ]]..2050*ScRt..[[,]].. -575*ScRt..[[ ]]..2025*ScRt..[[,]].. -600*ScRt..[[ ]]..2050*ScRt..[[,]].. -625*ScRt..[["/>
        <polyline points="]]..2050*ScRt..[[,]]..1175*ScRt..[[ ]]..2075*ScRt..[[,]]..1200*ScRt..[[ ]]..2050*ScRt..[[,]]..1225*ScRt..[[ ]]..2025*ScRt..[[,]]..1200*ScRt..[[ ]]..2050*ScRt..[[,]]..1175*ScRt..[["/>
        <polyline points="]].. -1550*ScRt..[[,]]..1175*ScRt..[[ ]].. -1525*ScRt..[[,]]..1200*ScRt..[[ ]].. -1550*ScRt..[[,]]..1225*ScRt..[[ ]].. -1575*ScRt..[[,]]..1200*ScRt..[[ ]].. -1550*ScRt..[[,]]..1175*ScRt..[["/>]]
       end
       HUD_HELM[#HUD_HELM+1]=[[</g>
        <g id="HorizonLines" class="linesHELM" transform="rotate(]].. -roll_hud..[[,]]..251*ScRt..[[,]]..300*ScRt..[[) translate(0 ]].. pitch_hud*pitchK*ScRt ..[[)"><polyline points="]]..229*ScRt..[[,]]..300*ScRt..[[ ]]..100*ScRt..[[,]]..300*ScRt..[[ ]]..100*ScRt..[[,]]..310*ScRt..[["/><polyline points="]]..271*ScRt..[[,]]..300*ScRt..[[ ]]..400*ScRt..[[,]]..300*ScRt..[[ ]]..400*ScRt..[[,]]..310*ScRt..[["/></g>
        <g class="circleHELM"><circle cx="]]..251*ScRt..[[" cy="]]..300*ScRt..[[" r="]]..3*ScRt..[["/></g>]]
       if brakeInput>0 then HUD_HELM[#HUD_HELM+1]=[[<g class="textHELM"><text text-anchor="middle" x="]]..251*ScRt..[[" y="]]..390*ScRt..[[">SPD BRK</text></g>]] end
       if speed_hud>=60 then HUD_HELM[#HUD_HELM+1]=[[<g id="VelVectorLine" class="linesHELM"><line x1="]]..251*ScRt..[[" y1="]]..300*ScRt..[[" x2="]].. (251+yaw_space_hud*yawK)*ScRt ..[[" y2="]].. (300+pitch_space_hud*pitchK)*ScRt ..[["/></g>]] end
       HUD_HELM[#HUD_HELM+1]=[[<g class="linesHELM"><rect x="0" y="]]..50*ScRt..[[" width="]]..90*ScRt..[[" height="]]..25*ScRt..[["/><rect x="0" y="]]..75*ScRt..[[" width="]]..90*ScRt..[[" height="]]..25*ScRt..[["/>
        <g class="textHELM"><text text-anchor="middle" x="]]..45*ScRt..[[" y="]]..68*ScRt..[[">]].. speed_hud ..[[</text><text text-anchor="left" x="]]..100*ScRt..[[" y="]]..68*ScRt..[[">Km/h</text><text text-anchor="middle" x="]]..45*ScRt..[[" y="]]..93*ScRt..[[">]].. speedMS ..[[</text><text text-anchor="left" x="]]..100*ScRt..[[" y="]]..93*ScRt..[[">m/s</text></g></g>
        <g class="g_text"><text text-anchor="start" x="]]..40*ScRt..[[" y="]]..180*ScRt..[[">]].. planet_name ..[[<tspan text-anchor="start" x="]]..40*ScRt..[[" y="]]..210*ScRt..[[">G ]].. g_hud ..[[</tspan></text></g>
        <g class="linesHELM"><rect x="]]..410*ScRt..[[" y="]]..50*ScRt..[[" width="]]..90*ScRt..[[" height="]]..25*ScRt..[["/><g class="textHELM"><text text-anchor="left" x="]]..385*ScRt..[[" y="]]..68*ScRt..[[">m</text><text text-anchor="middle" x="]]..455*ScRt..[[" y="]]..68*ScRt..[[">]].. altitude ..[[</text></g></g>
        <g class="wpHELM"><g transform="translate(]].. yaw_WP_hud*yawK*ScRt .." ".. pitch_WP_hud*pitchK*ScRt ..[[)"><rect x="]]..215*ScRt..[[" y="]]..265*ScRt..[[" width="]]..70*ScRt..[[" height="]]..70*ScRt..[["/></g></g>
        <g class="wpHELM"><line x1="]]..251*ScRt..[[" y1="]]..300*ScRt..[[" x2="]].. (251+yaw_WP_hud*yawK)*ScRt ..[[" y2="]].. (300+pitch_WP_hud*pitchK)*ScRt ..[[" stroke-dasharray="]]..5*ScRt..[["/></g>
        </g></svg></td></tr></table></div>]]
       local HTML=table.concat(HUD_HELM)
       return HTML
      end

      function space_orientation_svg()
       local SVG={}
       SVG[#SVG+1]=[[
        <svg width="100%" height="100%" viewbox="0 0 ]]..150*ScRt..[[ ]]..70*ScRt..[[" style="background-color:black">
        <g id="Dest" class="wpHELM"><circle cx="]]..75*ScRt..[[" cy="]]..35*ScRt..[[" r="]]..12*ScRt..[["/></g>
        <g id="DestVectorLine" style="stroke:]].. wp_color ..[[;stroke-width:]]..ScRt..[["><line x1="]]..75*ScRt..[[" y1="]]..35*ScRt..[[" x2="]].. (75-yaw_WP_hud)*ScRt ..[[" y2="]].. (35-pitch_WP_hud)*ScRt ..[["/></g>
        <g id="Nose" style="stroke:yellow;stroke-width:]]..2*ScRt..[[" transform="translate(]].. -yaw_WP_hud*ScRt .." ".. -pitch_WP_hud*ScRt ..[[)"><line x1="]]..65*ScRt..[[" y1="]]..25*ScRt..[[" x2="]]..85*ScRt..[[" y2="]]..45*ScRt..[["/><line x1="]]..65*ScRt..[[" y1="]]..45*ScRt..[[" x2="]]..85*ScRt..[[" y2="]]..25*ScRt..[["/>]]
        if speed_hud>=60 then SVG[#SVG+1]=[[
        <g id="VelVector" style="stroke:white;stroke-width:]]..ScRt..[[;fill:none" transform="translate(]].. yaw_space_hud*ScRt .." ".. pitch_space_hud*ScRt ..[[)"><circle cx="]]..75*ScRt..[[" cy="]]..35*ScRt..[[" r="]]..10*ScRt..[[" style="stroke-width:]]..2*ScRt..[["/></g>
        <g id="VelVectorLine" style="stroke:white;stroke-width:]]..ScRt..[["><line x1="]]..75*ScRt..[[" y1="]]..35*ScRt..[[" x2="]].. (75+yaw_space_hud)*ScRt ..[[" y2="]].. (35+pitch_space_hud)*ScRt ..[["/></g>]]
        end
        SVG[#SVG+1]=[[</g><g style="font-size:]]..12*ScRt..[[px">
        <text x="]]..5*ScRt..[[" y="]]..20*ScRt..[[" fill="white" text-anchor="start">]].. yaw_space_hud ..[[
        <tspan x="]]..5*ScRt..[[" y="]]..35*ScRt..[[" fill="yellow" text-anchor="start">Yaw</tspan>
        <tspan x="]]..5*ScRt..[[" y="]]..50*ScRt..[[" fill="]].. wp_color ..[[" text-anchor="start">]].. yaw_WP_hud ..[[</tspan></text>
        <text x="]]..145*ScRt..[[" y="]]..20*ScRt..[[" fill="white" text-anchor="end">]].. -pitch_space_hud ..[[
        <tspan x="]]..145*ScRt..[[" y="]]..35*ScRt..[[" fill="yellow" text-anchor="end">Pitch</tspan>
        <tspan x="]]..145*ScRt..[[" y="]]..50*ScRt..[[" fill="]].. wp_color ..[[" text-anchor="end">]].. -pitch_WP_hud ..[[</tspan>
        </text></g></svg>]]
       local HTML=table.concat(SVG)
       return HTML
      end

     --SVG ORBIT
      TApSec=0
      ship_PPOS_svg=ConstructPos()
      function f_orbit_svg()
       if OrbTSec>0 then map_scale_setting=2500
        if scale==nil then scale=map_scale_setting end
        scale=scale
        local fix=80 local OrbCx=(PeAlt+ApAlt+2*planet_radius)/2/scale+fix local OrbRx=OrbCx-fix local PlCx=(OrbRx-(orbit_ecc*OrbRx))+fix local Plr=planet_radius/scale local OrbRy=math.sqrt(OrbRx^2-(orbit_ecc*OrbRx)^2) local ApCx=OrbCx+OrbRx local ShCx1=PlCx local ShCx2=PlCx+my_planet_alt/scale local altitude=my_planet_alt-planet_radius local PeTargetAlt_svg=Plr+(PeTargetAlt/scale) local AtmoAlt_svg=planet_Atmo_alt/scale

        local b,c=my_planet_alt/scale,(OrbCx-PlCx)*2 local a=(OrbRx*2)-b
        if TAp~=nil then
         if (OrbTSec>0 and TAp~="n/a" and (TApSec/OrbTSec)>=0.5) then LineR=math.deg(math.acos((b^2+c^2-a^2)/(2*b*c)))
          if (LineR~=LineR and (TApSec/OrbTSec)>0.75) then LineR=0 elseif (LineR~=LineR and (TApSec/OrbTSec)<0.75) then LineR=180 end else LineR=360-(math.deg(math.acos((b^2+c^2-a^2)/(2*b*c))))
          if (LineR~=LineR and (TApSec/OrbTSec)>0.25) then LineR=180 elseif (LineR~=LineR and (TApSec/OrbTSec)<0.25) then LineR=0 end
         end
        end

        if PeAlt<(PeTargetAlt-1000) then OrbCo=[[ red ]] else OrbCo=[[#00FFFF]] end
        if orbit_ecc==0 then orbit_Opacity=0 else orbit_Opacity=100 end

        if orbit_ecc<1 then ship_PPOS_svg=ConstructPos() end

        local OrbRy_max,OrbRy_min,ApCx_max,ApCx_min,min_scale=70,35,330,200,1000

        if OrbRy>OrbRy_max then scale_O=scale*2 end
        if OrbRy<OrbRy_max then if OrbRy<OrbRy_min then scale_O=scale/2 else scale_O=scale end end

        if ApCx>ApCx_max then scale_A=scale*2 end
        if ApCx<ApCx_max then if ApCx<ApCx_min then scale_A=scale/2 else scale_A=scale end end

        scale=math.max(scale_O,scale_A,min_scale)

        local OrbSpeed=M1(orbit_circular_speed)
        if OrbSpeed>(MaxSpeed()*1000/3600) then OrbSpeed="Too High" end

        return [[
         <svg width="]]..360*ScRt..[[" height="]]..150*ScRt..[[">
          <circle id="AtmoAlt" cx="]]..PlCx*ScRt..[[" cy="]]..75*ScRt..[[" r="]]..AtmoAlt_svg*ScRt..[[" stroke-width="]]..2*ScRt..[[" stroke="red" opacity="100%" fill="darkcyan" fill-opacity="10%"/>
          <circle id="TargetPEAlt" cx="]]..PlCx*ScRt..[[" cy="]]..75*ScRt..[[" r="]]..PeTargetAlt_svg*ScRt..[[" stroke-width="]]..1*ScRt..[[" stroke="white" fill="none"/>
          <circle id="Planet" cx="]]..PlCx*ScRt..[[" cy="]]..75*ScRt..[[" r="]]..Plr*ScRt..[[" fill="darkslategrey"/>
          <ellipse id="Orbit" cx="]]..OrbCx*ScRt..[[" cy="]]..75*ScRt..[[" rx="]]..OrbRx*ScRt..[[" ry="]]..OrbRy*ScRt..[[" style="fill:none;stroke:]]..OrbCo..[[;stroke-width:]]..1*ScRt..[[;opacity:]]..orbit_Opacity..[[%"/>
          <circle id="Pe" cx="]]..fix*ScRt..[[" cy="]]..75*ScRt..[[" r="]]..3*ScRt..[[" stroke="green" stroke-width="]]..1*ScRt..[[" fill="green"/>
          <circle id="Ap" cx="]]..ApCx*ScRt..[[" cy="]]..75*ScRt..[[" r="]]..3*ScRt..[[" stroke="green" stroke-width="]]..2*ScRt..[[" fill="none"/>
          <g transform=" rotate(]]..LineR.." "..ShCx1*ScRt..[[ ]]..75*ScRt..[[)"><line id="ship" x1="]]..ShCx1*ScRt..[[" y1="]]..75*ScRt..[[" x2="]]..ShCx2*ScRt..[[" y2="]]..75*ScRt..[[" stroke="yellow" stroke-width="]]..2*ScRt..[[" opacity="100%"/></g>
          <text x="]]..10*ScRt..[[" y="]]..20*ScRt..[[" fill="green" font-size="]]..15*ScRt..[[px">Altitude:<tspan x="]]..10*ScRt..[[" y="]]..40*ScRt..[[" fill="yellow">]]..M1(altitude/1000*10)/10 ..[[</tspan><tspan fill="#00FFFF"> Km</tspan></text>
          <text x="]]..10*ScRt..[[" y="]]..130*ScRt..[[" fill="green" font-size="]]..15*ScRt..[[px">Circ Orb Speed:<tspan x="]]..10*ScRt..[[" y="]]..150*ScRt..[[" fill="yellow">]]..OrbSpeed..[[</tspan><tspan fill="#00FFFF"> m/s</tspan></text>
          <text x="]]..250*ScRt..[[" y="]]..20*ScRt..[[" fill="green" font-size="]]..15*ScRt..[[px">Map Scale:<tspan x="]]..250*ScRt..[[" y="]]..40*ScRt..[[" fill="yellow">]]..M1(scale)..[[</tspan></text>
          <text x="]]..250*ScRt..[[" y="]]..130*ScRt..[[" fill="green" font-size="]]..15*ScRt..[[px">Dist To PE:<tspan x="]]..250*ScRt..[[" y="]]..150*ScRt..[[" fill="yellow">]]..M1(pe_dis)..[[</tspan><tspan fill="#00FFFF"> Km</tspan></text>
         </svg>
        ]]
       else
        return interplanet_svg()
       end
      end

     --SVG INTERPLANET
      nav_planet_scale=80000
      function interplanet_svg()

       local myPos=ConstructPos()

       if DbInit=="Verified" then
        if (db.getNbKeys()~=0 and G1("navigator_from_coordinates")~="n/a" and G1("navigator_from")~="PPOS") then
         planet_A_coord,from_name_hud,planet_A_opacity,from_planet_radius=vec3FromStr(G1("navigator_from_coordinates")),G1("navigator_from"),100,G3("navigator_from_planet_radius")
         planet_A_radius=(20/nav_planet_scale)* from_planet_radius
         x1_path,ship_x1,ship_x2=50+planet_A_radius,50+planet_A_radius,40+planet_A_radius
        elseif (db.getNbKeys()~=0 and G1("navigator_from_coordinates")~="n/a" and G1("navigator_from")=="PPOS") then
         planet_A_coord,from_name_hud,planet_A_opacity,planet_A_radius,x1_path,ship_x1,ship_x2=vec3FromStr(G1("navigator_from_coordinates")),"PPOS",0,20,50,50,40
        else planet_A_coord,from_name_hud,planet_A_opacity,planet_A_radius,x1_path,ship_x1,ship_x2=ship_PPOS_svg,"PPOS",0,20,50,50,40 end

        if (db.getNbKeys()~=0 and G1("navigator_coordinates")~="n/a") then planet_B_coord,to_name_hud,to_planet_radius=vec3FromStr(G1("navigator_coordinates")),G1("navigator_target_destination"),G3("navigator_target_planet_radius") planet_B_radius=(20/nav_planet_scale)*to_planet_radius x2_path=310-planet_B_radius
        else planet_B_coord,to_name_hud,to_planet_radius=planet_pos,planet_name,planet_radius planet_B_radius=(20/nav_planet_scale)*to_planet_radius x2_path=310-planet_B_radius end
       else planet_A_coord,from_name_hud,planet_A_opacity,planet_B_coord,to_name_hud,to_planet_radius=ship_PPOS_svg,"PPOS",0,planet_pos,planet_name,planet_radius planet_B_radius=(20/nav_planet_scale)*to_planet_radius x2_path=310-planet_B_radius

        x1_path,planet_A_radius,ship_x1,ship_x2=50,20,50,40
       end

       distance_PPOS_B_hud=M1(((planet_B_coord-myPos):len())/1000/200*100)/100
       local distance_PPOS_A_hud=M1(((planet_A_coord-myPos):len())/1000/200*100)/100

       local ATA_hud,ATA_h,ATA_m,ATA_s="n/a",0,0,0
       if speed_hud~=0 then ATA_h=(((planet_B_coord-myPos):len())/1000)/speed_hud ATA_m=(ATA_h-M1(ATA_h))*60 ATA_s=(ATA_m-M1(ATA_m))*60
        ATA_hud=S1("%d:%02d:%02d",M1(ATA_h),M1(ATA_m),M1(ATA_s))
       end

       local tot_distance,OrbSpeed=distance_PPOS_A_hud+distance_PPOS_B_hud,M1(orbit_circular_speed)

       if OrbSpeed>(MaxSpeed()*1000/3600) then OrbSpeed="Too High" end

       x1_x2_path=x2_path-x1_path xm_path=(x2_path+x1_path)/2

       if from_name_hud=="PPOS" then ship_pos_svg=x1_x2_path-(distance_PPOS_B_hud/tot_distance)*x1_x2_path
        if (distance_PPOS_B_hud/tot_distance)>0.5 then ship_pos_svg=ship_pos_svg+((to_planet_radius/1000/200)/tot_distance)*x1_x2_path else ship_pos_svg=ship_pos_svg end
       elseif from_name_hud~="PPOS" then ship_pos_svg=(distance_PPOS_A_hud/tot_distance)*x1_x2_path
        if (distance_PPOS_A_hud/tot_distance)<0.5 then ship_pos_svg=ship_pos_svg-((from_planet_radius/1000/200)/tot_distance)*x1_x2_path else ship_pos_svg=ship_pos_svg end
       end

       return [[
        <svg width="]]..360*ScRt..[[" height="]]..150*ScRt..[[">
         <line id="Path" x1="]]..x1_path*ScRt..[[" y1="]]..55*ScRt..[[" x2="]]..x2_path*ScRt..[[" y2="]]..55*ScRt..[[" stroke="yellow" stroke-width="]]..ScRt..[["/>
         <line id="HalfPath" x1="]]..xm_path*ScRt..[[" y1="]]..50*ScRt..[[" x2="]]..xm_path*ScRt..[[" y2="]]..60*ScRt..[[" stroke="yellow" stroke-width="]]..ScRt..[["/>

         <circle id="Planet_A" cx="]]..50*ScRt..[[" cy="]]..55*ScRt..[[" r="]]..planet_A_radius*ScRt..[[" style="fill:darkslategrey;stroke:#00FFFF;stroke-width:]]..ScRt..[[;opacity:]]..planet_A_opacity..[["/>
         <circle id="Planet_B" cx="]]..310*ScRt..[[" cy="]]..55*ScRt..[[" r="]]..planet_B_radius*ScRt..[[" style="fill:darkslategrey;stroke:#00FFFF;stroke-width:]]..ScRt..[[;"/>

         <g transform="translate(]]..ship_pos_svg*ScRt..[[ 0)"><polygon points="]]..ship_x1*ScRt..[[,]]..55*ScRt..[[ ]]..ship_x2*ScRt..[[,]]..63*ScRt..[[ ]]..ship_x2*ScRt..[[,]]..47*ScRt..[[" style="fill:#00FFFF;stroke:green;stroke-width:]]..ScRt..[[;fill-rule:evenodd"/></g>
         <text x="]]..10*ScRt..[[" y="]]..15*ScRt..[[" fill="green" font-size="]]..14*ScRt..[[px">From:<tspan x="]]..10*ScRt..[[" y="]]..30*ScRt..[[" fill="#00FFFF">]]..from_name_hud..[[</tspan></text>
         <text x="]]..140*ScRt..[[" y="]]..15*ScRt..[[" fill="green" font-size="]]..14*ScRt..[[px">Dist:<tspan x="]]..140*ScRt..[[" y="]]..30*ScRt..[[" fill="yellow">]]..tot_distance..[[</tspan><tspan fill="#00FFFF"> Su</tspan></text>
         <text x="]]..250*ScRt..[[" y="]]..15*ScRt..[[" fill="green" font-size="]]..14*ScRt..[[px">To:<tspan x="]]..250*ScRt..[[" y="]]..30*ScRt..[[" fill="#00FFFF">]]..to_name_hud..[[</tspan></text>
         <text x="]]..10*ScRt..[[" y="]]..90*ScRt..[[" fill="green" font-size="]]..14*ScRt..[[px">Dist:<tspan x="]]..10*ScRt..[[" y="]]..105*ScRt..[[" fill="yellow">]]..distance_PPOS_A_hud..[[</tspan><tspan fill="#00FFFF"> Su</tspan></text>
         <text x="]]..140*ScRt..[[" y="]]..90*ScRt..[[" fill="green" font-size="]]..14*ScRt..[[px">Fly Time:<tspan x="]]..140*ScRt..[[" y="]]..105*ScRt..[[" fill="yellow">]]..ATA_hud..[[</tspan></text>
         <text x="]]..250*ScRt..[[" y="]]..90*ScRt..[[" fill="green" font-size="]]..14*ScRt..[[px">Dist:<tspan x="]]..250*ScRt..[[" y="]]..105*ScRt..[[" fill="yellow">]]..distance_PPOS_B_hud..[[</tspan><tspan fill="#00FFFF"> Su</tspan></text>
         <text x="]]..10*ScRt..[[" y="]]..130*ScRt..[[" fill="green" font-size="]]..14*ScRt..[[px">Circ Orb Speed:<tspan x="]]..10*ScRt..[[" y="]]..145*ScRt..[[" fill="yellow">]]..OrbSpeed..[[</tspan><tspan fill="#00FFFF"> m/s</tspan></text>
         <text x="]]..250*ScRt..[[" y="]]..130*ScRt..[[" fill="green" font-size="]]..14*ScRt..[[px">Dist To PE:<tspan x="]]..250*ScRt..[[" y="]]..145*ScRt..[[" fill="yellow">]]..M1(pe_dis)..[[</tspan><tspan fill="#00FFFF"> Km</tspan></text>
        </svg>
       ]]
      end

    --HTML SCREENS
     --CSS
      CameraYDeg,CameraXDeg=0,0
      function html_style()
       local hud_pos_x,hud_pos_y=(ScrW/2)-251*ScRt,(ScrH/2)-322*ScRt
       local FWDx,FWDy=ScrW/2-23*ScRt,ScrH/2+7*ScRt
       local FWDy1,FWDy2=FWDy-10*ScRt,FWDy-25*ScRt
       local g_color=ActiveHUDColor
       if shield_st_color==nil then shield_st_color="#ff3333" end
       if wp_color==nil then wp_color="none" end
       local css={}
       css[#css+1]=[[<style>
       .hud_spc {position:absolute;top:]].. hud_pos_y ..[[px;left:0px;}
       .hud_ai {position:absolute;top:]].. hud_pos_y ..[[px;left:]].. hud_pos_x ..[[px;}
       .linesHELM {stroke:]].. ActiveHUDColor ..[[;stroke-width:1;fill:none;}
       .lines05HELM {stroke:]].. ActiveHUDColor ..[[;stroke-width:0.5;fill:none;}
       .circleHELM {stroke:]].. ActiveHUDColor ..[[;stroke-width:1;fill:]].. ActiveHUDColor ..[[;}
       .pitchHELM {font-family:arial;font-size:]]..12*ScRt..[[px;stroke-width:0;fill:]].. ActiveHUDColor ..[[;}
       .textHELM {font-family:arial;font-size:]]..15*ScRt..[[px;stroke-width:0;fill:]].. ActiveHUDColor ..[[;}
       .wptext {font-family:arial;font-size:]]..15*ScRt..[[px;stroke-width:0;fill:]].. wp_color ..[[;}
       .wpHELM {stroke:]].. wp_color ..[[;stroke-width:2;fill:none;}
       .alt_hold {font-family:arial;font-size:]]..15*ScRt..[[px;stroke-width:0;fill:]].. AltHoldColor ..[[;}
       .g_effect {stroke:]].. g_color ..[[;stroke-width:2;fill:none;}
       .g_text {font-family:arial;font-size:]]..15*ScRt..[[px;stroke-width:0;fill:]].. g_color ..[[;}
       .containerDiv {position:relative;top:]]..CameraXDeg-(5*ScRt)..[[vh;left:]]..-CameraYDeg..[[vw;}
       .rh_m_div {position:absolute;bottom:]]..RH_Panel_Y..[[vh;right:]]..RH_Panel_X..[[vw;}
       .lh_m_div {position:absolute;bottom:]]..LH_Panel_Y..[[vh;left:]]..LH_Panel_X..[[vw;}
       .top_lh_div {position:absolute;top:]]..LH_TOP_Panel_Y..[[vh;left:]]..LH_TOP_Panel_X..[[vw;}
       .top_rh_div{position:absolute;top:]]..RH_TOP_Panel_Y..[[vh;right:]]..RH_TOP_Panel_X..[[vw;}
       .tbl {border:]]..ScRt..[[px solid yellow;text-align:center;vertical-align:middle;color:yellow;font-size:]]..11*ScRt..[[px;}
       .top {vertical-align:top;}
       .txcx {text-align:center;}
       .ecam {vertical-align:top;border:]]..ScRt..[[px solid slategray;text-align:left;}
       .ecam_rec {color:slategray;}
       .green {color:green;}
       .lgt_green {color:#7FFF00;}
       .yellow {color:yellow;}
       .red {color:red;}
       .rdr_hud {text-align:center;vertical-align:top;font-size:]]..9*ScRt..[[px;}
       .tomato{color:#ff3333;}
       .white {color:white;}
       .svg_box {border:]]..ScRt..[[px solid #00FFFF;}
       .cyan {color:#00FFFF;}
       .left {text-align:left;}
       .right {text-align:right;}
       .f_right {float:right;}
       .px10 {font-size:]]..10*ScRt..[[px;}
       .px16 {font-size:]]..16*ScRt..[[px;}
       .shield_st {color:]]..shield_st_color..[[;}
       .an_lgt {border:1px solid slategray;}
       .ldmg {color:LightYellow;}
       .mdmg {color:gold;}
       .hdmg {color:DarkOrange;}
       .dead {color:Red;}
       .r {color:white;}
       </style>
       <div class="containerDiv"><table width="]]..ScrW..[[px" height="]]..ScrH..[[px"><tr><td>]]
       if (math.abs(CameraXDeg)>1 or math.abs(CameraYDeg)>1) then
        css[#css+1]=[[<svg width="]]..ScrW..[[px" height="]]..ScrH..[[px"><g class="linesHELM"><circle id="FWD" cx="]]..FWDx..[[" cy="]]..FWDy..[[" r="]]..10*ScRt..[[" fill-opacity="0"/>
        <line x1="]]..FWDx..[[" y1="]]..FWDy1..[[" x2="]]..FWDx..[[" y2="]]..FWDy2..[[" transform="rotate(45,]]..FWDx..[[,]]..FWDy..[[)"/>
        <line x1="]]..FWDx..[[" y1="]]..FWDy1..[[" x2="]]..FWDx..[[" y2="]]..FWDy2..[[" transform="rotate(135,]]..FWDx..[[,]]..FWDy..[[)"/>
        <line x1="]]..FWDx..[[" y1="]]..FWDy1..[[" x2="]]..FWDx..[[" y2="]]..FWDy2..[[" transform="rotate(225,]]..FWDx..[[,]]..FWDy..[[)"/>
        <line x1="]]..FWDx..[[" y1="]]..FWDy1..[[" x2="]]..FWDx..[[" y2="]]..FWDy2..[[" transform="rotate(315,]]..FWDx..[[,]]..FWDy..[[)"/></g></svg>]]
       end
       local HTML=table.concat(css)
       return HTML
      end

     --<DIV>
      local right_monitor_html=[[<div class="rh_m_div"><div class="window tbl"><table class="tbl">]]
      local left_monitor_html=[[<div class="lh_m_div"><div class="window tbl"><table class="tbl">]]
      local top_left_html=[[<div class="top_lh_div window tbl"><table class="left" width="]]..360*ScRt..[[vw">]]
      local top_right_html=[[<div class="top_rh_div window tbl"><table>]]

     --RIGHT MONITOR
      function monitor_right()
       local RH_HTML={}
       RH_HTML[#RH_HTML+1]=right_monitor_html..[[
       <tr height="]]..30*ScRt..[[vh" class="green"><th width="]]..40*ScRt..[[vw">Speed</th><td width="]]..ScRt..[[vw" rowspan="5"></td><th width="]]..40*ScRt..[[vw">Pitch</th><td width="]]..ScRt..[[vw" rowspan="2"></td><th width="]]..40*ScRt..[[vw">Roll</th><td width="]]..ScRt..[[vw" rowspan="5"></td><th class="green left" width="]]..70*ScRt..[[vw" colspan="2"><span class="yellow">]]..a_fuel_tank_n..[[</span>&nbspA F T</th><th class="green left" width="]]..70*ScRt..[[vw" colspan="2"><span class="yellow">]]..s_fuel_tank_n..[[</span>&nbspS F T</th><th class="green left" width="]]..70*ScRt..[[vw" colspan="2"><span class="yellow">]]..r_fuel_tank_n..[[</span>&nbspR F T</th></tr>
       <tr height="]]..30*ScRt..[[vh"><td>]]..speed_hud..[[</td><td>]]..pitch_hud..[[</td><td>]]..roll_direction..[[</td><td width="]]..30*ScRt..[[vw">]]..a_fuel_percent_avg_hud..[[</td><td width="]]..40*ScRt..[[vw">%</td><td width="]]..30*ScRt..[[vw">]]..s_fuel_percent_avg_hud..[[</td><td width="]]..40*ScRt..[[vw">%</td><td width="]]..30*ScRt..[[vw">]]..r_fuel_percent_avg_hud..[[</td><td width="]]..40*ScRt..[[vw">%</th></tr>
       <tr height="]]..30*ScRt..[[vh"><td class="cyan">]]..thr_hud..[[</td><td colspan="3">]]..radar_warning_hud..[[</td><td class="svg_box" rowspan="3">]]..a_fuel_svg()..[[</td><td>]]..M1(a_t_h)..[[</td><td class="svg_box" rowspan="3">]]..s_fuel_svg()..[[</td><td>]]..M1(s_t_h)..[[</td><td class="svg_box" rowspan="3">]]..r_fuel_svg()..[[</td><td>]]..M1(r_t_h)..[[</td></tr>
       <tr height="]]..30*ScRt..[[vh"><td class="svg_box" rowspan="2">]]..thr_svg()..[[</td><td class="green left" colspan="3">&nbspAlt&nbsp&nbsp<span class="yellow right">]]..altitude..[[</span>&nbsp</td><td>]]..M1(a_t_m)..[[</td><td>]]..M1(s_t_m)..[[</td><td>]]..M1(r_t_m)..[[</td></tr>
       <tr height="]]..30*ScRt..[[vh"><td class="green left" colspan="3">&nbspV/S&nbsp&nbsp<span class="yellow right">]]..vs_hud..[[</span>&nbsp</td><td>]]..M1(a_t_s)..[[</td><td>]]..M1(s_t_s)..[[</td><td>]]..M1(r_t_s)..[[</td></tr>
       </table></div></div>]]
       local HTML=table.concat(RH_HTML)
       return HTML
      end

     --OPTION 1 (Loading page)
      function monitor_left_loading()
       if warpdrive~=nil then warpdrive.hideWidget() end
       active_hud_mode="LOAD Mode"
       local gnd_alt=M1(unit.getSurfaceEngineAltitudeStabilization())
       local HUD_LOAD={}
       HUD_LOAD[#HUD_LOAD+1]=left_monitor_html..[[
        <tr height="]]..25*ScRt..[[vh"><td width="]]..ScRt..[[vw" rowspan="6"></td><td class="shield_st" colspan="3">Shield: ]]..shield_percent..[[</td><td width="]]..ScRt..[[vw" rowspan="6"></td><td class="tbl">LOAD</td><th class="tbl green" colspan="4" width="]]..180*ScRt..[[vw">LOAD&nbsp&nbspDOW:&nbsp&nbsp<span class="yellow">]]..dow_m..[[</span>&nbsp<span class="cyan">t</span></th></tr>
        <tr height="]]..25*ScRt..[[vh"><td width="]]..40*ScRt..[[vw" class="an_lgt" style="color:]]..ldg_st..[[">LDG</td><td width="]]..40*ScRt..[[vw" class="an_lgt" style="color:]]..ldg_st..[[">]]..gnd_alt..[[</td><td width="]]..40*ScRt..[[vw" class="an_lgt" style="color:]]..RktAct..[[">RKT</td><td width="]]..50*ScRt..[[vw" class="tbl cyan">AI</td><td class="left green">&nbspLOAD</td><td class="right">]]..cargo_m_t_hud..[[<span class="cyan">&nbspt&nbsp</span></td><td width="]]..10*ScRt..[[vw" rowspan="4"></td><td width="]]..30*ScRt..[[vw" class="px10 green">MTOW<br><span class="cyan">&nbsp]]..M1(MTOW/1000*10)/10 ..[[&nbspt</span></td></tr>
        <tr height="]]..25*ScRt..[[vh"><td class="an_lgt">]]..AFuelSpy..[[</td><td class="an_lgt">]]..SFuelSpy..[[</td><td class="an_lgt">]]..RFuelSpy..[[</td><td class="tbl cyan">SPC</td><td class="left green">&nbspZFW</td><td class="right">]]..zfw_m..[[<span class="cyan">&nbspt&nbsp</span></td><td>]]..MTOW_p..[[&nbsp%</td></tr>
        <tr height="]]..25*ScRt..[[vh"><td class="tbl ecam" rowspan="3" colspan="3">]]..ECAM()..[[</td><td class="tbl cyan">ORB</td><td class="left green">&nbspFuel</td><td class="right">]]..fuel_mass..[[<span class="cyan">&nbspt&nbsp</span></td><td class="svg_box" rowspan="2">]]..MTOW_svg()..[[</td></tr>
        <tr height="]]..25*ScRt..[[vh"><td class="tbl" style="color:]]..dmg_color..[[">DMG</td><td class="left green">&nbspGW</td><td class="right">]]..gw_m..[[<span class="cyan">&nbspt&nbsp</span></td></tr>
        <tr><td class="tbl" colspan="5"></td></tr>
       </table></div></div>]]
       local HTML=table.concat(HUD_LOAD)
       return HTML
      end

     --OPTION 2 (AI page)
      function monitor_left_atmo()
       if warpdrive~=nil then warpdrive.hideWidget() end
       active_hud_mode="AI Mode"
       local HUDDistance=""
       if db then ToWp=G1("navigator_target_destination") else ToWp="WP" end
       if (distance_to_wp=="n/a" or speed_hud<50) then time_to_wp_hud="n/a"
       else
        local ATA_h=tonumber(distance_to_wp)/speed_hud
        local ATA_m=(ATA_h-M1(ATA_h))*60
        local ATA_s=(ATA_m-M1(ATA_m))*60
        time_to_wp_hud=M1(ATA_h) ..":".. M1(ATA_m) ..":".. M1(ATA_s)
       end
       local gnd_alt=M1(unit.getSurfaceEngineAltitudeStabilization())

       if tonumber(distance_to_wp)~=nil then
        local Distance=tonumber(distance_to_wp)
        if Distance>200 then Distance=M1((Distance/200)*100)/100 ..[[</span> <span class="cyan">Su</span>]]
        else Distance=Distance  ..[[</span> <span class="cyan">Km</span>]] end
        HUDDistance=Distance
       else HUDDistance=distance_to_wp end

       local HUD_AI={}
       HUD_AI[#HUD_AI+1]=left_monitor_html..[[
        <tr height="]]..25*ScRt..[[vh"><td width="]]..ScRt..[[vw" rowspan="6"></td><td class="shield_st" colspan="3">Shield: ]]..shield_percent..[[</td><td width="]]..ScRt..[[vw" rowspan="6"></td><td class="tbl cyan">LOAD</td><td class="left lgt_green" width="]]..180*ScRt..[[vw"> &nbsp;Docking Mode:<span class="f_right yellow">]]..DockingMode..[[ &nbsp;</span></td></tr>
        <tr height="]]..25*ScRt..[[vh"><td width="]]..40*ScRt..[[vw" class="an_lgt" style="color:]]..ldg_st..[[">LDG</td><td width="]]..40*ScRt..[[vw" class="an_lgt" style="color:]]..ldg_st..[[">]]..gnd_alt..[[</td><td width="]]..40*ScRt..[[vw" class="an_lgt" style="color:]]..RktAct..[[">RKT</td><td width="]]..50*ScRt..[[vw" class="tbl">AI</td><td>]]..ConstructDocked..[[</td></tr>
        <tr height="]]..25*ScRt..[[vh"><td class="an_lgt">]]..AFuelSpy..[[</td><td class="an_lgt">]]..SFuelSpy..[[</td><td class="an_lgt">]]..RFuelSpy..[[</td><td class="tbl cyan">SPC</td><td></td></tr>
        <tr height="]]..25*ScRt..[[vh"><td class="tbl ecam" rowspan="3" colspan="3">]]..ECAM()..[[</td><td class="tbl cyan">ORB</td><td class="left"> &nbsp;<span class="lgt_green">DOCKED: &nbsp;</span>]]..DockedConstructs..[[<span class="f_right lgt_green">Mass: &nbsp;<span class="yellow">]]..DockedMass..[[ &nbsp;<span class="cyan">t &nbsp;</span></span></span></td></tr>
        <tr height="]]..25*ScRt..[[vh"><td class="tbl" style="color:]]..dmg_color..[[">DMG</td><td class="left"> &nbsp;<span class="lgt_green">CREW+PAX: &nbsp;</span>]]..PaxOnBoard..[[<span class="f_right lgt_green">Mass: &nbsp;<span class="yellow">]]..PaxOnBoardMass..[[ &nbsp;<span class="cyan">t &nbsp;</span></span></span></td></tr>
        <tr><td class="tbl" colspan="5"></td></tr>
       </table></div></div>]]
       local HTML=table.concat(HUD_AI)
       return HTML
      end

     --OPTION 3 (Space page)
      function monitor_left_space()
       active_hud_mode,final_speed_brk="SPC Mode",0
       if warpdrive then
        warp_data=json.decode(warpdrive.getWidgetData())
        warp_cells_hud=warp_data.cellCount
        local ws=warp_data.statusText
        if (warp_data.destination~=Unknown and warp_data.destination~=navigator_target_destination_hud) then
         warp_destination=[[<br><span class="green">Warp to: </span>]]..warp_data.destination..[[&nbsp<span class="red">]]..ws..[[</span>]]
         destination_hud_spc=[[</span>&nbspTo:&nbsp<span class="cyan">]]..navigator_target_destination_hud..[[&nbsp]]..warp_destination..[[</span>]]
        elseif (warp_data.destination~=Unknown and warp_data.destination==navigator_target_destination_hud) then
         destination_hud_spc=[[</span>&nbspWarp To:&nbsp<span class="cyan">]]..warp_data.destination..[[</span><br><span class="red">]]..ws..[[</span>]]
        end
        if (ws~="NO WARP CONTAINER" and ws~="NO DESTINATION" and ws~="PLANET TOO CLOSE" and ws~="NOT SEATED") then warpdrive.showWidget() else warpdrive.hideWidget() end
       else
        warp_cells_hud="n/a"
        destination_hud_spc=[[</span>&nbspTo:&nbsp<span class="cyan">]]..navigator_target_destination_hud..[[</span>]]
       end
       local gnd_alt,SZ=M1(unit.getSurfaceEngineAltitudeStabilization()),""
       local SafeDist=SZone()
       if math.abs(SafeDist)>200 then SZ=S1("%.2f",math.abs(SafeDist/200)) ..[[ <span class="cyan">Su</span>]] else SZ=math.abs(SafeDist) ..[[ <span class="cyan">Km</span>]] end
       if SafeDist>0 then SZ=[[<span class="red">]]..SZ..[[</span>]] end
       speedMS=M1(speed_hud/3.6)
       rrThrust_hud=S1("%.0f",MaxBrake())

       local HUD_SPC={}
       HUD_SPC[#HUD_SPC+1]=top_left_html..[[
        <tr height="]]..30*ScRt..[[vh" class="px16"><td width="]]..ScRt..[[vw" rowspan="5"></td><td class="green left" colspan="3">From:&nbsp<span class="cyan">]]..navigator_from_hud..[[&nbsp]]..destination_hud_spc..[[</td></tr>
        <tr height="]]..30*ScRt..[[vh"><th class="green">Dist.</th><td>]]..navigator_distance_hud..[[<span class="cyan">&nbspSu</span></td><td colspan="2" rowspan="4" width="]]..180*ScRt..[[vw" height="]]..120*ScRt..[[vh">]]..space_orientation_svg()..[[</td></tr>
        <tr height="]]..30*ScRt..[[vh"><th class="green">Speed:</th><td>]]..navigator_speed_hud..[[<span class="cyan">&nbspKm/h</span></td></tr>
        <tr height="]]..30*ScRt..[[vh"><th class="green">Time:</th><td>]]..navigator_eta_hud..[[</td></tr>
        <tr height="]]..30*ScRt..[[vh"><th class="green">Warp C.</th><td>]]..warp_cells_hud..[[</td></tr>
       </table></div>
       ]]..top_right_html..[[
        <tr height="]]..150*ScRt..[[vh"><td width="]]..360*ScRt..[[vw">]]..interplanet_svg()..[[<td></tr>
        <tr><td>&nbspAuto Brake in:&nbsp<span class="white">]]..autobrake_in..[[</span>&nbsp<span class="cyan">Su</span>-<span class="white">]]..BrkStop..[[</span>&nbsp<span class="cyan">Su</span>&nbspFrom Dest.</td></tr>
       </table></div>
       ]]..left_monitor_html..[[
        <tr height="]]..25*ScRt..[[vh"><td width="]]..ScRt..[[vw" rowspan="6"></td><td class="shield_st" colspan="3">Shield: ]]..shield_percent..[[</td><td width="]]..ScRt..[[vw" rowspan="6"></td><td class="tbl cyan">LOAD</td><th class="tbl green" colspan="2" width="]]..180*ScRt..[[vw">Safe Zone Border <span class="f_right yellow">]].. SZ ..[[</span></th></tr>
        <tr height="]]..25*ScRt..[[vh"><td width="]]..40*ScRt..[[vw" class="an_lgt" style="color:]]..ldg_st..[[">LDG</td><td width="]]..40*ScRt..[[vw" class="an_lgt" style="color:]]..ldg_st..[[">]]..gnd_alt..[[</td><td width="]]..40*ScRt..[[vw" class="an_lgt" style="color:]]..RktAct..[[">RKT</td><td width="]]..50*ScRt..[[vw" class="tbl cyan">AI</td><td class="green">Braking</td><td>]]..rrThrust_hud..[[<span class="cyan">&nbspkN</span></td></tr>
        <tr height="]]..25*ScRt..[[vh"><td class="an_lgt">]]..AFuelSpy..[[</td><td class="an_lgt">]]..SFuelSpy..[[</td><td class="an_lgt">]]..RFuelSpy..[[</td><td class="tbl">SPC</td><td class="green">Stop in:</td><td>]]..brake_su..[[<span class="cyan">&nbspSu</span></td></tr>
        <tr height="]]..25*ScRt..[[vh"><td class="tbl ecam" rowspan="3" colspan="3">]]..ECAM()..[[</td><td class="tbl cyan">ORB</td><td class="green">Max Speed:</td><td>]]..brake_km..[[<span class="cyan">&nbspKm</span></td></tr>
        <tr height="]]..25*ScRt..[[vh"><td td class="tbl" style="color:]]..dmg_color..[[">DMG</td><td>]]..M1(MaxSpeed())..[[<span class="cyan">&nbspKm/h</span></td><td>]]..brake_min..[[<span class="cyan">'&nbsp</span>]]..brake_sec..[[<span class="cyan">"</span></td></tr>
        <tr><td class="tbl" colspan="3"></td></tr>
       </table></div></div>]]
       local HTML=table.concat(HUD_SPC)
       return HTML
      end

     --OPTION 4 (Orbit page)
      function monitor_left_orbit()
       if warpdrive~=nil then warpdrive.hideWidget() end
       active_hud_mode,final_speed_brk="ORB Mode",(orbit_circular_speed)/1000*60*60
       local gnd_alt=M1(unit.getSurfaceEngineAltitudeStabilization())
       local AtmoAltitude=M1(planet_Atmo_alt-planet_radius)
       if AtmoAltitude<=0 then AtmoAltitude=0 end
       local PEAltColor="yellow"
       if PeAlt<=AtmoAltitude then PEAltColor="red" else PEAltColor="yellow" end
       local APAltColor="yellow"
       if ApAlt<=AtmoAltitude then APAltColor="red" else APAltColor="yellow" end
       speedMS=M1(speed_hud/3.6)
       local PeSpeedHud=PeSpeed
       if PeSpeedHud>(MaxSpeed()*1000/3600) then PeSpeedHud="Too High" end

       local HUD_ORB={}
       HUD_ORB[#HUD_ORB+1]=top_left_html..[[
        <tr height="]]..30*ScRt..[[vh" class="px16"><td width="]]..ScRt..[[vw" rowspan="6"></td><th width="]]..360*ScRt..[[vw" colspan="4" class="green">ORBIT&nbsp&nbsp<span class="cyan">]]..planet_name..[[&nbsp&nbsp</span><span class="yellow">]]..M1(my_planet_alt/1000/200*100)/100 ..[[</span><span class="cyan">&nbsp&nbspSu</span></th></tr>
        <tr height="]]..30*ScRt..[[vh"><td class="green">Atmosphere Altitude</td><td>]]..AtmoAltitude..[[&nbsp<span class="cyan">m</span></td><td></td><td></td></tr>
        <tr height="]]..30*ScRt..[[vh"><td class="green">ECC</td><td>]]..S1("%.4f",orbit_ecc)..[[</td><td class="green">T</td><td>]]..orbit_period..[[</td></tr>
        <tr height="]]..30*ScRt..[[vh"><td class="green">PE Alt</td><td class="]]..PEAltColor..[[">]]..PeAlt..[[&nbsp<span class="cyan">m</span></td><td class="green">AP Alt</td><td class="]]..APAltColor..[[">]]..ApAlt..[[&nbsp<span class="cyan">m</span></td></tr>
        <tr height="]]..30*ScRt..[[vh"><td class="green">PE Speed</td><td>]]..PeSpeedHud..[[&nbsp<span class="cyan">m/s</span></td><td class="green">AP Speed</td><td>]]..ApSpeed..[[&nbsp<span class="cyan">m/s</span></td></tr>
        <tr height="]]..30*ScRt..[[vh"><td class="green">T to PE</td><td>]]..TPe..[[</td><td class="green">T to AP</td><td>]]..TAp..[[</td></tr>
       </table></div>
       ]]..top_right_html..[[
        <tr height="]]..150*ScRt..[[vh"><td width="]]..360*ScRt..[[vw">]]..f_orbit_svg()..[[<td></tr>
        <tr><td class="left">&nbspTarget PE Altitude&nbsp<span class="white">]]..PeTargetAlt..[[</span>&nbsp<span class="cyan">m</span>
        <span class="f_right">Atmosphere Altitude<span class="white"> ]]..AtmoAltitude..[[</span>&nbsp<span class="cyan">m</span></td></tr>
       </table></div>
       ]]..left_monitor_html..[[
        <tr height="]]..25*ScRt..[[vh"><td width="]]..ScRt..[[vw" rowspan="6"></td><td class="shield_st" colspan="3">Shield: ]]..shield_percent..[[</td><td width="]]..ScRt..[[vw" rowspan="6"></td><td class="tbl cyan">LOAD</td><th class="tbl green" colspan="2" width="]]..180*ScRt..[[vw">Orbit&nbsp&nbsp<span class="yellow">]]..speedMS..[[</span><span class="cyan">&nbspm/s</span></tr>
        <tr height="]]..25*ScRt..[[vh"><td width="]]..40*ScRt..[[vw" class="an_lgt" style="color:]]..ldg_st..[[">LDG</td><td width="]]..40*ScRt..[[vw" class="an_lgt" style="color:]]..ldg_st..[[">]]..gnd_alt..[[</td><td width="]]..40*ScRt..[[vw" class="an_lgt" style="color:]]..RktAct..[[">RKT</td><td width="]]..50*ScRt..[[vw" class="tbl cyan">AI</td><td class="green">Brake at:</td><td>]]..brake_km..[[&nbsp<span class="cyan">Km</span></td></tr>
        <tr height="]]..25*ScRt..[[vh"><td class="an_lgt">]]..AFuelSpy..[[</td><td class="an_lgt">]]..SFuelSpy..[[</td><td class="an_lgt">]]..RFuelSpy..[[</td><td class="tbl cyan">SPC</td><td colspan="2" rowspan="3"  width="]]..180*ScRt..[[vw" height="]]..75*ScRt..[[vh">]] .. space_orientation_svg() .. [[</td></tr>
        <tr height="]]..25*ScRt..[[vh"><td class="tbl ecam" rowspan="3" colspan="3">]]..ECAM()..[[</td><td class="tbl">ORB</td></tr>
        <tr height="]]..25*ScRt..[[vh"><td td class="tbl" style="color:]]..dmg_color..[[">DMG</td></tr>
        <tr><td class="tbl" colspan="3"></td></tr>
       </table></div></div>]]
       local HTML=table.concat(HUD_ORB)
       return HTML
      end

     --OPTION 5 (Damage page)
      function monitor_left_damage()
       if warpdrive~=nil then warpdrive.hideWidget() end
       active_hud_mode="DMG Mode"
       dmgrep=DmgMdl.new()
       damage_html=dmgrep:renderHTML()
       local dmg_table_html=dead_elem_list_hud..high_damage_list_hud..medium_damage_list_hud..light_damage_list_hud
       local gnd_alt=M1(unit.getSurfaceEngineAltitudeStabilization())

       local HUD_DMG={}
       HUD_DMG[#HUD_DMG+1]=top_left_html..[[
        <tr height="]]..150*ScRt..[[vh"><td class="txcx" width="]]..360*ScRt..[[vw">TOP VIEW<hr>]]..top_view_html_hud..[[</td></tr>
       </table></div>
       ]]..top_right_html..[[
        <tr height="]]..150*ScRt..[[vh"><td width="]]..360*ScRt..[[vw">SIDE VIEW<hr>]]..side_view_html_hud..[[</td></tr>
       </table></div>
       ]]..left_monitor_html..[[
        <tr height="]]..25*ScRt..[[vh"><td width="]]..ScRt..[[vw" rowspan="6"></td><td class="shield_st" colspan="3">Shield: ]]..shield_percent..[[</td><td width="]]..ScRt..[[vw" rowspan="6"></td><td class="tbl cyan">LOAD</td><td width="]]..180*ScRt..[[vw" class="tbl tomato">Damages Report</td></tr>
        <tr height="]]..25*ScRt..[[vh"><td width="]]..40*ScRt..[[vw" class="an_lgt" style="color:]]..ldg_st..[[">LDG</td><td width="]]..40*ScRt..[[vw" class="an_lgt" style="color:]]..ldg_st..[[">]]..gnd_alt..[[</td><td width="]]..40*ScRt..[[vw" class="an_lgt" style="color:]]..RktAct..[[">RKT</td><td width="]]..50*ScRt..[[vw" class="tbl cyan">AI</td><td rowspan="4" height="]]..75*ScRt..[[vh" class="top left">]]..dmg_table_html..[[</td></tr>
        <tr height="]]..25*ScRt..[[vh"><td class="an_lgt">]]..AFuelSpy..[[</td><td class="an_lgt">]]..SFuelSpy..[[</td><td class="an_lgt">]]..RFuelSpy..[[</td><td class="tbl cyan">SPC</td></tr>
        <tr height="]]..25*ScRt..[[vh"><td class="tbl ecam" rowspan="3" colspan="3">]]..ECAM()..[[</td><td class="tbl cyan">ORB</td></tr>
        <tr height="]]..25*ScRt..[[vh"><td td class="tbl">DMG</td></tr>
        <tr><td class="tbl" colspan="2"></td></tr>
       </table></div></div>]]
       local HTML=table.concat(HUD_DMG)
       return HTML
      end

    --HTML ASSEMBLER
     function html_assemble(x)
      left_panel=x
      right_panel=html_style()..monitor_right()
      hud=right_panel
      hud=hud..left_panel
      if atmo_pg then S.setScreen(hud..[[</td></tr></table></div>]]..art_h_svg()) elseif (space_pg or orbit_pg) then S.setScreen(hud..[[</td></tr></table></div>]]..spc_hud()) else S.setScreen(hud..[[</td></tr></table></div>]]) end
      S.showScreen(1)
     end

     air_data()

    --TIMER
     unit.setTimer("CommonFunctions",1/30)
     unit.setTimer("LoadPg",1/30)
     unit.setTimer("thrust",1/30)
     unit.setTimer("Camera",1/30)
  onTimer:
   args: [Camera]
   lua: |
    if (not player.isSeated() or Fix_Panels) then unit.stopTimer("Camera") elseif S.isFirstPerson() then
     local k=1.054
     local upRef,rhRef,fwd=vec3(0,0,1)/k,vec3(1,0,0)/k,vec3(S.getCameraForward())/k
     CameraYDeg=(fwd:dot(rhRef))*100
     CameraXDeg=(fwd:dot(upRef))*100
     CameraYDeg=CameraYDeg-CameraYDeg/6
     CameraXDeg=CameraXDeg-CameraXDeg/6
    elseif not S.isFirstPerson() then CameraYDeg,CameraXDeg=0,0 end
  onTimer:
   args: [CommonFunctions]
   lua: |
    if atmofueltank_size~=0 then atmo_fuel_percent() a_fuel_minimum_time() end
    if spacefueltank_size~=0 then space_fuel_percent() s_fuel_minimum_time() end
    if rocketfueltank_size~=0 then rocket_fuel_percent() r_fuel_minimum_time() r_warning_light() end
    avg_fuel_percentage()
    Docking()
    RadioAndGear()
    if DMG_Report then dmg_checker() end
    if radar_1 then radar_contacts() end
    if shield then shield_function() end
  onTimer:
   args: [LoadPg]
   lua: |
    f_loading_data()
    gw_m=ConstructMass()+DockedMass
    zfw_m=gw_m-fuel_mass
    dow_m=gw_m-fuel_mass-cargo_m_t-DockedMass
    MTOW_p=M1(gw_m*1000/MTOW*100)
    total_fuel_mass()

    html_assemble(monitor_left_loading())
  onTimer:
   args: [atmo_pg]
   lua: |
    distance_to_wp_ai()
    space_orientation()

    if (altitude_hold and auto_wp) then
     local wp=G1("navigator_target_destination")
     local ext=G1("wp_settings"):gsub("@@@","\"")
     ext=json.decode(ext)
     if (ext[wp] and air_density()>1) then local alt=ext[wp].alt
      if alt~="" then TargetAltitude=tonumber(alt) end
      local speed=ext[wp].s
      if db.getIntValue("Holding")==1 then local h_speed=db.getIntValue("holding_speed")
       if tonumber(h_speed)~=0 then speed=h_speed end
      end
      if (speed~="" and unit.getControlMode()==1) then local thr=M1(unit.getThrottle()) thr=M1(thr/100)
       if thr<tonumber(speed) then Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal,1.0) elseif thr>tonumber(speed) then Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal,-1.0) end
      end
     end
    end

    html_assemble(monitor_left_atmo())
  onTimer:
   args: [orbit_pg]
   lua: |
    distance_to_wp_ai()
    braking_distance(final_speed_brk)
    orbital_data()
    space_orientation()
    databank_condition()

    g_hud=M1(((core.getGravityIntensity())/10)*10)/10
    if (prograde_mode and not deorbit_mode and (altitude>0 and altitude<=planet_Atmo_alt+20000) and unit.getAtmosphereDensity()==0 and speed_hud>(110*DUatlas[0][planet_id].gravity) and vs_hud>-100 and DUatlas[0][planet_id].hasAtmosphere) then DeorbitPossible=true else DeorbitPossible=false end
    if DeorbitPossible then
     local Spd=110*DUatlas[0][planet_id].gravity
     local PitchUp=speed_hud*0.33/60
     braking_distance(Spd)
     local Dec=brake_km
     local Des=(altitude/360000*Spd)
     DeorbDist=M1(PitchUp+Dec+Des)
    end

    html_assemble(monitor_left_orbit())
  onTimer:
   args: [space_pg]
   lua: |
    distance_to_wp_ai()
    orbital_data()
    braking_distance(final_speed_brk)
    if DbInit=="Verified" then
     if G3("navigator_autobrake")~=nil then BrkStop=G3("navigator_autobrake") else BrkStop=Autobrake_Stop_Distance end
    else BrkStop=Autobrake_Stop_Distance end
    space_orientation()
    databank_condition()

    g_hud=M1(((core.getGravityIntensity())/10)*10)/10

    html_assemble(monitor_left_space())
  onTimer:
   args: [damage_pg]
   lua: html_assemble(monitor_left_damage())
  onTimer:
   args: [autobrake]
   lua: autobrake_function()
  onTimer:
   args: [maintaning_orbit]
   lua: maintaining_orbit()
  onTimer:
   args: [PeDist]
   lua: New_pe_dis=pe_dis
  onTimer:
   args: [delay3sec]
   lua: |
    --3 SECONDS DELAY
     if autopilot_ecam_mode==[[<span class="tomato">Adjust Attitude</span><br><span class="cyan">Max Bank 45<br>Max Pitch +25 -15</span><br>]] then autopilot_ecam_mode=[[]] unit.stopTimer("delay3sec") end
     if (autopilot_ecam_mode==[[Autopilot ON-M2]]) then orbiting_mode_delay() elseif (autopilot_ecam_mode==[[Autopilot ON-M3]]) then destination_mode_delayed() end
  onTimer:
   args: [countdown]
   lua: |
    --3 SECONDS COUNTDOWN
     if (autopilot_ecam_mode==[[Autopilot ON-M2]]) then time_to_align=time_to_align-1 adjusting_mode=[[Mainteining Orbit in: ]] .. time_to_align
     elseif (autopilot_ecam_mode==[[Autopilot ON-M3]]) then time_to_align=time_to_align-1 adjusting_mode=[[Align to DEST in: ]] .. time_to_align end
  onTimer:
   args: [antigravity]
   lua: |
    --ANTIGRAVITY
     agg_b_alt=antigrav.getBaseAltitude()
     db.setIntValue("agg_b_alt",agg_b_alt)
     local new_alt=db.getIntValue("agg_t_alt")
     if new_alt~=antigrav_target_alt then antigrav_target_alt=new_alt antigrav.setBaseAltitude(antigrav_target_alt) end
     local state=antigrav.isActive()
     if state then G2("agg eng/stby","ENG") G2("agg off/stby","ACTIVE") agg_ecam_mode=[[AGG ON]]
     else G2("agg eng/stby","STBY") G2("agg off/stby","STBY") agg_ecam_mode=[[<span class="cyan">AGG ARM</span>]] end
  onTimer:
   args: [antigravity_op]
   lua: |
    --ANTIGRAVITY OPERATION
     if G1("nav agg")~=navi_agg_op then navi_agg_op=G1("nav agg")
      if navi_agg_op=="OFF" then unit.stopTimer("antigravity",1)
       G2("agg eng/stby","STBY") G2("agg off/stby","OFF")
       antigrav.hideWidget() antigrav.deactivate()
       atigrav_widget,AgArm,agg_ecam_mode=false,false,[[]]
      elseif navi_agg_op=="STBY" then antigrav.showWidget() antigrav.deactivate()
       atigrav_widget,AgArm,agg_ecam_mode=true,true,[[<span class="cyan">AGG ARM</span>]]
       G2("agg eng/stby","STBY") G2("agg off/stby","STBY")
       unit.setTimer("antigravity",1)
      elseif navi_agg_op=="ENG" then
       unit.stopTimer("delay3sec") unit.stopTimer("countdown") unit.stopTimer("maintaning_orbit") unit.stopTimer("PeDist")
       auto_aligner,prograde_mode,destination_mode,altitude_hold,align_active_mode,adjusting_mode,autopilot_ecam_mode,AltHoldColor,agg_ecam_mode=false,false,false,false,[[]],[[]],[[]],"none",[[AGG ON]]
       antigrav.activate()
      end
    end
  onTimer:
   args: [PVPupdate]
   lua: |
    if radar_1.getOperationalState() then
     FleetListFunction()
     TargetListFunction()
     Target()
     if weaponlinked then wepdat() end
    else
     S.destroyWidgetPanel(radarPanel)
     _autoconf.hideCategoryPanels()
     unit.setTimer("CheckRadarOp",1) unit.stopTimer("PVPupdate") unit.stopTimer("PVPsender")
     RDRMaxRange,TargetList,TargetTotal,TargetInfo,ThreatList,AbandonedList=0,{},0,{},{},{} 
     SendingData()
    end
  onTimer:
   args: [PVPsender]
   lua: |
    local isIdentified=radar_1.getIdentifiedConstructIds()
    if #isIdentified>0 then TargetInfoFunction() else TargetInfo={} end
    if (db and radar_1.getOperationalState()) then SendingData() end
  onTimer:
   args: [CheckRadarOp]
   lua: if radar_1.getOperationalState() then unit.stopTimer("CheckRadarOp") PvP() end
  onTimer:
   args: [thrust]
   lua: |
    if not Thrust_Lever then unit.stopTimer("thrust")
    elseif (not ThrRev and (controller.getThrottleInput()*100)~=unit.getThrottle()) then Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal,controller.getThrottleInput()) thrust_setting()
    elseif ( ThrRev and (controller.getThrottleInput()*100)~=unit.getThrottle()) then Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal,-controller.getThrottleInput()) thrust_setting()
    end
  onStop:
   lua: |
    _autoconf.hideCategoryPanels()
    if antigrav~=nil then antigrav.hideWidget() end
    if warpdrive~=nil then warpdrive.hideWidget() end
    if shield~=nil then shield.hideWidget() end
    if gyro~=nil then gyro.hideWidget() end
    core.hideWidget()
    unit.switchOffHeadlights()
    if gyro then gyro.deactivate() end
    if db then
     if UnitIsCockpit then G2("PVPCockpit","OFF")
     elseif (UnitIsSeat and UnitType~="RemoteControlUnit") then G2("PVPGunner","OFF") end
     if UnitType~="RemoteControlUnit" then G2("PVPStationData","") end
    end
    S.showScreen(0)
 system:
  onFlush:
   lua: |
    --constants
    local pitchSpeedFactor,yawSpeedFactor,rollSpeedFactor,brakeSpeedFactor,brakeFlatFactor,autoRoll,autoRollFactor,turnAssist,turnAssistFactor,torqueFactor=0.8,1,1.5,3,1,autoRoll_activated,2,true,2,2
    --validate params
    pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)
    yawSpeedFactor=math.max(yawSpeedFactor,0.01)
    rollSpeedFactor=math.max(rollSpeedFactor,0.01)
    torqueFactor=math.max(torqueFactor,0.01)
    brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)
    brakeFlatFactor=math.max(brakeFlatFactor,0.01)
    autoRollFactor=math.max(autoRollFactor,0.01)
    turnAssistFactor=math.max(turnAssistFactor,0.01)
    --final inputs
    local finalPitchInput=pitchInput+S.getControlDeviceForwardInput()+controller.getPitchInput()
    local finalRollInput=rollInput+S.getControlDeviceYawInput()+controller.getRollInput()
    local finalYawInput=yawInput-S.getControlDeviceLeftRightInput()+controller.getYawInput()
    local finalBrakeInput=brakeInput
    --Axis
    local worldVertical=0
    if antigrav then
     if antigrav.isActive() then worldVertical=vec3(core.getWorldVertical()) else worldVertical=vec3(core.getWorldGravity()) end
    else worldVertical=vec3(core.getWorldGravity()) end
    local constructUp=Up()
    local constructForward=Forward()
    local constructRight=Right()
    local constructVelocity=ConstructVel()
    local constructVelocityDir=ConstructVel():normalize()
    local currentRollDeg=getRoll(worldVertical,constructForward,constructRight)
    local currentRollDegAbs=math.abs(currentRollDeg)
    local currentRollDegSign=utils.sign(currentRollDeg)
    --Rotation
    local constructAngularVelocity=AngVelocity()

    --ALTITUDE HOLD
    if altitude_hold then
     altitude_hold_function()

     local maxBurn=MaxBurnSpeed()-10
     if (speed_hud>maxBurn-100 and unit.getControlMode()==0) then cruise_speed_f(maxBurn) tgtSpeed=M1(maxBurn) else CruiseSpeed=false end

     local LimitPitchDeg=getRoll(worldVertical,constructRight,-constructForward)
     local currentPitchDeg=math.max(math.min(getRoll(worldVertical,constructRight,-constructForward)/60,1),-1)
     local heightDiff=math.max(math.min((TargetAltitude-altitude-fpa_hud)/500,1),-1)
     local heightDiff=utils.smoothstep(heightDiff,-1,1)- 0.5
     finalPitchInput=(heightDiff-currentPitchDeg)-(vs_hud*3.6/2500)

     if (LimitPitchDeg>25 or pitch_bird_hud>10) then finalPitchInput=math.min(finalPitchInput,0) end
     if LimitPitchDeg<-15 then finalPitchInput=math.max(finalPitchInput,0) end

     if currentRollDeg>45 then finalRollInput=-1 elseif currentRollDeg<-45 then finalRollInput=1 end

     local roll_dead_zone=3
     if auto_wp then roll_dead_zone=0 end
     if (currentRollDeg>roll_dead_zone and math.abs(yaw_bird_hud)<8) then finalYawInput=-0.002*currentRollDeg
     elseif (currentRollDeg<-roll_dead_zone and math.abs(yaw_bird_hud)<8) then finalYawInput=-0.002*currentRollDeg end
    else CruiseSpeed=false end

    --DEORBITING
    if DeorbFlight==nil then DeorbFlight=false end
    if EMERdisc==nil then EMERdisc=false end
    if (deorbit_mode and (autopilot_ecam_mode==[[DEORBITING]] or DeorbFlight)) then
     if DeorbRoll==nil then DeorbRoll=false end if DeorbYaw==nil then DeorbYaw=false end if DeorbPitch==nil then DeorbPitch=false end

     if ((roll_hud>0 or roll_hud<0) and not DeorbRoll and not DeorbFlight) then finalRollInput=-0.003*roll_hud end
     if math.abs(roll_hud)<=1 then DeorbRoll=true end

     if ((yaw_bird_hud>0 or yaw_bird_hud<0) and DeorbRoll and not DeorbYaw and not DeorbFlight) then finalYawInput=-0.003*yaw_bird_hud end
     if (math.abs(yaw_bird_hud)<=1 and DeorbRoll) then DeorbYaw=true end

     if ((pitch_hud<70 or pitch_hud>70) and DeorbRoll and DeorbYaw and not DeorbFlight) then finalPitchInput=0.003*(70-pitch_hud) end
     if (pitch_hud>=70 and pitch_hud<=75) then DeorbPitch=true end

     if (DeorbRoll and DeorbYaw and DeorbPitch and not DeorbFlight) then
      CruiseSpeed,tgtSpeed=true,M1(110*DUatlas[0][planet_id].gravity)
      if speed_hud>tgtSpeed then brakeInput=1 else brakeInput=0 end
      if vs_hud<-90 then
       if thrPID==nil then thrPID=pid.new(0.5,0,1) end
       thrPID:inject(math.abs(vs_hud)-90)
       ThrPIDGet=thrPID:get()
       if ThrPIDGet<=0 then ThrPIDGet=0 elseif ThrPIDGet>0 then ThrPIDGet=ThrPIDGet/10 end
       newThrottle=utils.clamp(ThrPIDGet,0,1)
       if newThrottle<ThrPIDGet then Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal,utils.clamp(newThrottle,0.01,1))
       else Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal,ThrPIDGet) end
      end
     end

     local maxBurn=MaxBurnSpeed()
     if (air_density()>0 and not EMERdisc) then
      if speed_hud>maxBurn then Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal) brakeInput=1 end
      if speed_hud<=maxBurn then brakeInput=0 end
      if speed_hud<(maxBurn-50) then Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal,100) end
      if air_density()<3 then TargetAltitude=core.getAltitude()-500 end
      DeorbFlight,altitude_hold=true,true
      if vs_hud>=0 then TargetAltitude=core.getAltitude() deorbit_mode,DeorbFlight,brakeInput,CruiseSpeed=false,false,0,false end
      AltHoldColor="lightgreen"
      if (unit.getControlMode()==0 and not deorbit_mode) then unit.cancelCurrentControlMasterMode() end
      if db then if G1("databank_verification")=="Verified" then NavDatabank=true end end
     end
    end

    --DU CODE
    local targetAngularVelocity=finalPitchInput*pitchSpeedFactor*constructRight+finalRollInput*rollSpeedFactor*constructForward+finalYawInput*yawSpeedFactor*constructUp

    local atmo=unit.getAtmosphereDensity()
    if (worldVertical:len()>0.01 and atmo>0.0) then in_atmosphere=true else in_atmosphere=false end
    if radio_alt_1 then
     local g=core.getGravityIntensity()/10
     local ra=tonumber(radio_alt_value)
     if (ra~=nil and ra<=10 and ra>=0 and atmo<=0.0 and g>0.01) then in_space=true else in_space=false end
    end

    if (in_atmosphere or in_space) then
     local autoRollRollThreshold=1.0
     if autoRoll and currentRollDegAbs>autoRollRollThreshold and finalRollInput==0 then
      local targetRollDeg=utils.clamp(0,currentRollDegAbs-30,currentRollDegAbs+30);
      if (rollPID==nil) then rollPID=pid.new(autoRollFactor*0.01,0,autoRollFactor*0.1) end
      rollPID:inject(targetRollDeg-currentRollDeg)
      local autoRollInput=rollPID:get()
      targetAngularVelocity=targetAngularVelocity+autoRollInput*constructForward
     end
    end

    --In atmosphere
    if in_atmosphere then
     --AUTOPILOT
     if auto_wp then
      autopilot_wp()
      if yaw_WP_hud~=0 then
       if yaw_WP_hud>=180 then delta=(360-yaw_WP_hud) elseif yaw_WP_hud<180 then delta=-yaw_WP_hud end
       local final_roll=math.min(30,math.abs(delta))
       if yaw_WP_hud<180 then final_roll=-final_roll end
       local targetRollDeg=utils.clamp(0,final_roll,final_roll);
       if (rollPID==nil) then rollPID=pid.new(autoRollFactor*0.01,0,autoRollFactor*0.1) end
       rollPID:inject(targetRollDeg-currentRollDeg)
       local autoRollInput=rollPID:get()
       targetAngularVelocity=targetAngularVelocity+autoRollInput*constructForward+finalYawInput*yawSpeedFactor*constructUp
      end
     end

     local turnAssistRollThreshold=20.0
     if turnAssist and currentRollDegAbs>turnAssistRollThreshold and finalPitchInput==0 and finalYawInput==0 then
      local rollToPitchFactor=turnAssistFactor*0.1
      local rollToYawFactor=turnAssistFactor*0.025

      local rescaleRollDegAbs=((currentRollDegAbs-turnAssistRollThreshold)/(180-turnAssistRollThreshold))*180
      local rollVerticalRatio=0
      if rescaleRollDegAbs<90 then rollVerticalRatio=rescaleRollDegAbs/90
      elseif rescaleRollDegAbs<180 then rollVerticalRatio=(180-rescaleRollDegAbs)/90 end
      rollVerticalRatio=rollVerticalRatio*rollVerticalRatio
      local turnAssistYawInput=- currentRollDegSign*rollToYawFactor*(1.0-rollVerticalRatio)
      local turnAssistPitchInput=rollToPitchFactor*rollVerticalRatio
      targetAngularVelocity=targetAngularVelocity+turnAssistPitchInput*constructRight+turnAssistYawInput*constructUp
     end
    end

    --Engine commands
    local keepCollinearity,dontKeepCollinearity,tolerancePercentToSkipOtherPriorities=1,0,1

    --Rotation
    local angularAcceleration=torqueFactor*(targetAngularVelocity-constructAngularVelocity)
    local airAcceleration=AirFriction()
    angularAcceleration=angularAcceleration-airAcceleration
    Nav:setEngineTorqueCommand('torque',angularAcceleration,keepCollinearity,'airfoil','','',tolerancePercentToSkipOtherPriorities)

    --Brakes
    local brakeAcceleration=-finalBrakeInput*(brakeSpeedFactor*constructVelocity+brakeFlatFactor*constructVelocityDir)
    Nav:setEngineForceCommand('brake',brakeAcceleration)

    --AutoNavigation regroups all the axis command by 'TargetSpeed'
    local autoNavigationEngineTags=''
    local autoNavigationAcceleration=vec3()
    local autoNavigationUseBrake=false

    --Longitudinal Translation
    local longitudinalEngineTags='thrust analog longitudinal'
    local longitudinalCommandType=Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
    if (longitudinalCommandType==axisCommandType.byThrottle) then
     local longitudinalAcceleration=Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
     Nav:setEngineForceCommand(longitudinalEngineTags,longitudinalAcceleration,keepCollinearity)
    elseif  (longitudinalCommandType==axisCommandType.byTargetSpeed) then
     local longitudinalAcceleration=Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
     autoNavigationEngineTags=autoNavigationEngineTags .. ' ,' .. longitudinalEngineTags
     autoNavigationAcceleration=autoNavigationAcceleration+longitudinalAcceleration
     if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)==0 or Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<- Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5) then autoNavigationUseBrake=true end
    end

    --Lateral Translation
    local lateralStrafeEngineTags='thrust analog lateral'
    local lateralCommandType=Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
    if (lateralCommandType==axisCommandType.byThrottle) then
     local lateralStrafeAcceleration= Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
     Nav:setEngineForceCommand(lateralStrafeEngineTags,lateralStrafeAcceleration,keepCollinearity)
    elseif  (lateralCommandType==axisCommandType.byTargetSpeed) then
     local lateralAcceleration=Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
     autoNavigationEngineTags=autoNavigationEngineTags .. ' ,' .. lateralStrafeEngineTags
     autoNavigationAcceleration=autoNavigationAcceleration+lateralAcceleration
    end

    --Vertical Translation
    --VTOL
    if not vtol_system then Nav:setEngineCommand('vtol_eng',vec3.zero,vec3.zero) end
    local verticalStrafeEngineTags='thrust analog vertical'
    local verticalCommandType=Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
    if (verticalCommandType==axisCommandType.byThrottle) then
     local verticalStrafeAcceleration=Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
     Nav:setEngineForceCommand(verticalStrafeEngineTags,verticalStrafeAcceleration,keepCollinearity,'airfoil','ground','',tolerancePercentToSkipOtherPriorities)
    elseif (verticalCommandType==axisCommandType.byTargetSpeed) then
     local verticalAcceleration=Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
     autoNavigationEngineTags=autoNavigationEngineTags .. ' ,' .. verticalStrafeEngineTags
     autoNavigationAcceleration=autoNavigationAcceleration+verticalAcceleration
    end

    --Auto Navigation (Cruise Control)
    if (autoNavigationAcceleration:len()>constants.epsilon) then
     if (brakeInput~=0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward))<0.95) then autoNavigationEngineTags=autoNavigationEngineTags .. ',brake' end
     Nav:setEngineForceCommand(autoNavigationEngineTags,autoNavigationAcceleration,dontKeepCollinearity,'','','',tolerancePercentToSkipOtherPriorities)
    end

    --Rockets
    Nav:setBoosterCommand('rocket_engine')

    --PROGRADE ALIGNER/DEORBIT
    if auto_aligner then auto_align() end
  onUpdate:
   lua: |
    Nav:update()
    local data_change=false
    if M1(core.getAltitude())~=altitude then data_change=true right_panel=html_style()..monitor_right() end
    altitude=M1(core.getAltitude())
    if M1(unit.getPitch()*10)/10~=pitch_hud then data_change=true f_pitch_roll() right_panel=html_style()..monitor_right() end
    if M1(unit.getRoll()*10)/10~=roll_hud then data_change=true f_pitch_roll() right_panel=html_style()..monitor_right() end
    f_pitch_roll()
    if M1((Velocity():len())*3.6)~=speed_hud then data_change=true right_panel=html_style()..monitor_right() end
    speed_hud=M1((Velocity():len())*3.6)
    if S.getMouseWheel()==1 then data_change=true end
    local new_thr,new_mode=thr,unit.getControlMode()
    thrust_setting()
    if (new_thr~=thr or new_mode~=unit.getControlMode()) then data_change=true right_panel=html_style()..monitor_right() end
    thr=M1(unit.getThrottle())
    local new_vs=vertical_speed()
    if new_vs~=vs_hud then data_change=true right_panel=html_style()..monitor_right() end
    vs_hud=new_vs

    if data_change then
     hud=right_panel
     hud=hud .. left_panel
     if atmo_pg then S.setScreen(hud..[[</td></tr></table></div>]]..art_h_svg()) elseif (space_pg or orbit_pg) then S.setScreen(hud..[[</td></tr></table></div>]]..spc_hud()) else S.setScreen(hud..[[</td></tr></table></div>]]) end
    end
  onActionStart:
   args: [option1]
   lua: |
    if not L_SHIFT then
    --LOADING page
     unit.stopTimer("atmo_pg") unit.stopTimer("space_pg") unit.stopTimer("orbit_pg") unit.stopTimer("damage_pg")
     S.showHelper(true)

     LoadPg,atmo_pg,orbit_pg,space_pg,damage_pg=true,false,false,false,false

     left_panel=monitor_left_loading()
     hud=right_panel
     hud=hud .. left_panel
     S.setScreen(hud..[[</td></tr></table></div>]])

     unit.setTimer("LoadPg",1/30)
    end
  onActionStart:
   args: [option2]
   lua: |
    --ATMO page
     unit.stopTimer("LoadPg") unit.stopTimer("space_pg") unit.stopTimer("orbit_pg") unit.stopTimer("damage_pg")
     S.showHelper(false)

     LoadPg,atmo_pg,orbit_pg,space_pg,damage_pg=false,true,false,false,false

     left_panel=monitor_left_atmo()
     hud=right_panel
     hud=hud .. left_panel
     S.setScreen(hud..[[</td></tr></table></div>]])

     unit.setTimer("atmo_pg",1/30)
  onActionStart:
   args: [option3]
   lua: |
    --SPACE page
     unit.stopTimer("LoadPg") unit.stopTimer("atmo_pg") unit.stopTimer("orbit_pg") unit.stopTimer("damage_pg")
     S.showHelper(false)

     LoadPg,atmo_pg,orbit_pg,space_pg,damage_pg=false,false,false,true,false

     left_panel=monitor_left_space()
     hud=right_panel
     hud=hud .. left_panel
     S.setScreen(hud..[[</td></tr></table></div>]])

     unit.setTimer("space_pg",1/30)
  onActionStart:
   args: [option4]
   lua: |
    --ORBIT page
     unit.stopTimer("LoadPg") unit.stopTimer("atmo_pg") unit.stopTimer("space_pg") unit.stopTimer("damage_pg")
     S.showHelper(false)

     LoadPg,atmo_pg,orbit_pg,space_pg,damage_pg=false,false,true,false,false

     left_panel=monitor_left_orbit()
     hud=right_panel
     hud=hud .. left_panel
     S.setScreen(hud..[[</td></tr></table></div>]])

     unit.setTimer("orbit_pg",1/30)
  onActionStart:
   args: [option5]
   lua: |
    --DAMAGE page
    if DMG_Report then
     unit.stopTimer("LoadPg") unit.stopTimer("atmo_pg") unit.stopTimer("space_pg") unit.stopTimer("orbit_pg")
     S.showHelper(true)

     LoadPg,atmo_pg,orbit_pg,space_pg,damage_pg=false,false,false,false,true

     left_panel=monitor_left_damage()
     hud=right_panel
     hud=hud .. left_panel
     S.setScreen(hud..[[</td></tr></table></div>]])

     unit.setTimer("damage_pg",1/2)
    end
  onActionStart:
   args: [option6]
   lua: |
    --AUTOPILOT
     if (atmo_pg and not auto_aligner and not AgArm and unit.getAtmosphereDensity()>0) then
      if (not altitude_hold and not auto_wp) then
       if (pitch_hud<25 and pitch_hud>-15 and roll_hud<45 and roll_hud>-45) then
        TargetAltitude=core.getAltitude()
        altitude_hold,EMERdisc=true,false
        AltHoldColor="lightgreen"
        if db then if G1("databank_verification")=="Verified" then NavDatabank=true end end
       else autopilot_ecam_mode=[[<span class="tomato">Adjust Attitude</span>]] unit.setTimer("delay3sec",3) end
      elseif (altitude_hold and not auto_wp and NavDatabank) then auto_wp=true
      elseif ((altitude_hold and auto_wp) or (altitude_hold and not NavDatabank)) then
       if not EMERdisc then EMERdisc=true end
       altitude_hold,auto_wp,autopilot_ecam_mode,AltHoldColor=false,false,[[]],"none"
      end

     elseif (atmo_pg and prograde_mode and not deorbit_mode and (altitude>0 and altitude<=planet_Atmo_alt+20000) and unit.getAtmosphereDensity()==0 and speed_hud>(110*DUatlas[0][planet_id].gravity) and vs_hud>-100 and DUatlas[0][planet_id].hasAtmosphere) then
      unit.stopTimer("delay3sec") unit.stopTimer("countdown") unit.stopTimer("maintaning_orbit") unit.stopTimer("PeDist")
      auto_aligner,prograde_mode,orbit_maintainer,destination_mode,altitude_hold,auto_wp,deorbit_mode,EMERdisc=false,false,false,false,false,false,true,false
      align_active_mode,adjusting_mode,autopilot_ecam_mode=[[]],[[]],[[DEORBITING]]

     elseif ((space_pg or orbit_pg) and not atmo_pg and not AgArm and (altitude>(planet_Atmo_alt-planet_radius) or unit.getAtmosphereDensity()==0)) then
      if not auto_aligner then
       if (parking_brk_on and brakeInput==1) then parking_brk_on=false parking_brk() end
       altitude_hold,auto_wp,auto_aligner,prograde_mode=false,false,true,true
       deorbit_mode,DeorbFlight,DeorbRoll,DeorbYaw,DeorbPitch,EMERdisc=false,false,false,false,false,false
       autopilot_ecam_mode=[[Autopilot ON-M1]]

      elseif (auto_aligner and prograde_mode and not orbit_maintainer) then
       altitude_hold,auto_wp,orbit_maintainer=false,false,true
       autopilot_ecam_mode=[[Autopilot ON-M2]]
       unit.setTimer("delay3sec",3) time_to_align=4 unit.setTimer("countdown",1)
       function orbiting_mode_delay() unit.setTimer("maintaning_orbit",1/30) unit.setTimer("PeDist", 1) unit.stopTimer("delay3sec") unit.stopTimer("countdown") end

      elseif (auto_aligner and prograde_mode and orbit_maintainer) then
       unit.stopTimer("maintaning_orbit") unit.stopTimer("PeDist")
       orbit_maintainer,prograde_mode,adjusting_mode,autopilot_ecam_mode=false,false,[[]],[[Autopilot ON-M3]]
       unit.setTimer("delay3sec",3) time_to_align=4 unit.setTimer("countdown",1)
       function destination_mode_delayed() destination_mode=true unit.stopTimer("delay3sec") unit.stopTimer("countdown") adjusting_mode=[[]] end

      elseif (auto_aligner and (destination_mode or not prograde_mode)) then
       unit.stopTimer("delay3sec") unit.stopTimer("countdown")
       altitude_hold,auto_wp,auto_aligner,destination_mode=false,false,false,false
       deorbit_mode,DeorbFlight,DeorbRoll,DeorbYaw,DeorbPitch=false,false,false,false,false
       align_active_mode,autopilot_ecam_mode,adjusting_mode=[[]],[[]],[[]]
      end
     elseif AgArm then
      unit.stopTimer("delay3sec") unit.stopTimer("countdown") unit.stopTimer("maintaning_orbit") unit.stopTimer("PeDist")
      auto_aligner,prograde_mod,destination_mode,altitude_hold,auto_wp,orbit_maintainer=false,false,false,false,false,false
      align_active_mode,adjusting_mode,autopilot_ecam_mode,AltHoldColor=[[]],[[]],[[]],"none"
      if not antigrav.isActive() then agg_ecam_mode=[[AGG ON]]
      else agg_ecam_mode=[[<span class="cyan">AGG ARM</span>]] end
      antigrav.toggle()
     elseif atmo_pg then
      unit.stopTimer("delay3sec") unit.stopTimer("countdown") unit.stopTimer("maintaning_orbit") unit.stopTimer("PeDist")
      orbit_maintainer,auto_aligner,prograde_mode,destination_mode,altitude_hold,auto_wp,deorbit_mode,DeorbFlight=false,false,false,false,false,false,false,false
      DeorbRoll,DeorbYaw,DeorbPitch=false,false,false
      align_active_mode,adjusting_mode,autopilot_ecam_mode=[[]],[[]],[[]]
      brakeInput=0
     end

     if EMERdisc then deorbit_mode,DeorbFlight,CruiseSpeed=false,false,false end
  onActionStart:
   args: [option7]
   lua: |
    --BRAKE SYSTEM
     if (not parking_brk_on and not autobrake_arm and not autobrake and brakeInput<=0 ) and not L_SHIFT then
      parking_brk_on=true
      parking_brk()
     elseif (not autobrake_arm and not autobrake and not parking_brk_on and speed_hud>100) and L_SHIFT then
      autobrake_arm=true
      unit.setTimer("autobrake",1/2)
     elseif (parking_brk_on or autobrake_arm or autobrake) then
      if (parking_brk_on and brakeInput==1) then parking_brk_on=false parking_brk()
      elseif (autobrake_arm or autobrake) then autobrake_disengage() end
     end
  onActionStart:
   args: [option8]
   lua: |
    if (not du_radar_widgets and UnitType~="RemoteControlUnit") then
     local isPVPStationOn="OFF"
     if db then isPVPStationOn=G1("PVPStation") end
     if isPVPStationOn=="" then isPVPStationOn="OFF" end

     if (radar_size>0 and isPVPStationOn=="ON") then PvP() end
     if isPVPStationOn=="OFF" then _autoconf.displayCategoryPanel(radar,radar_size, "Periscope","periscope") end
     if radar_size>0 then _autoconf.displayCategoryPanel(radar,radar_size,"Radar","radar") end
     if isPVPStationOn=="OFF" then
      _autoconf.displayCategoryPanel(weapon,weapon_size, "Weapons","weapon",true)
      coreCombatStressPanelId=S.createWidgetPanel("Core combat stress")
      coreCombatStressgWidgetId=S.createWidget(coreCombatStressPanelId,"core_stress")
      S.addDataToWidget(core.getWidgetDataId(),coreCombatStressgWidgetId)
     end
     du_radar_widgets=true

     if shield~=nil then shield.showWidget() end

    elseif (du_radar_widgets and UnitType~="RemoteControlUnit") then
     unit.stopTimer("PVPupdate") unit.stopTimer("PVPsender") unit.stopTimer("CheckRadarOp")
     if db then
      if UnitIsCockpit then G2("PVPCockpit","OFF") elseif UnitIsSeat then G2("PVPGunner","OFF") end
      G2("PVPStationData","")
     end
     _autoconf.hideCategoryPanels() S.destroyWidgetPanel(coreCombatStressPanelId) S.destroyWidgetPanel(radarPanel) du_radar_widgets=false

     if shield~=nil then shield.hideWidget() end
    end
    if Nav.control.isRemoteControlled() then rcfreeze=not rcfreeze; player.freeze(rcfreeze) end
  onActionStart:
   args: [option9]
   lua: |
    --WIDGETS SHOW
     if not du_widgets then unit.showWidget() core.showWidget()
      if warpdrive~=nil then warpdrive.showWidget() end
      parentingPanelId=S.createWidgetPanel("Docking")
      parentingWidgetId=S.createWidget(parentingPanelId,"parenting")
      S.addDataToWidget(unit.getWidgetDataId(),parentingWidgetId)
      du_widgets=true
    --WIDGETS HIDE
     elseif du_widgets then unit.hideWidget() core.hideWidget()
      if warpdrive~=nil then warpdrive.hideWidget() end
      S.destroyWidgetPanel(parentingPanelId)
      S.destroyWidgetPanel(coreCombatStressPanelId)
      _autoconf.hideCategoryPanels()
      du_widgets,du_radar_widgets=false,false
     end
  onActionStart:
   args: [gear]
   lua: |
    if not GearInhibit then gearExtended=not gearExtended
     if gearExtended then Nav.control.deployLandingGears() else Nav.control.retractLandingGears() end
    end
  onActionStart:
   args: [light]
   lua: |
    if Nav.control.isAnyHeadlightSwitchedOn() then Nav.control.switchOffHeadlights() else Nav.control.switchOnHeadlights() end
    if db then helmet_hud_color() end
  onActionStart:
   args: [forward]
   lua: pitchInput=pitchInput-1
  onActionStop:
   args: [forward]
   lua: pitchInput=0
  onActionStart:
   args: [backward]
   lua: pitchInput=pitchInput+1
  onActionStop:
   args: [backward]
   lua: pitchInput=0
  onActionStart:
   args: [left]
   lua: rollInput=rollInput-1
  onActionStop:
   args: [left]
   lua: rollInput=0
  onActionStart:
   args: [right]
   lua: rollInput=rollInput+1
  onActionStop:
   args: [right]
   lua: rollInput=0
  onActionStart:
   args: [straferight]
   lua: if not L_ALT then Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral,1.0) end
  onActionStop:
   args: [straferight]
   lua: if not L_ALT then Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral,-1.0) end
  onActionStart:
   args: [strafeleft]
   lua: if not L_ALT then Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral,-1.0) end
  onActionStop:
   args: [strafeleft]
   lua: if not L_ALT then Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral,1.0) end
  onActionStart:
   args: [up]
   lua: if not L_ALT then Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization() Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical,1.0) end
  onActionStop:
   args: [up]
   lua: if not L_ALT then Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical,-1.0) Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization) end
  onActionStart:
   args: [down]
   lua: if not L_ALT then Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization() Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical,-1.0) end
  onActionStop:
   args: [down]
   lua: if not L_ALT then Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical,1.0) Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization) end
  onActionStart:
   args: [groundaltitudeup]
   lua: |
    if (speed_hud<150 and not AgArm) then Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0) end
    if (altitude_hold and speed_hud>=150 and not AgArm) then TargetAltitude=TargetAltitude +100 end
    if (antigrav~=nil and AgArm) then antigrav_target_alt=antigrav_target_alt +10
     if DbInit=="Verified" then db.setIntValue("agg_t_alt",antigrav_target_alt) end
     antigrav.setBaseAltitude(antigrav_target_alt)
     if antigrav.isActive() then agg_ecam_mode=[[AGG ON]] else agg_ecam_mode=[[<span class="cyan">AGG ARM</span>]] end
    end
  onActionLoop:
   args: [groundaltitudeup]
   lua: |
    if (speed_hud<150 and not AgArm) then Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0) end
    if (altitude_hold and speed_hud>=150 and not AgArm) then TargetAltitude=TargetAltitude +1 end
    if (antigrav~=nil and AgArm) then antigrav_target_alt=antigrav_target_alt +10
     if DbInit=="Verified" then db.setIntValue("agg_t_alt",antigrav_target_alt) end
     antigrav.setBaseAltitude(antigrav_target_alt)
     if antigrav.isActive() then agg_ecam_mode=[[AGG ON]] else agg_ecam_mode=[[<span class="cyan">AGG ARM</span>]] end
    end
  onActionStart:
   args: [groundaltitudedown]
   lua: |
    if (speed_hud<150 and not AgArm) then Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0) end
    if (altitude_hold and speed_hud>=150 and not AgArm) then TargetAltitude=TargetAltitude -100 end
    if (antigrav~=nil and AgArm) then antigrav_target_alt=antigrav_target_alt -10
     if antigrav_target_alt<1000 then antigrav_target_alt=1000 end
     antigrav.setBaseAltitude(antigrav_target_alt)
     if DbInit=="Verified" then db.setIntValue("agg_t_alt",antigrav_target_alt) end
     if antigrav.isActive() then agg_ecam_mode=[[AGG ON]] else agg_ecam_mode=[[<span class="cyan">AGG ARM</span>]] end
    end
  onActionLoop:
   args: [groundaltitudedown]
   lua: |
    if (speed_hud<150 and not AgArm) then Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0) end
    if (altitude_hold and speed_hud>=150 and not AgArm) then TargetAltitude=TargetAltitude -1 end
    if (antigrav~=nil and AgArm) then antigrav_target_alt=antigrav_target_alt -10
     if antigrav_target_alt<1000 then antigrav_target_alt=1000 end
     antigrav.setBaseAltitude(antigrav_target_alt)
     if DbInit=="Verified" then db.setIntValue("agg_t_alt",antigrav_target_alt) end
     if antigrav.isActive() then agg_ecam_mode=[[AGG ON]] else agg_ecam_mode=[[<span class="cyan">AGG ARM</span>]] end
    end
  onActionStart:
   args: [yawright]
   lua: yawInput=yawInput-1
  onActionStop:
   args: [yawright]
   lua: yawInput=0
  onActionStart:
   args: [yawleft]
   lua: yawInput=yawInput+1
  onActionStop:
   args: [yawleft]
   lua: yawInput=0
  onActionStart:
   args: [brake]
   lua: |
    brakeInput=brakeInput+1 CTRL=true
    local longitudinalCommandType=Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
    if (longitudinalCommandType==axisCommandType.byTargetSpeed) then local targetSpeed=Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
     if (math.abs(targetSpeed)>constants.epsilon) then Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal,- utils.sign(targetSpeed)) end
    end
  onActionStop:
   args: [brake]
   lua: brakeInput=brakeInput-1 CTRL=false
  onActionLoop:
   args: [brake]
   lua: |
    local longitudinalCommandType=Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
    if (longitudinalCommandType==axisCommandType.byTargetSpeed) then local targetSpeed=Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
     if (math.abs(targetSpeed)>constants.epsilon) then Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal,- utils.sign(targetSpeed)) end
    end
  onActionStart:
   args: [booster]
   lua: Nav:toggleBoosters()
  onActionStart:
   args: [stopengines]
   lua: if not L_SHIFT then Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal) end
  onActionStart:
   args: [speedup]
   lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal,1.0)
  onActionLoop:
   args: [speedup]
   lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal,1.0)
  onActionStart:
   args: [speeddown]
   lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal,-1.0)
  onActionLoop:
   args: [speeddown]
   lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal,-1.0)
  onActionStart:
   args: [antigravity]
   lua: |
    if (antigrav~=nil and not atigrav_widget) then antigrav.showWidget()
     atigrav_widget,AgArm,agg_ecam_mode=true,true,[[<span class="cyan">AGG ARM</span>]]
     if DbInit=="Verified" then G2("nav agg","STBY") G2("agg eng/stby","STBY") G2("agg off/stby","STBY") unit.setTimer("antigravity",1) end
    elseif (antigrav~=nil and atigrav_widget) then unit.stopTimer("antigravity",1)
     if DbInit=="Verified" then G2("nav agg","OFF") G2("agg eng/stby","STBY") G2("agg off/stby","OFF") end
     antigrav.hideWidget() antigrav.deactivate()
     atigrav_widget,AgArm,agg_ecam_mode=false,false,[[]]
    end
  onActionStart:
   args: [warp]
   lua: if warpdrive~=nil then warpdrive.activateWarp() end
  onActionLoop:
   args: [lshift]
   lua: L_SHIFT,GearInhibit=true,true
  onActionStop:
   args: [lshift]
   lua: L_SHIFT,GearInhibit=false,false
  onActionLoop:
   args: [lalt]
   lua: L_ALT=true
  onActionStop:
   args: [lalt]
   lua: L_ALT=false
  onActionStop:
   args: [stopengines]
   lua: if L_SHIFT then VtolGyro() end stopengines_pressed=false
  onActionStop:
   args: [option15]
   lua: ThrRev=false
  onActionLoop:
   args: [option15]
   lua: if S.getActionKeyName(option15) then ThrRev=true end
  onActionLoop:
   args: [option16]
   lua: if S.getActionKeyName(option16) then VtolGyro() end
  onInputText(text):
   lua: |
    local T=text
    local check=string.find(T,"/help")
    if check then
     S.print("1 << REMOTE CONTROLLER >>") S.print("Player Freeze = ALT+8") S.print("")
     S.print("2 << FLIGHT MODES >>") S.print("LOAD = ALT+1") S.print("AI   = ALT+2") S.print("SPC  = ALT+3") S.print("ORB  = ALT+4") S.print("DMG  = ALT+5") S.print("")
     S.print("3 << HELMET HUD >>") S.print("Cycle Colors = SHIFT+L") S.print("")
     S.print("4 << AUTOMATIONS >>") S.print("ALT HOLD = 1x ALT+6 (AI)") S.print("Altitude +/- 100m = ALT+SpaceBar/C") S.print("Autopilot ON = 2x ALT+6 (AI)") S.print("Align PROGRADE = 1x ALT+6 (LOAD,SPC,ORB,DMG)") S.print("DEORBITING = 1x ALT+6 (AI+Conditions)") S.print("Maint. ORBIT = 2x ALT+6 (LOAD,SPC,ORB,DMG)") S.print("Align DESTINATION = 3x ALT+6 (LOAD,SPC,ORB,DMG)") S.print("")
     S.print("5 << BRAKING SYSTEM >>") S.print("Parking Brake ON/OFF = ALT+7") S.print("Autobrake ARM ON/OFF = L.SHIFT+ALT+7 (spd>100)") S.print("")
     S.print("6 << AGG >>") S.print("ARM/OFF = ALT+G") S.print("ON/ARM = ALT+6 (Override any active mode)") S.print("Target Altitude +/- = ALT+SpaceBar/C") S.print("")
     S.print("7 << WEAPONS AND RADAR >>") S.print("ON/OFF = ALT+8") S.print("Shield Venting ON/OFF = L.SHIFT+G") S.print("")
     S.print("8 << WIDGETS >>") S.print("ON/OFF = ALT+9") S.print("")
     S.print("9 << VTOL >>") S.print("Tag the VTOL engines with vtol_eng") S.print("ON/OFF = L.SHIFT+MMB") S.print("")
     S.print("10 << GYRO >>") S.print("ON/OFF = L.SHIFT+MMB")
    end
 construct:
  onStart:
   lua: |
    function ConstructMass() local M=M1(construct.getMass()/1000*10)/10 return M end
    function ConstructPos() local P=vec3(construct.getWorldPosition()) return P end
    function ConstructVel() local V=vec3(construct.getWorldVelocity()) return V end
    function Velocity() local V=vec3(construct.getVelocity()) return V end
    function AngVelocity() local A=vec3(construct.getWorldAngularVelocity()) return A end
    function AirFriction() local A=vec3(construct.getWorldAirFrictionAngularAcceleration()) return A end
    function Forward() local F=vec3(construct.getWorldOrientationForward()) return F end
    function Up() local U=vec3(construct.getWorldOrientationUp()) return U end
    function Right() local R=vec3(construct.getWorldOrientationRight()) return R end
    function ConstructId() local I=construct.getId() return I end
    function ConstructDockingMode() local D=construct.getDockingMode() return D end
    function DockedConstructMass(v) local M=construct.getDockedConstructMass(v) return M end
    function Parent() local P=construct.getParent() return P end
    function ClosestParent() local P=construct.getClosestParent() return P end
    function DockedConstruct() local D=construct.getDockedConstructs() return D end
    function PlayerOnBoard() local P=construct.getPlayersOnBoard() return P end
    function PlayerMass(v) local M=construct.getBoardedPlayerMass(v) return M end
    function SZone() local D=M1(construct.getDistanceToSafeZone()/1000*10)/10 return D end
    function MaxBrake() local B=construct.getMaxBrake()/1000 return B end
    function MaxSpeed() local S=construct.getMaxSpeed()*3.6 return S end
    function MaxBurnSpeed() local S=construct.getFrictionBurnSpeed()*3.6 return S end